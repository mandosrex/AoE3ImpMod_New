//==============================================================================
// Constants
/*
	Last updated by
	ageekhere 2021/10/15
	V 2.52
*/
//==============================================================================

// Temporary constants, to be deleted if implemented in C++
extern bool debugMessage = false; //shows debug messages 
extern int debugLevel = 0; //debug Level
extern string versionNumber = "2.52 2021/10/15";
extern const int		cNumResourceTypes = 3;  // Gold, food, wood.
extern float   baselineHandicap = 1.0;    // This is the handicap given to cDifficultyHard.  Our intent is to ship with this at 1.0,
// meaning that hard has no handicap advantage or penalty.
// All other difficulty levels will be adjusted relative to this constant.  This means that
// we can gradually reduce this number as the AI's competence increases, and all the difficulty levels will respond.
extern int           gMaxPop = 250;             // Absolute hard limit pop cap for game...will be set lower on some difficulty levels 
extern int     gMaxPopFixValue = 350; 	// Absolute hard limit pop cap for game...fixed unchangeable value
extern const int     cMaxSettlersPerPlantation = 10;

// Start mode constants.
extern const int     cStartModeScenarioNoTC = 0;   // Scenario, wait for aiStart unit, then play without a TC
extern const int     cStartModeScenarioTC = 1;     // Scenario, wait for aiStart unit, then play with starting TC
extern const int     cStartModeScenarioWagon = 2;  // Scenario, wait for aiStart unit, then start TC build plan.
extern const int     cStartModeBoat = 3;           // RM or GC game, with a caravel start.  Wait to unload, then start TC build plan.
extern const int     cStartModeLandTC = 4;         // RM or GC game, starting with a TC...just go.
extern const int     cStartModeLandWagon = 5;      // RM or GC game, starting with a wagon.  Explore, start TC build plan.

//ai civ max villager pop
extern int maxVillPop = 100; //will hold the max village pop

//==============================================================================
// Econ variables
//==============================================================================
extern int  gDefaultDeck = -1;   // Home city deck used by each AI
extern bool gTimeToFarm = false;    // Set true when we start to run out of cheap early food.
extern bool gTimeForPlantations = false;  // Set true when we start to run out of mine-able gold.
extern int  gEconUnit = cUnitTypeSettler; // Set appropriately for the different civilizations later.
extern int  gHouseUnit = cUnitTypeHouse;  // Housing unit, different per civ.
extern int  gTowerUnit = cUnitTypeOutpost;   // Tower unit, blockhouse for Russians, huts and teepees for natives, castle for Asians.
extern int  gFarmUnit = cUnitTypeMill;    // Will be farm for natives and rice paddy for Asians.
extern int  gPlantationUnit = cUnitTypePlantation;    // Will be farm for natives and rice paddy for Asians.
extern int  gLivestockPenUnit = cUnitTypeLivestockPen;    // The Asians all have different ones.
extern int  gCoveredWagonUnit = cUnitTypeCoveredWagon;    // Allow for a different type (currently none).
extern int  gMarketUnit = cUnitTypeMarket;    // The Asians have a different type.
extern int  gDockUnit = cUnitTypeDock;    // The Asians have a different type.
extern int  gSpecialUnit = cUnitTypeMusketeer; // Set appropriately for the different civilizations later.
extern int  gTownCenter = cUnitTypeTownCenter; 

extern int  gBarracksUnit = cUnitTypeBarracks; // Set appropriately for the different civilizations later.
extern int  gStableUnit = cUnitTypeStable; // Set appropriately for the different civilizations later.
extern int  gArtilleryDepotUnit = cUnitTypeArtilleryDepot; // Set appropriately for the different civilizations later.

extern bool gFlagChosen = false;  // need to make sure they only build one
extern int  gLastTribSentTime = 0;
extern int  gEconUpgradePlan = -1;
extern int gTCBuildPlanID = -1;
extern int gStartMode = -1;    // See start mode constants, above.  This variable is set 
// in main() and is used to decide which cascades of rules
// should be used to start the AI.
extern bool gGoodFishingMap = false;    // Set in init(), can be overridden in postInit() if desired.  True indicates that fishing is a good idea on this map.
extern int  gFishingPlan = -1;      // Plan ID for main fishing plan.
extern int mainDockPlan = -1;
extern int gFishingBoatMaintainPlan = -1; // Fishing boats to maintain
extern int gFishingUnit = cUnitTypeFishingBoat; // Fishing Boat
extern int gNumFishBoats = 0;    // Set in the rule startFishing, higher for boomers.
extern int  gHerdPlanID = -1;
extern int gSettlerMaintainPlan = -1;   // Main plan to control settler population
extern int gTransportUnit = cUnitTypeAbstractWarShip;  // hard coded ship type for now
extern int  gWaterTransportUnitMaintainPlan = -1;  // The plan that maintains all the ships
extern int  gWaterExplorePlan = -1;    // Plan ID for ocean exploration plan
extern bool gWaterMap = false;               // True when we are on a water map
extern int  gNavyDefendPlan = -1;
extern int  gNavyAttackPlan = -1;
extern vector unloadLocation = cInvalidVector;
extern vector loadLocation = cInvalidVector;

extern vector gTCSearchVector = cInvalidVector;  // Used to define the center of the TC building placement search.
extern int   gTCStartTime = 10000;                   // Used to define when the TC build plan can go active.  In ms.
extern int  gAgeUpResearchPlan = -1;      // Plan used to send politician from HC, used to detect if an age upgrade is in progress.
extern int gNuggetMessagePercentage = 100;
extern int gFeedGoldTo = -1;     // If set, this indicates which player we need to be supplying with regular gold shipments.
extern int gFeedWoodTo = -1;     // See commsHandler and monitorFeeding rule.
extern int gFeedFoodTo = -1;
extern const int  cForwardBaseStateNone = -1;      // None exists, none in progress
extern const int  cForwardBaseStateBuilding = 0;   // Fort wagon exists, but no fort yet.
extern const int  cForwardBaseStateActive = 1;     // Base is active, defend and train plans there.
extern int gForwardBaseState = cForwardBaseStateNone;
extern int gForwardBaseID = -1;                    // Set when state goes to Active
extern vector gForwardBaseLocation = cInvalidVector;  // Set when state goes to 'building' or earlier.
extern vector gBackBaseLocation = cInvalidVector;  
extern int gForwardBaseBuildPlan = -1;
extern int  gNativeDancePlan = -1;
bool baseRelocate = false;
bool baseRelocateEver = false;
//==============================================================================
// Military variables
//==============================================================================
extern int  gLandDefendPlan0 = -1;   // Primary land defend plan
extern int  gLandReservePlan = -1;     // Reserve defend plan, gathers units for use in the next military mission
//extern int  gWaterDefendPlan0 = -1;    // Primary water defend plan
extern bool gDefenseReflex = false;    // Set true when a defense reflex is overriding normal ops.
extern bool gDefenseReflexPaused = false; // Set true when we're in a defense reflex, but overwhelmed, so we're hiding to rebuild an army.
extern int  gDefenseReflexBaseID = -1; // Set to the base ID that we're defending in this emergency
extern vector  gDefenseReflexLocation = cInvalidVector;  // Location we're defending in this emergency
extern int  gDefenseReflexStartTime = 0;
extern int  gLandUnitPicker = -1;      // Picks the best land military units to train.
extern int  gMainAttackGoal = -1;      // Attack goal monitors opportunities, launches missions.
extern int  newAttackGoal = -1;      // Attack goal monitors opportunities, launches missions.
extern int  gCaravelMaintain = -1;     // Maintain plans for naval units.
extern int  gGalleonMaintain = -1;
extern int  gFrigateMaintain = -1;
extern int  gMonitorMaintain = -1;
extern int  gWaterExploreMaintain = -1;
extern int  gCaravelUnit = cUnitTypeCaravel; // Will be Galley for Ottomans, Canoe for natives, War Junk for Chinese, Fune for Japanese
extern int  gGalleonUnit = cUnitTypeGalleon; // Will be Fluyt for Dutch, War Canoe for natives, Fuchuan for Chinese, Atakabune for Japanese
extern int  gFrigateUnit = cUnitTypeFrigate; // Will be Tekkousen for Japanese
extern bool gNavyMap = false;    // Setting this false prevents navies
extern const int cNavyModeOff = 0;
//extern const int cNavyModeExplore = 1;
extern const int cNavyModeActive = 2;
extern int  gNavyMode = cNavyModeOff; // Tells us whether we're making no navy, just an exploring ship, or a full navy.
extern vector gNavyVec = cInvalidVector;  // The center of the navy's operations.
extern int  gNumArmyUnitTypes = 19;    // How many land unit types do we want to train?
extern int  gGoodArmyPop = -1;         // This number is updated by the pop manager, to give a ballpark feel for the pop count needed to create a credible
// attack army.  It is based on military pop allowed and game time, and is very sensitive to difficulty level.  
// This is used by the strategyMaster rule to help decide when certain mission types make sense.  For example, if 
// your available military pop is only 1/2 of gGoodArmyPop, a base attack would be foolish, but villager raiding or
// claiming a VP site might be good choices.  
extern int  gUnitPickSource = cOpportunitySourceAutoGenerated;  // Indicates who decides which units are being trained...self, trigger, or ally player.
extern int  gUnitPickPlayerID = -1;                // If the source is cOpportunitySourceAllyRequest, this will hold the player ID.
extern int  gMostRecentAllyOpportunityID = -1;  // Which opportunity (if any) was created by an ally?  (Only one at a time allowed.)
extern int  gMostRecentTriggerOpportunityID = -1;  // Which opportunity (if any) was created by a trigger?  (Only one at a time allowed.)
extern int  gLastClaimMissionTime = -1;
extern int  gLastAttackMissionTime = -1;
extern int  gLastDefendMissionTime = -1;
extern int  gClaimMissionInterval = 600000;  // 10 minutes.  This variable indicates how long it takes for claim opportunities to score their maximum.  Typically, a new one will launch before this time.
extern int  gAttackMissionInterval = 180000; // 3 minutes.  Suppresses attack scores (linearly) for 3 minutes after one launches.  Attacks will usually happen before this period is over.
extern int  gDefendMissionInterval = 300000;  // 5 minutes.   Makes the AI less likely to do another defend right after doing one.
extern bool gDelayAttacks = false;     // Can be used on low difficulty levels to prevent attacks before the AI is attacked.  (AI is defend-only until this variable is
//==============================================================================
// Other global variables
//==============================================================================
extern bool gSPC = false;           // Set true in main if this is an spc or campaign game
extern int  gExplorerControlPlan = -1; // Defend plan set up to control the explorer's location
extern int  gLandExplorePlan = -1;  // Primary land exploration
extern int  gMainBase = -1;
extern bool gBuildWalls = false;    // Global indicating if we're walling up or not.
extern int  gNumTowers = -1;         // How many towers do we want to build?
extern int  gPrevNumTowers = -1;     // Set when a command is received, to allow resetting when a cancel is received.
extern bool gIsMonopolyRunning = false; // Set true while a monopoly countdown is in effect.
extern int  gMonopolyTeam = -1;         // TeamID of team that will win if the monopoly timer completes.
extern int  gMonopolyEndTime = -1;      // Gametime when current monopoly should end
extern bool gIsKOTHRunning = false; // Set true while a KOTH countdown is in effect.
extern int  gKOTHTeam = -1;         // TeamID of team that will win if the KOTH timer completes.
//updatedOn 2019/04/04 By ageekhere  
//---------------------------
extern int ourTeamSizeMain = 1; //stores the team size
//docks
extern int dockBuikdNum = 2; //Sets the amount of docks an ai can build at the given age
extern int dockPlacement0 = 1; //dock placement main base
extern int dockPlacement1 = 0; //dock placement flag
//wall
extern vector wallMidPosition = cInvalidVector; //The middle of the team position
extern bool activateWallUpgrade = false; //Upgrade wall
extern float wallSize = 0; //The wall size
extern vector wallPosition = cInvalidVector; //The wall location
//Wall layers
extern int wallPlanNumber = 1;
extern int wallPlanNumberP1 = 1;
extern int wallPlanNumberP2 = 1;
extern int wallPlanNumberP3 = 1;
extern int wallPlanNumberP4 = 1;
extern int wallPlanNumberP5 = 1;
extern int wallPlanNumberP6 = 1;
extern int wallPlanNumberP7 = 1;
extern int wallPlanNumberP8 = 1;
//Foward base
extern vector buildFrontLocation = cInvalidVector; //base locaiton
extern int buildListArray = -1;
extern int fowardBaseCount = 0;
extern int fowardBaseDelay = 10;
//Runaway base
extern int newBase = 0;
extern int newBaseAi = 0;
extern int runAwayCount = 0;
extern bool waitingForRevolt = false;
extern bool revolted = false;
extern int capedPop = -1;
extern bool controlCenter = false;
extern int currentSlaughter = -1;
extern int currentHunt = -1;
extern int excludeLivestockArray = -1; 
extern int excludeBuildingArray = -1; 
extern int excludeSettlersArray = -1;
extern int huntSettlersArray = -1;
extern int huntUnitMoveTo = -1;
//extern int garrisonArray = -1; 
extern bool losingDigin = false;
extern int gatherRange = 50;
extern int petardTarget = -1;
extern int gatherHuntingNum = 0;
extern int gatherChopNum = 0;
extern int gatherMineNum = 0;
extern int gatherBerryNum = 0;
extern int gatherHerdNum = 0;
extern bool idleLifestock = false;

extern int shorelineArray = -1;
extern int wallAreaArray = -1;
extern int transportShipsArray = -1;
int currentShipTransport = -1;
extern int shorelineEnemyBuildingsArray = -1;
extern bool islandLanded = false;
extern int islandLandedLocationUnit = -1;
extern bool reallocateSettlers = false;
extern bool forceReallocateSettlers = false;
//extern bool outOfOpening = true;
//extern int openingType = -1; //0 = Jan rush
//==============================================================================
// Function forward declarations.
//
// Used in loader file to override default values, called at start of main()
mutable void preInit(void) {}

// Used in loader file to override initialization decisions, called at end of main()
mutable void postInit(void) {}

mutable void econMaster(int mode=-1, int value=-1) {}
mutable void shipGrantedHandler(int parm=-1) {}
mutable int initUnitPicker(string name="BUG", int numberTypes=1, int minUnits=10,int maxUnits=20, int minPop=-1, int maxPop=-1, int numberBuildings=1, bool guessEnemyUnitType=false) {return(-1);}
mutable void updateForecasts(void) {}
mutable void setUnitPickerPreference(int upID=-1) {}
mutable void endDefenseReflex(void) {}
//==============================================================================
// Global Arrays
//==============================================================================
// Forecast float array initialized below.
extern int  gForecasts = -1;
extern int  gMapNames = -1;   // An array of random map names, so we can store ID numbers in player histories
extern int  gTargetSettlerCounts = -1; // How many settlers do we want per age?
extern int  gConsulateTechs = -1; //List of all the consulate techs
extern int  gConsulateTechsSize = -1; //Size of the list of all the consulate techs
extern int  gAsianWonders = -1; //List of wonders for the Asian civs
extern int  gAge2PoliticianList = -1; // List of Age 2 European politicians
extern int  gAge3PoliticianList = -1; // List of Age 3 European politicians
extern int  gAge4PoliticianList = -1; // List of Age 4 European politicians
extern int  gAge5PoliticianList = -1; // List of Age 5 European politicians
extern int  gAge2WonderList = -1; // List of Age 2 Asian age-up wonders
extern int  gAge3WonderList = -1; // List of Age 3 Asian age-up wonders
extern int  gAge4WonderList = -1; // List of Age 4 Asian age-up wonders
extern int  gAge5WonderList = -1; // List of Age 5 Asian age-up wonders
extern int  gAge2WonderTechList = -1; // List of Age 2 Asian age-up technologies
extern int  gAge3WonderTechList = -1; // List of Age 3 Asian age-up technologies
extern int  gAge4WonderTechList = -1; // List of Age 4 Asian age-up technologies
extern int  gAge5WonderTechList = -1; // List of Age 5 Asian age-up technologies
extern int  gAgeUpPoliticians = -1; // Array of available age-up politicians
extern int  gPoliticianScores = -1; // Array used to calculate "scores" for different European politicians
extern int  gNatCouncilScores = -1; // Array used to calculate "scores" for different native council members
extern int  gAsianWonderScores = -1; // Array used to calculate "scores" for different Asian wonders
//==============================================================================
// debugRule
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
void debugRule(string message = "DEFAULT")
{ //create debug messages
	aiChat( 1,"Debug: " + message + " Time "+ xsGetTime() );
	aiEcho( "Debug: " + message + " Time "+ xsGetTime() );
}

//==============================================================================
// echoMessage
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
void echoMessage(string message="DEFAULT")
{ //Provides on-screen debug information.
	for( i = 1; < cNumberPlayers )
	{ //loop through all players starting from player 1
		aiChat( i, message ); //send message to player
	} //end for
} //end echoMessage

//==============================================================================
// MIN
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
float MIN(float a=0.0, float b=0.0)
{ //returns the lowest value between two values 
	if( debugMessage == true && debugLevel > 1 ) debugRule( "float MIN " + a + " " + b );
	if( a < b ) return(a); // a is lower
	return(b); //b is lower
} //end MIN

//==============================================================================
// MAX
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
float MAX(float a=0.0, float b=0.0)
{ //returns the largest value between two values 
	if( debugMessage == true && debugLevel > 1 ) debugRule( "float MAX " + a + " " + b );
	if( a < b ) return(b);
	return(a);
} //end MAX

//==============================================================================
// sendChatToAllies
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
void sendChatToAllies(string text="")
{ //send chat message to Allies
	if( debugMessage == true && debugLevel > 1 ) debugRule( "void sendChatToAllies " + text);
	for( i = 1; < cNumberPlayers )
	{ //loop through all players starting from player 1
		if( (i != cMyID) && (kbIsPlayerAlly(i) == true) ) aiChat( i, text ); //if the current player "i" is not me and is my Ally send chat 
	} //end for
} //end sendChatToAllies

//==============================================================================
// civIsNative
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
bool civIsNative(void)
{ //checks if a civ is native
	if( debugMessage == true && debugLevel > 1 ) debugRule( "bool civIsNative " );
	if ( (cMyCiv == cCivXPAztec) || (cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPSioux) ) return(true); //check for match
	return(false); //no match
}//end civIsNative

//==============================================================================
// civIsAsian
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
bool civIsAsian(void)
{ //checks if a civ is Asian
	if( debugMessage == true && debugLevel > 1 ) debugRule( "bool civIsAsian " );
	if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivChinese) || (cMyCiv == cCivIndians) || 
		(cMyCiv == cCivSPCIndians) || (cMyCiv == cCivSPCChinese) || (cMyCiv == cCivSPCJapanese) || 
	(cMyCiv == cCivSPCJapaneseEnemy) ) return(true); //is Asian
	return(false); //not Asian
} //end civIsAsian

//==============================================================================
// getSettlerShortfall
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
int getSettlerShortfall()
{  //How many more Settlers do we currently want?
	if( debugMessage == true && debugLevel > 1 ) debugRule( "int getSettlerShortfall " );
    static int getAllSettlersQuery = -1; //Find all the different Settlers Query
	if(getAllSettlersQuery == -1) getAllSettlersQuery = kbUnitQueryCreate("getAllSettlersQuery");
	kbUnitQuerySetPlayerID(getAllSettlersQuery, cMyID, false);
	kbUnitQuerySetUnitType(getAllSettlersQuery, cUnitTypeLogicalTypeAffectedByTownBell); //use LogicalTypeAffectedByTownBell to get all settlers  
	kbUnitQuerySetState(getAllSettlersQuery, cUnitStateAlive);	 
	kbUnitQueryResetResults(getAllSettlersQuery);
	return( xsArrayGetInt(gTargetSettlerCounts, kbGetAge()) - kbUnitQueryExecute(getAllSettlersQuery) ); //the target settler count for the age - number of ALL settler unit kinds
} //end getSettlerShortfall

//==============================================================================
// agingUp
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
bool agingUp()
{ //checks if the ai is aging up
	if( debugMessage == true && debugLevel > 1 ) debugRule( "bool agingUp " );
	if (aiPlanGetState(gAgeUpResearchPlan) == cPlanStateResearch) return(true); //check plan Status of gAgeUpResearchPlan
	return(false);
} //end agingUp

//==============================================================================
// getPreferredWonderToBuild
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
int getPreferredWonderToBuild(int the_age=-1)
{ //sets the Wonder preferred wonder to build per age
	if( debugMessage == true && debugLevel > 1 ) debugRule( "int getPreferredWonderToBuild " + the_age);
	if (the_age == cAge2) return( xsArrayGetInt(gAsianWonders, 0) );
	if (the_age == cAge3) return( xsArrayGetInt(gAsianWonders, 1) );
	if (the_age == cAge4) return( xsArrayGetInt(gAsianWonders, 2) );
	if (the_age == cAge5) 
	{
		if (aiGetGameMode() == cGameModeDeathmatch) return(-1); //BHG:CGN: don't try to get to age 5 in a deathmatch game
		return(xsArrayGetInt(gAsianWonders, 3));
	} //end if
	return (-1);
} //end getPreferredWonderToBuild

//==============================================================================
// mapIsIsland
// updatedOn 2020/10/15 By ageekhere
//==============================================================================
bool mapIsIsland(void)
{
	if ( debugMessage == true && debugLevel > 1 ) debugRule( "bool mapIsIsland ");
	if ((cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "ceylon")) return(true);
	return(false);
}
//==============================================================================
/* createOpportunity(type, targetType, targetID, targetPlayerID, source)
	
	A wrapper function for aiCreateOpportunity(), to permit centralized tracking
	of the most recently created ally-generated and trigger-generated 
	opportunities.  This info is needed so that a cancel command can
	efficiently deactivate the previous (and possibly current) opportunity before
	creating the new one.
*/
//==============================================================================
int createOpportunity(int type = -1, int targetType = -1, int targetID = -1, int targetPlayerID = -1, int source = -1)
{
	int oppID = aiCreateOpportunity(type, targetType, targetID, targetPlayerID, source);
	if (source == cOpportunitySourceAllyRequest)
	gMostRecentAllyOpportunityID = oppID; // Remember which ally opp we're doing
	else if (source == cOpportunitySourceTrigger)
	gMostRecentTriggerOpportunityID = oppID;
	
	return(oppID);
}

//==============================================================================
/* sendStatement(player, commPromptID, vector)
	
	Sends a chat statement, but first checks the control variables and updates the
	"ok to chat" state.   This is a gateway for routine "ambience" personality chats.
	Another function will be written as a gateway for strategic communications, i.e.
	requests for defence, tribute, joint operations, etc.  That one will be controlled by 
	the cvOkToChat variable.
	
	If vector is not cInvalidVector, it will be added as a flare
*/
//==============================================================================
bool sendStatement(int playerIDorRelation = -1, int commPromptID = -1, vector vec = cInvalidVector)
{
	//aiEcho("<<<<<SEND STATEMENT to player "+playerIDorRelation+", commPromptID = "+commPromptID+", vector "+vec+">>>>>");
	// Routine "ambience" chats are not allowed
	if (cvOkToTaunt == false)
	{
		// Failed, no chat sent
		// Make sure the C++ side knows about it
		aiCommsAllowChat(false);
		return(false);
	}
	
	// If we got this far, it's OK.
	aiCommsAllowChat(true);
	
	// It's a player ID, not a relation.
	if (playerIDorRelation < 100)
	{
		int playerID = playerIDorRelation;
		if (vec == cInvalidVector)
		aiCommsSendStatement(playerID, commPromptID);
		else
		aiCommsSendStatementWithVector(playerID, commPromptID, vec);
	}
	else  // Then it's a player relation
	{
		int player = -1;
		for (player = 1; < cNumberPlayers)
		{
			bool send = false;
			switch(playerIDorRelation)
			{
				case cPlayerRelationAny:
				{
					send = true;
					break;
				}
				case cPlayerRelationSelf:
				{
					if (player == cMyID)
					send = true;
					break;
				}
				case cPlayerRelationAlly:
				{
					send = kbIsPlayerAlly(player);
					
					// Don't talk to myself, even though I am my ally.
					if (player == cMyID)
					send = false;     
					break;
				}
				case cPlayerRelationEnemy:
				{
					send = kbIsPlayerEnemy(player);
					break;
				}
				case cPlayerRelationEnemyNotGaia:
				{
					send = kbIsPlayerEnemy(player);
					break;
				}
			}
			if (send == true)
			{
				//aiEcho("<<<<<Sending chat prompt "+commPromptID+" to player "+player+" with vector "+vec+">>>>>");
				if (vec == cInvalidVector)
				aiCommsSendStatement(player, commPromptID);
				else
				aiCommsSendStatementWithVector(player, commPromptID, vec);
			}
		}
	}
	return(true);
}

//==============================================================================
// Plan Chat functions
//
//==============================================================================

// Set the attack plan to trigger a message and optional flare when the plan reaches the specified state.
// See the event handler below.
bool setPlanChat(int plan=-1, int state=-1, int prompt=-1, int player=-1, vector flare=cInvalidVector)
{
	
	// State -1 could be valid for action on plan termination
	if ( (plan < 0) || (prompt < 0) || (player < 0) )
	return(false);    
	
	aiPlanSetEventHandler(plan, cPlanEventStateChange, "planStateEventHandler");
	
	aiPlanAddUserVariableInt(plan, 0, "Key State", 1);
	aiPlanAddUserVariableInt(plan, 1, "Prompt ID", 1);
	aiPlanAddUserVariableInt(plan, 2, "Send To", 1);
	aiPlanAddUserVariableVector(plan, 3, "Flare Vector", 1);
	
	aiPlanSetUserVariableInt(plan, 0, 0, state);
	aiPlanSetUserVariableInt(plan, 1, 0, prompt);
	aiPlanSetUserVariableInt(plan, 2, 0, player);
	aiPlanSetUserVariableVector(plan, 3, 0, flare);
	
	return(true);
}

void  planStateEventHandler(int planID=-1)
{
	//aiEcho("    Plan "+aiPlanGetName(planID)+" is now in state "+aiPlanGetState(planID));
	
	// Plan planID has changed states.  Get its state, compare to target, issue chat if it matches
	int state = aiPlanGetUserVariableInt(planID, 0, 0);
	int prompt = aiPlanGetUserVariableInt(planID, 1, 0);
	int player = aiPlanGetUserVariableInt(planID, 2, 0);
	vector flare = aiPlanGetUserVariableVector(planID, 3, 0);
	
	if ( aiPlanGetState(planID) == state )
	{
		// We have a winner, send the chat statement
		sendStatement(player, prompt, flare);
		//clearPlanChat(index);
	}
}

void tcPlacedEventHandler(int planID=-1)
{
	// Check the state of the TC build plan.
	// Fire an ally chat if the state is "build"
	if (aiPlanGetState(planID) == cPlanStateBuild)
	{
		vector loc = kbBuildingPlacementGetResultPosition( aiPlanGetVariableInt(planID,cBuildPlanBuildingPlacementID, 0) ); 
		sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildTC, loc);
		//aiEcho("Sending TC placement chat at location "+loc);
	}
}

//==============================================================================
// distance
// updatedOn 2020/10/28 By ageekhere
//==============================================================================
float distance(vector v1=cInvalidVector, vector v2=cInvalidVector)
{ // Will return a float with the 3D distance between two vectors 
	if( debugMessage == true && debugLevel > 1 ) debugRule( "float distance ");
	return(xsVectorLength( v1 - v2 ));
} //end distance

//==============================================================================
// getUnit
// updatedOn 2020/10/16 By ageekhere
//==============================================================================
int getUnit(int unitTypeID=-1, int playerRelationOrID=cMyID, int state=cUnitStateAlive)
{ //returns a random unit matching the parameters
	if( debugMessage == true && debugLevel > 1 ) debugRule( "int getUnit ");
	static int unitQueryID = -1;
	static int numberFound = -1;
	if (unitQueryID == -1) unitQueryID = kbUnitQueryCreate("miscGetUnitQuery");
	kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
	if (playerRelationOrID > 1000)      // Too big for player ID number
	{
		kbUnitQuerySetPlayerID(unitQueryID, -1);  // Clear the player ID, so playerRelation takes precedence.
		kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
	}
	else
	{
		kbUnitQuerySetPlayerRelation(unitQueryID, -1);
		kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
	}
	kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
	kbUnitQuerySetState(unitQueryID, state);
	kbUnitQueryResetResults(unitQueryID);
	numberFound = kbUnitQueryExecute(unitQueryID);
	if (numberFound > 0) return(kbUnitQueryGetResult(unitQueryID, aiRandInt(numberFound))); // Return a random dude(tte)
	return(-1);
} //end getUnit

//==============================================================================
// getUnitByLocation
// updatedOn 2020/10/16 By ageekhere
//==============================================================================
int getUnitByLocation(int unitTypeID=-1, int playerRelationOrID=cMyID, int state=cUnitStateAlive, vector location = cInvalidVector, float radius = 20.0)
{ //Returns a random unit by location matching the parameters
	if( debugMessage == true && debugLevel > 1 ) debugRule( "int getUnitByLocation ");
	static int unitQueryID = -1;
	static int numberFound = -1;
	if (unitQueryID == -1) unitQueryID=kbUnitQueryCreate("miscGetUnitLocationQuery");
	kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
	if (playerRelationOrID > 1000) 
	{ // Too big for player ID number
		kbUnitQuerySetPlayerID(unitQueryID, -1);
		kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
	}
	else
	{
		kbUnitQuerySetPlayerRelation(unitQueryID, -1);
		kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
	}
	kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
	kbUnitQuerySetState(unitQueryID, state);
	kbUnitQuerySetPosition(unitQueryID, location);
	kbUnitQuerySetMaximumDistance(unitQueryID, radius);
	kbUnitQueryResetResults(unitQueryID);
	numberFound = kbUnitQueryExecute(unitQueryID);
	if (numberFound > 0) return(kbUnitQueryGetResult(unitQueryID, aiRandInt(numberFound)));   // Return a random dude(tte)
	return(-1);
} //end getUnitByLocation

//==============================================================================
// getUnitCountByLocation
//
// Returns the number of matching units in the point/radius specified
//==============================================================================
int getUnitCountByLocation(int unitTypeID=-1, int playerRelationOrID=cMyID, int state=cUnitStateAlive, vector location = cInvalidVector, float radius = 20.0)
{
	int count=-1;
	static int unitQueryID = -1;
	
	//If we don't have the query yet, create one.
	if (unitQueryID < 0)
	{
		unitQueryID=kbUnitQueryCreate("miscGetUnitLocationQuery");
		kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
	}
	
	//Define a query to get all matching units
	if (unitQueryID != -1)
	{
		if (playerRelationOrID > 1000)      // Too big for player ID number
		{
			kbUnitQuerySetPlayerID(unitQueryID, -1);
			kbUnitQuerySetPlayerRelation(unitQueryID, playerRelationOrID);
		}
		else
		{
			kbUnitQuerySetPlayerRelation(unitQueryID, -1);
			kbUnitQuerySetPlayerID(unitQueryID, playerRelationOrID);
		}
		kbUnitQuerySetUnitType(unitQueryID, unitTypeID);
		kbUnitQuerySetState(unitQueryID, state);
		kbUnitQuerySetPosition(unitQueryID, location);
		kbUnitQuerySetMaximumDistance(unitQueryID, radius);
	}
	else
   	return(-1);
	
	kbUnitQueryResetResults(unitQueryID);
	return(kbUnitQueryExecute(unitQueryID));
}
//==============================================================================
// createSimpleAttackGoal
//==============================================================================
int createSimpleAttackGoal(string name="BUG", int attackPlayerID=-1, int unitPickerID=-1, int repeat=-1, int minAge=-1, int maxAge=-1,int baseID=-1, bool allowRetreat=false)
{
	if(aiTreatyActive() == true) return(-1);
	//aiEcho("CreateSimpleAttackGoal:  Name="+name+", AttackPlayerID="+attackPlayerID+".");
	//aiEcho("  UnitPickerID="+unitPickerID+", Repeat="+repeat+", baseID="+baseID+".");
	//aiEcho("  MinAge="+minAge+", maxAge="+maxAge+", allowRetreat="+allowRetreat+".");
	//Create the goal.
	int goalID=aiPlanCreate(name, cPlanGoal);
	if (goalID < 0)
	return(-1);
	
	//Priority.
	aiPlanSetDesiredPriority(goalID, 90);
	//Attack player ID.
	if (attackPlayerID >= 0)
	aiPlanSetVariableInt(goalID, cGoalPlanAttackPlayerID, 0, attackPlayerID);
	else
	aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateAttackPlayerID, 0, true);
	//Base.
	if (baseID >= 0)
	aiPlanSetBaseID(goalID, baseID);
	else
	aiPlanSetVariableBool(goalID, cGoalPlanAutoUpdateBase, 0, true);
	//Attack.
	aiPlanSetAttack(goalID, true);
	aiPlanSetVariableInt(goalID, cGoalPlanGoalType, 0, cGoalPlanGoalTypeAttack);
	aiPlanSetVariableInt(goalID, cGoalPlanAttackStartFrequency, 0, 5);
	
	//Military.
	aiPlanSetMilitary(goalID, true);
	aiPlanSetEscrowID(goalID, cMilitaryEscrowID);
	//Ages.
	aiPlanSetVariableInt(goalID, cGoalPlanMinAge, 0, minAge);
	aiPlanSetVariableInt(goalID, cGoalPlanMaxAge, 0, maxAge);
	//Repeat.
	aiPlanSetVariableInt(goalID, cGoalPlanRepeat, 0, repeat);
	//Unit Picker.
	aiPlanSetVariableInt(goalID, cGoalPlanUnitPickerID, 0, unitPickerID);
	//Retreat.
	aiPlanSetVariableBool(goalID, cGoalPlanAllowRetreat, 0, allowRetreat);
	aiPlanSetVariableBool(goalID, cGoalPlanSetAreaGroups, 0, true);
	aiPlanSetVariableInt(goalID, cGoalPlanAttackRoutePatternType, 0, cAttackPlanAttackRoutePatternRandom);
	
	//Done.
	return(goalID);
}

//==============================================================================
// getPlayerArmyHPs
//
// Queries all land military units.  
// Totals hitpoints (ideal if considerHealth false, otherwise actual.)
// Returns total
//==============================================================================
float getPlayerArmyHPs(int playerID = -1, bool considerHealth = false)
{
	int queryID = -1;    // Will recreate each time, as changing player trashes existing query settings.
	
	if (playerID <= 0) 
	return(-1.0);
	
	queryID = kbUnitQueryCreate("getStrongestEnemyArmyHPs");
	kbUnitQuerySetIgnoreKnockedOutUnits(queryID, true);
	kbUnitQuerySetPlayerID(queryID, playerID, true);
	kbUnitQuerySetUnitType(queryID, cUnitTypeLogicalTypeLandMilitary);
	kbUnitQuerySetState(queryID, cUnitStateAlive);
	kbUnitQueryResetResults(queryID);
	kbUnitQueryExecute(queryID);
	
	return(kbUnitQueryGetUnitHitpoints(queryID, considerHealth));
}

//==============================================================================
/* sigmoid(float base, float adjustment, float floor, float ceiling)
	
	Used to adjust a number up or down in a sigmoid fashion, so that it
	grows very slowly at values near the bottom of the range, quickly near
	the center, and slowly near the upper limit.  
	
	Used with the many 0..1 range variables, this lets us adjust them up
	or down by arbitrary "percentages" while retaining the 0..1 boundaries.  
	That is, a 50% "boost" (1.5 adjustment) to a .9 score gives .933, while a
	
	
	Base is the number to be adjusted.
	Adjustment of 1.0 means 100%, i.e. stay where you are.
	Adjustment of 2.0 means to move it up by the LESSER movement of:
	Doubling the (base-floor) amount, or
	Cutting the (ceiling-base) in half (mul by 1/2.0).
	
	With a default floor of 0 and ceiling of 1, it gives these results:
	sigmoid(.1, 2.0) = .2
	sigmoid(.333, 2.0) = .667, upper and lower adjustments equal
	sigmoid(.8, 2.0) = .9, adjusted up 50% (1/2.0) of the headroom.
	sigmoid(.1, 5.0) = .50 (5x base, rather than moving up to .82)
	sigmoid(.333, 5.0) = .866, (leaving 1/5 of the .667 headroom)
	sigmoid(.8, 5.0) = .96 (leaving 1/5 of the .20 headroom)
	
	Adjustments of less than 1.0 (neutral) do the opposite...they move the 
	value DOWN by the lesser movement of:
	Increasing headroom by a factor of 1/adjustment, or
	Decreasing footroom by multiplying by adjustment.
	sigmoid(.1, .5) = .05   (footroom*adjustment)
	sigmoid(.667, .5) = .333  (footroom*adjustment) = (headroom doubled)
	sigmoid(.8, .2) = .16 (footroom*0.2)
	
	Not intended for base < 0.  Ceiling must be > floor.  Must have floor <= base <= ceiling.
*/
//==============================================================================
float sigmoid(float base=-1.0 /*required*/, float adjust=1.0, float floor=0.0, float ceiling=1.0)
{
	float retVal = -1.0;
	if (base < 0.0)
	return(retVal);
	if (ceiling <= floor)
	return(retVal);
	if (base < floor)
	return(retVal);
	if (base > ceiling)
	return(retVal);
	
	float footroom = base - floor;
	float headroom = ceiling - base;
	
	float footBasedNewValue = 0.0;   // This will be the value created by adjusting the footroom, i.e.
	// increasing a small value.
	float headBasedNewValue = 0.0;   // This will be the value created by adjusting the headroom, i.e.
	// increasing a value that's closer to ceiling than floor.
	
	if (adjust > 1.0) 
	{  // Increasing
		footBasedNewValue = floor + (footroom * adjust);
		headBasedNewValue = ceiling - (headroom / adjust);
		
		// Pick the value that resulted in the smaller net movement
		if ( (footBasedNewValue - base) < (headBasedNewValue - base) )
		retVal = footBasedNewValue;   // The foot adjustment gave the smaller move.
		else
		retVal = headBasedNewValue;   // The head adjustment gave the smaller move
	}
	else
	{  // Decreasing
		footBasedNewValue = floor + (footroom * adjust);
		headBasedNewValue = ceiling - (headroom / adjust);
		
		// Pick the value that resulted in the smaller net movement
		if ( (base - footBasedNewValue) < (base - headBasedNewValue) )
		retVal = footBasedNewValue;   // The foot adjustment gave the smaller move.
		else
		retVal = headBasedNewValue;   // The head adjustment gave the smaller move
	}
	
	//aiEcho("sigmoid("+base+", "+adjust+", "+floor+", "+ceiling+") is "+retVal);
	return(retVal);
	
}

//==============================================================================
// createSimpleResearchPlan
// updatedOn 2020/11/13 By ageekhere
//==============================================================================
int createSimpleResearchPlan(int techID=-1, int buildingID=-1, int escrowID=cRootEscrowID, int pri = 50)
{ //creates a research plan
	if( debugMessage == true && debugLevel > 1 ) debugRule( "int createSimpleResearchPlan ");
	//if (outOfOpening == true) return(-1);
	if( aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, techID) != -1 ) return (-1); //check if tech is already being researched
	if( kbTechGetStatus(techID) == cTechStatusActive || kbTechGetStatus(techID) != cTechStatusObtainable ) return(-1); // Check if tech is obtainable
	int planID = aiPlanCreate("Research "+kbGetTechName(techID), cPlanResearch);
	aiPlanSetVariableInt(planID, cResearchPlanTechID, 0, techID);
	aiPlanSetVariableInt(planID, cResearchPlanBuildingID, 0, buildingID);
	aiPlanSetDesiredPriority(planID, pri);
	aiPlanSetEscrowID(planID, escrowID);
	aiPlanSetActive(planID);	
	return(planID);
} //end createSimpleResearchPlan

//==============================================================================
//chooseConsulateFlag
//==============================================================================
void chooseConsulateFlag()
{
	int consulatePlanID = -1;
	int randomizer = aiRandInt(100); // 0-99
	int flag_button_id = -1;
	
	// Chinese options: British, Russians, French (HC level >= 25) & Germans (HC level >= 40)
	// Choice biased towards Russians
	if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
	{
		if (kbGetHCLevel(cMyID) < 25)
		{
			if (randomizer < 70) // 70 % probability
			{
				flag_button_id = cTechypBigConsulateRussians;
				cvOkToBuildForts = true;
			}
			else // 30 % probability
			{
				flag_button_id = cTechypBigConsulateBritish;
			}
		}
		else if (kbGetHCLevel(cMyID) < 40)
		{
			if (randomizer < 60) // 60 % probability
			{
				flag_button_id = cTechypBigConsulateRussians;
				cvOkToBuildForts = true;
			}
			else if (randomizer < 80) // 20 % probability
			{
				flag_button_id = cTechypBigConsulateBritish;
			}
			else // 20 % probability
			{
				flag_button_id = cTechypBigConsulateFrench;
			}
		}
		else // HC level >= 40
		{
			if (randomizer < 52) // 52 % probability
			{
				flag_button_id = cTechypBigConsulateRussians;
				cvOkToBuildForts = true;
			}
			else if (randomizer < 68) // 16 % probability
			{
				flag_button_id = cTechypBigConsulateBritish;
			}
			else if (randomizer < 84) // 16 % probability
			{
				flag_button_id = cTechypBigConsulateFrench;
			}
			else // 16 % probability
			{
				flag_button_id = cTechypBigConsulateGermans;
			}
		}
	}
	
	// Indian options: British, Portuguese, French (HC level >= 25) & Ottomans (HC level >= 40)
	// Choice biased towards Portuguese, especially on water maps
	if ((kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians))
	{
		if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
		{
			if (kbGetHCLevel(cMyID) < 25)
			{
				if (randomizer < 80) // 80 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else // 20 % probability
				{
					flag_button_id = cTechypBigConsulateBritish;
				}
			}
			else if (kbGetHCLevel(cMyID) < 40)
			{
				if (randomizer < 60) // 60 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else if (randomizer < 80) // 20 % probability
				{
					flag_button_id = cTechypBigConsulateBritish;
				}
				else // 20 % probability
				{
					flag_button_id = cTechypBigConsulateFrench;
				}
			}
			else // HC level >= 40
			{
				if (randomizer < 52) // 52 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else if (randomizer < 68) // 16 % probability
				{
					flag_button_id = cTechypBigConsulateBritish;
				}
				else if (randomizer < 84) // 16 % probability
				{
					flag_button_id = cTechypBigConsulateFrench;
				}
				else // 16 % probability
				{
					flag_button_id = cTechypBigConsulateOttomans;
				}
			}
		}
		else // land map
		{
			if (kbGetHCLevel(cMyID) < 25)
			{
				if (randomizer < 60) // 60 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else // 40 % probability
				{
					flag_button_id = cTechypBigConsulateBritish;
				}
			}
			else if (kbGetHCLevel(cMyID) < 40)
			{
				if (randomizer < 40) // 40 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else if (randomizer < 70) // 30 % probability
				{
					flag_button_id = cTechypBigConsulateBritish;
				}
				else // 30 % probability
				{
					flag_button_id = cTechypBigConsulateFrench;
				}
			}
			else // HC level >= 40
			{
				if (randomizer < 40) // 40 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else if (randomizer < 60) // 20 % probability
				{
					flag_button_id = cTechypBigConsulateBritish;
				}
				else if (randomizer < 80) // 20 % probability
				{
					flag_button_id = cTechypBigConsulateFrench;
				}
				else // 20 % probability
				{
					flag_button_id = cTechypBigConsulateOttomans;
					xsEnableRule("consulateLevy");
				}
			}
		}
	}
	
	// Japanese options: Isolation, Portuguese, Dutch (HC level >= 25) & Spanish (HC level >= 40)
	// Choice biased towards Portuguese on water maps, towards Dutch on land maps
	if ((kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapanese))
	{
		if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
		{
			if (kbGetHCLevel(cMyID) < 25)
			{
				if (randomizer < 80) // 80 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else // 20 % probability
				{
					flag_button_id = cTechypBigConsulateJapanese;
				}
			}
			else if (kbGetHCLevel(cMyID) < 40)
			{
				if (randomizer < 60) // 60 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else if (randomizer < 80) // 20 % probability
				{
					flag_button_id = cTechypBigConsulateJapanese;
				}
				else // 20 % probability
				{
					flag_button_id = cTechypBigConsulateDutch;
				}
			}
			else // HC level >= 40
			{
				if (randomizer < 50) // 50 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else if (randomizer < 65) // 15 % probability
				{
					flag_button_id = cTechypBigConsulateJapanese;
				}
				else if (randomizer < 85) // 20 % probability
				{
					flag_button_id = cTechypBigConsulateDutch;
				}
				else // 15 % probability
				{
					flag_button_id = cTechypBigConsulateSpanish;
				}
			}
		}
		else // land map
		{
			if (kbGetHCLevel(cMyID) < 25)
			{
				if (randomizer < 30) // 30 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else // 70 % probability
				{
					flag_button_id = cTechypBigConsulateJapanese;
				}
			}
			else if (kbGetHCLevel(cMyID) < 40)
			{
				if (randomizer < 20) // 20 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else if (randomizer < 40) // 20 % probability
				{
					flag_button_id = cTechypBigConsulateJapanese;
				}
				else // 60 % probability
				{
					flag_button_id = cTechypBigConsulateDutch;
				}
			}
			else // HC level >= 40
			{
				if (randomizer < 10) // 10 % probability
				{
					flag_button_id = cTechypBigConsulatePortuguese;
				}
				else if (randomizer < 30) // 20 % probability
				{
					flag_button_id = cTechypBigConsulateJapanese;
				}
				else if (randomizer < 80) // 50 % probability
				{
					flag_button_id = cTechypBigConsulateDutch;
				}
				else // 20 % probability
				{
					flag_button_id = cTechypBigConsulateSpanish;
				}
			}
		}
	}
	
	if (kbTechGetStatus(flag_button_id) == cTechStatusObtainable)
	{
		consulatePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, flag_button_id);
		if (consulatePlanID < 0) 
		{
			//aiEcho("************Consulate Flag************");
			//aiEcho("Our Consulate flag is: "+kbGetTechName(flag_button_id));
			//aiEcho("Randomizer value: "+randomizer);
			createSimpleResearchPlan(flag_button_id, getUnit(cUnitTypeypConsulate),cEconomyEscrowID, 40);
			gFlagChosen = true;
		}
	}
}

void setConsulateArmyPreference() {
	if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) < 1) {
		return;
	}
	if (kbTechGetStatus(cTechypBigConsulatePortuguese) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese3, 0.6);
	}
	
	if (kbTechGetStatus(cTechypBigConsulateDutch) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch3, 0.6);
	}
	
	if (kbTechGetStatus(cTechypBigConsulateRussians) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian3, 0.6);
	}
	
	if (kbTechGetStatus(cTechypBigConsulateSpanish) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish3, 0.6);
	}
	
	if (kbTechGetStatus(cTechypBigConsulateBritish) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish3, 0.6);      
	}
	
	if (kbTechGetStatus(cTechypBigConsulateFrench) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench3, 0.6); 
	}
	
	if (kbTechGetStatus(cTechypBigConsulateGermans) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman3, 0.6); 
	}
	
	if (kbTechGetStatus(cTechypBigConsulateOttomans) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman3, 0.6);
	}
	
	if (kbTechGetStatus(cTechypBigConsulateJapanese) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUSColonialMarines, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUSSaberSquad, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUSGatlingGuns, 0.6);
	}
	
	if (kbTechGetStatus(cTechypBigConsulateSPCChina) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyItalians1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyItalians2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyItalians3, 0.6);
	}
	
	if (kbTechGetStatus(cTechypBigConsulateSPCIndia) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSwedishArmy1, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSwedishArmy2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSwedishArmy3, 0.6);
	}
	
}

void setCapitolArmyPreference() {
	if (kbUnitCount(cMyID, cUnitTypeCapitol, cUnitStateAlive) < 1) {
		return;
	}
	if (kbTechGetStatus(cTechAge0Portuguese) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyPortuguese33, 0.6);
	}
	
	if (kbTechGetStatus(cTechAge0Dutch) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyDutch33, 0.6);
	}
	
	if (kbTechGetStatus(cTechAge0Russian) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyRussian33, 0.6);
	}
	
	if (kbTechGetStatus(cTechAge0Spanish) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmySpanish33, 0.6);
	}
	
	if (kbTechGetStatus(cTechAge0British) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyBritish33, 0.6);      
	}
	
	if (kbTechGetStatus(cTechAge0French) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyFrench33, 0.6); 
	}
	
	if (kbTechGetStatus(cTechAge0German) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyGerman33, 0.6); 
	}
	
	if (kbTechGetStatus(cTechAge0Ottoman) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyOttoman33, 0.6);
	}
	
	if (kbTechGetStatus(cTechAge0USA) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUSColonialMarines2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUSSaberSquad2, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeUSGatlingGuns2, 0.6);
	}
	
	if (kbTechGetStatus(cTechAge0Italians) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyItalians11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyItalians22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypConsulateArmyItalians33, 0.6);
	}
	
	if (kbTechGetStatus(cTechAge0Swedish) == cTechStatusActive) {
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSwedishArmy11, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSwedishArmy22, 0.6);
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeSwedishArmy33, 0.6);
	}
	
}

//==============================================================================
// capitolArmy
// updatedOn 2020/11/15 By ageekhere
//==============================================================================
void capitolArmy(int techAgeCiv = -1, int tech1 = -1, int tech2 = -1, int tech3 = -1)
{ //trains capitol Army
	if( debugMessage == true && debugLevel > 1 ) debugRule( "void capitolArmy ");
	int capID = getUnit(cUnitTypeCapitol, cMyID, cUnitStateAlive); //get the Capitol id
	if (kbTechGetStatus(techAgeCiv) == cTechStatusActive) 
	{
		if(kbResourceGet(cResourceFame) > kbUnitCostPerResource(tech1,cResourceFame) && kbBaseGetUnderAttack(cMyID, 0) == false )
		{
			aiTaskUnitTrain( capID, tech1 );
		}
		if(kbResourceGet(cResourceFame) > kbUnitCostPerResource(tech2,cResourceFame) && kbBaseGetUnderAttack(cMyID, 0) == false )
		{
			aiTaskUnitTrain( capID, tech2 );
		}
		if(kbResourceGet(cResourceFame) > kbUnitCostPerResource(tech3,cResourceFame))
		{
			aiTaskUnitTrain( capID, tech3 );
		}
	}
} //end capitolArmy

//==============================================================================
// capitolArmyManager
// updatedOn 2020/11/15 By ageekhere
//==============================================================================
void capitolArmyManager()
{ //managers capitol armies
	if (kbUnitCount(cMyID, cUnitTypeCapitol, cUnitStateAlive) < 1)  return; //no Capitol
	if( debugMessage == true && debugLevel > 1 ) debugRule( "void capitolArmyManager ");
	//checks the civ and sends the unit types to capitolArmy()
	if (kbTechGetStatus(cTechAge0Portuguese) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0Portuguese,cUnitTypeypConsulateArmyPortuguese11,cUnitTypeypConsulateArmyPortuguese22,cUnitTypeypConsulateArmyPortuguese33);
	}
	else if (kbTechGetStatus(cTechAge0Dutch) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0Dutch,cUnitTypeypConsulateArmyDutch11,cUnitTypeypConsulateArmyDutch22,cUnitTypeypConsulateArmyDutch22);
	}
	else if (kbTechGetStatus(cTechAge0Russian) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0Russian,cUnitTypeypConsulateArmyRussian11,cUnitTypeypConsulateArmyRussian22,cUnitTypeypConsulateArmyRussian33);
	}
	else if (kbTechGetStatus(cTechAge0Spanish) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0Spanish,cUnitTypeypConsulateArmySpanish11,cUnitTypeypConsulateArmySpanish22,cUnitTypeypConsulateArmySpanish33);
	}
	else if (kbTechGetStatus(cTechAge0British) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0British,cUnitTypeypConsulateArmyBritish11,cUnitTypeypConsulateArmyBritish22,cUnitTypeypConsulateArmyBritish33);
	}
	else if (kbTechGetStatus(cTechAge0French) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0French,cUnitTypeypConsulateArmyFrench11,cUnitTypeypConsulateArmyFrench22,cUnitTypeypConsulateArmyFrench33);
	}
	else if (kbTechGetStatus(cTechAge0German) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0German,cUnitTypeypConsulateArmyGerman11,cUnitTypeypConsulateArmyGerman22,cUnitTypeypConsulateArmyGerman33);
	}
	else if (kbTechGetStatus(cTechAge0Ottoman) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0Ottoman,cUnitTypeypConsulateArmyOttoman11,cUnitTypeypConsulateArmyOttoman22,cUnitTypeypConsulateArmyOttoman33);
	}
	else if (kbTechGetStatus(cTechAge0USA) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0USA,cUnitTypeUSColonialMarines2,cUnitTypeUSSaberSquad2,cUnitTypeUSGatlingGuns2);
	}
	else if (kbTechGetStatus(cTechAge0Italians) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0Italians,cUnitTypeypConsulateArmyItalians11,cUnitTypeypConsulateArmyItalians22,cUnitTypeypConsulateArmyItalians33);
	}
	else if (kbTechGetStatus(cTechAge0Swedish) == cTechStatusActive) 
	{
		capitolArmy(cTechAge0Swedish,cUnitTypeSwedishArmy11,cUnitTypeSwedishArmy22,cUnitTypeSwedishArmy33);
	}
} //end capitolArmyManager


//==============================================================================
// checkExcludeSettler
// updatedOn 2020/11/15 By ageekhere
//==============================================================================
bool checkExcludeSettler(int settlerId = -1)
{ //checks if the settler have been exclueded
	if( debugMessage == true && debugLevel > 1 ) debugRule( "bool checkExcludeSettler ");
	for(j = 0; < maxVillPop)
	{
		if(xsArrayGetInt(huntSettlersArray,j) == -1) break;
		if(settlerId == xsArrayGetInt(huntSettlersArray,j))return(true);
	}
	for(j = 0; < maxVillPop)
	{
		if(xsArrayGetInt(excludeSettlersArray,j) == -1) break;
		if(settlerId == xsArrayGetInt(excludeSettlersArray,j)) return(true);
	}	
	return(false);
} //end checkExcludeSettler											

//==============================================================================
// createSimpleMaintainPlan
// updatedOn 2020/11/15 By ageekhere
//==============================================================================
int createSimpleMaintainPlan(int puid=-1, int number=1, bool economy=true, int baseID=-1, int batchSize=1)
{ //Create a the plan name.
	if( debugMessage == true && debugLevel > 1 ) debugRule( "int createSimpleMaintainPlan");
	//if (outOfOpening == true) return(-1);
	string planName="Military";
	if (economy == true) planName="Economy";
	
	planName = planName + kbGetProtoUnitName(puid)+"Maintain";
	int planID = aiPlanCreate(planName, cPlanTrain);

	if (economy == true) aiPlanSetEconomy(planID, true); //Economy or Military.
	else aiPlanSetMilitary(planID, true);
	
	aiPlanSetVariableInt(planID, cTrainPlanUnitType, 0, puid); //Unit type.
	aiPlanSetVariableInt(planID, cTrainPlanNumberToMaintain, 0, number); //Number.
	aiPlanSetVariableInt(planID, cTrainPlanBatchSize, 0, batchSize); // Batch size
	if (baseID >= 0)
	{ //If we have a base ID, use it.
		aiPlanSetBaseID(planID, baseID);
		if  (economy == false) aiPlanSetVariableVector(planID, cTrainPlanGatherPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, baseID));
	}
	//   aiPlanSetVariableBool(planID, cTrainPlanUseHomeCityShipments, 0, true);
	aiPlanSetActive(planID);
	return(planID);
} 
//==============================================================================
// addItemToForecasts
// updatedOn 2020/11/15 By ageekhere
//==============================================================================
void addItemToForecasts(int protoUnit = -1, int qty = -1)
{ // Add qty of item protoUnit to the global forecast arrays
	if( debugMessage == true && debugLevel > 1 ) debugRule( "void addItemToForecasts");
	if (protoUnit < 0) return;
	if (qty < 1) return;
	for (i=0; < 3)  // Step through first three resources
	{
		xsArraySetFloat(gForecasts, i, xsArrayGetFloat(gForecasts, i) + (kbUnitCostPerResource(protoUnit, i) * qty));
	}
} //end addItemToForecasts

//==============================================================================
// createSimpleBuildPlan
// updatedOn 2020/11/27 By ageekhere
//==============================================================================
int createSimpleBuildPlan(int puid=-1, int number=1, int pri=100, bool economy=true, int escrowID=-1, int baseID=-1, int numberBuilders=1)
{ //will create a build plan in the given base, Note: Can have an issue with running out of space to place a building 
	if( debugMessage == true && debugLevel > 1 ) debugRule( "int createSimpleBuildPlan " );
	if( cvOkToBuild == false) return(-1);
	//if (outOfOpening == false) return(-1);

	if( aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, puid) != -1 ) return (-1); //Check if the ai already has a building of the type passed in que
	if( kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 1 && puid != gTownCenter )  return (-1); //do not build anything but a town center if the ai has none
	
	//if(puid == cUnitTypeBarracks && kbGetAge() < cAge3)return(-1);
	
	bool buildPass = true;
	if(kbGetAge() < cAge5)
	{
		if (puid == cUnitTypeBarracks ||
			puid == cUnitTypeStable ||
			puid == cUnitTypeArtilleryDepot ||
			puid == cUnitTypeBlockhouse ||
			puid == cUnitTypeWarHut ||
			puid == cUnitTypeNoblesHut ||
			puid == cUnitTypeypBarracksJapanese ||
			puid == cUnitTypeypWarAcademy ||
			puid == cUnitTypeYPBarracksIndian ||
			puid == cUnitTypeypStableJapanese ||
			puid == cUnitTypeypCaravanserai ||
			puid == cUnitTypeypCastle ||
			puid == gDockUnit ||
		puid == cUnitTypeCorral)
		{
			buildPass = true;
			if(kbGetAge() < cAge4 && (kbUnitCount(cMyID, puid, cUnitStateABQ) > 0 || kbUnitCount(cMyID, puid, cUnitStateAlive) > 0)) buildPass = false;
			if(kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 2)buildPass = true;
		}
	}
	
	if (buildPass == false) //&& kbResourceGet(cResourceWood) < 1500) 
	{
		return (-1);
	}
	
	//---------------------------

	static int builderType = -1;
	builderType = gEconUnit;
	//Create the right number of plans.
	for (i = 0; < number)
	{
		int planID=aiPlanCreate("Simple Build Plan, "+number+" "+kbGetUnitTypeName(puid), cPlanBuild);
		if (planID < 0)
		return(-1);
		
		// What to build
		aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, puid);
		
		// 3 meter separation
		aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 5.0);
		if (puid == gFarmUnit) aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 8.0);  	
		//if (puid == gHouseUnit) aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 3.0);  	
		
		//Priority.
		aiPlanSetDesiredPriority(planID, pri);
		//Mil vs. Econ.
		if (economy == true)
		aiPlanSetMilitary(planID, false);
		else
		aiPlanSetMilitary(planID, true);
		aiPlanSetEconomy(planID, economy);
		//Escrow.
		aiPlanSetEscrowID(planID, escrowID);
		//Builders.
		if (civIsAsian() == true) {
			if (puid  == gFarmUnit) {
				if (kbUnitCount(cMyID, cUnitTypeYPRicePaddyWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPRicePaddyWagon;
			}
			if (puid  == gMarketUnit) {
				if (kbUnitCount(cMyID, cUnitTypeypMarketWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeypMarketWagon;
			}
			if (puid  == cUnitTypeypShrineJapanese) {
				if (kbUnitCount(cMyID, cUnitTypeypShrineWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeypShrineWagon;
			}
			if (puid  == cUnitTypeypMonastery) {
				if (kbUnitCount(cMyID, cUnitTypeYPMonasteryWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPMonasteryWagon;
			}
			if (puid  == cUnitTypeypBerryBuilding) {
				builderType = cUnitTypeYPBerryWagon1;
			}
			if (puid  == cUnitTypeTradingPost) {
				if (kbUnitCount(cMyID, cUnitTypeypTradingPostWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeypTradingPostWagon;
			}
			if (puid  == cUnitTypeypBarracksJapanese) {
				if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPMilitaryRickshaw;
			}
			if (puid  == cUnitTypeypStableJapanese) {
				if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPMilitaryRickshaw;
			}
			if (puid  == cUnitTypeypDojo) {
				if (kbUnitCount(cMyID, cUnitTypeYPDojoWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPDojoWagon;
			}
			if (puid  == cUnitTypeypTradeMarketAsian) {
				if (kbUnitCount(cMyID, cUnitTypeypMarketWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeypMarketWagon;
			}
			if (puid  == cUnitTypeypSacredField) {
				if (kbUnitCount(cMyID, cUnitTypeYPSacredFieldWagon, cUnitStateAlive) > 0)
                builderType = cUnitTypeYPSacredFieldWagon;
			}
		}
		if (puid  == gDockUnit) {
			if (kbUnitCount(cMyID, cUnitTypeYPDockWagon, cUnitStateAlive) > 0)
			builderType = cUnitTypeYPDockWagon;
		}
		// Dutch can use bank wagon
		/*
			if ((kbGetCiv() == cCivDutch) && (puid == cUnitTypeBank))
			{
			if (kbUnitCount(cMyID, cUnitTypeBankWagon, cUnitStateAlive) > 0)
			builderType = cUnitTypeBankWagon;
			}
		*/
		// Explorers, war chiefs and monks build town centers
		if (puid == gTownCenter)
		{
			//updatedOn 2020/03/09 By ageekhere  
			//---------------------------
			int wantVill = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
			if(kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 1 && kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateABQ) == 0)
			{
				wantVill = getUnit(gEconUnit, cMyID, cUnitStateAlive);
			}
			if(wantVill < 2)
			{
				switch(kbGetCiv())
				{
					case cCivXPAztec:
					{ 
						aiPlanAddUnitType(planID, cUnitTypexpAztecWarchief, wantVill, wantVill, wantVill);
						break;
					}
					case cCivXPIroquois:
					{
						aiPlanAddUnitType(planID, cUnitTypexpIroquoisWarChief, wantVill, wantVill, wantVill);
						break;
					}
					case cCivXPSioux:
					{
						aiPlanAddUnitType(planID, cUnitTypexpLakotaWarchief, wantVill, wantVill, wantVill);
						break;
					}
					case cCivChinese:
					{
						aiPlanAddUnitType(planID, cUnitTypeypMonkChinese, wantVill, wantVill, wantVill);
						break;
					}
					case cCivIndians:
					{
						aiPlanAddUnitType(planID, cUnitTypeypMonkIndian, wantVill, wantVill, wantVill);
						aiPlanAddUnitType(planID, cUnitTypeypMonkIndian2, wantVill, wantVill, wantVill);
						break;
					}
					case cCivJapanese:
					{
						aiPlanAddUnitType(planID, cUnitTypeypMonkJapanese, wantVill, wantVill, wantVill);
						aiPlanAddUnitType(planID, cUnitTypeypMonkJapanese2, wantVill, wantVill, wantVill);
						break;
					}
					default:
					{
						aiPlanAddUnitType(planID, cUnitTypeExplorer, wantVill, wantVill, wantVill);
						break;
					}
					
				}
			}
			else
			{
				aiPlanAddUnitType(planID, builderType, numberBuilders, numberBuilders, numberBuilders);
			}
			//---------------------------
		}
		if(puid == cUnitTypeFactory)
		{
			aiPlanAddUnitType(planID, cUnitTypeFactoryWagon, 1, 1, 1);
		}
		
		else
		{
			// Germans use settler wagons if there are no settlers or builder wagons available
			int settlerCount = -1;
			if ((kbGetCiv() == cCivGermans) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) < 1) && (builderType == gEconUnit))
			{
				aiPlanAddUnitType(planID, cUnitTypeSettlerWagon, numberBuilders, numberBuilders, numberBuilders);
				static int nearestWagonSettler = -1; 
				if (nearestWagonSettler == -1) nearestWagonSettler = kbUnitQueryCreate("nearestWagonSettler");	
				kbUnitQuerySetPlayerID(nearestWagonSettler, cMyID);
				kbUnitQuerySetUnitType(nearestWagonSettler, cUnitTypeSettlerWagon);
				kbUnitQuerySetState(nearestWagonSettler, cUnitStateAlive);
				kbUnitQuerySetPosition(nearestWagonSettler, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) );
				kbUnitQuerySetAscendingSort(nearestWagonSettler,true);
				kbUnitQueryResetResults(nearestWagonSettler);
				settlerCount = kbUnitQueryExecute(nearestWagonSettler);		
				aiPlanAddUnit(planID, kbUnitQueryGetResult(nearestWagonSettler, 0) );
				
				
			}
			else
			{
				aiPlanAddUnitType(planID, builderType, numberBuilders, numberBuilders, numberBuilders);
				
				static int nearestSettler = -1; 
				if (nearestSettler == -1) nearestSettler = kbUnitQueryCreate("nearestSettler");	
				kbUnitQuerySetPlayerID(nearestSettler, cMyID);
				kbUnitQuerySetUnitType(nearestSettler, cUnitTypeSettlerWagon);
				kbUnitQuerySetState(nearestSettler, cUnitStateAlive);
				kbUnitQuerySetPosition(nearestSettler,  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
				kbUnitQuerySetAscendingSort(nearestSettler,true);
				kbUnitQueryResetResults(nearestSettler);
				settlerCount = kbUnitQueryExecute(nearestSettler);		
				aiPlanAddUnit(planID, kbUnitQueryGetResult(nearestSettler, 0) );
				
				
			}
		}
		addItemToForecasts(puid,number);
		//Base ID.
		aiPlanSetBaseID(planID, baseID);
		
		
		aiPlanSetNumberVariableValues(planID, cBuildPlanInfluenceUnitTypeID, 2, true);
		aiPlanSetNumberVariableValues(planID, cBuildPlanInfluenceUnitDistance, 2, true);
		aiPlanSetNumberVariableValues(planID, cBuildPlanInfluenceUnitValue, 2, true);
		aiPlanSetNumberVariableValues(planID, cBuildPlanInfluenceUnitFalloff, 2, true);
		
		aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeHomeCityWaterSpawnFlag);
		aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 50);  
		aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -500);        
		aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinearInverse); 
		
		if(kbGetCiv() != cCivXPSioux )
		{
			aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 1, gTownCenter);
			aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 1, 30);   
			aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 1, -500);
			aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinearInverse);
		}
		//Go.
		aiPlanSetActive(planID);
	}
	return(planID);   // Only really useful if number == 1, otherwise returns last value.
}

//==============================================================================
//createLocationBuildPlan
//==============================================================================
int createLocationBuildPlan(int puid=-1, int number=1, int pri=100, bool economy=true, int escrowID=-1, vector position=cInvalidVector, int numberBuilders=1)
{
	
	bool usingWagon = false;
	if (cvOkToBuild == false) return(-1);
	//if (outOfOpening == false) return(-1);
	
  	
	if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, puid) != -1 ) return (-1);
	
	//Create the right number of plans.
	if(puid == cUnitTypeFactory && gBackBaseLocation != cInvalidVector)
	{
		position = gBackBaseLocation;
	}
	for (i=0; < number)
	{
		int planID=aiPlanCreate("Location Build Plan, "+number+" "+kbGetUnitTypeName(puid), cPlanBuild);
		if (planID < 0)
		return(-1);
		// What to build
		aiPlanSetVariableInt(planID, cBuildPlanBuildingTypeID, 0, puid);
		
		aiPlanSetVariableVector(planID, cBuildPlanCenterPosition, 0, position);
		aiPlanSetVariableFloat(planID, cBuildPlanCenterPositionDistance, 0, 300.0);
		
		// 3 meter separation
		aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 3.0);
		if (puid == gFarmUnit)
		aiPlanSetVariableFloat(planID, cBuildPlanBuildingBufferSpace, 0, 8.0);  
		
		//Priority.
		aiPlanSetDesiredPriority(planID, pri);
		//Mil vs. Econ.
		if (economy == true)
		aiPlanSetMilitary(planID, false);
		else
		aiPlanSetMilitary(planID, true);
		aiPlanSetEconomy(planID, economy);
		//Escrow.
		aiPlanSetEscrowID(planID, escrowID);
		//Builders.
		
		
		if(puid == cUnitTypeMineGoldUS)
		{
			aiPlanAddUnitType(planID, cUnitTypeGoldMiner, 1, 5, 5);
		}
		
		else if(puid == cUnitTypeFactory)
		{
			aiPlanAddUnitType(planID, cUnitTypeFactoryWagon,1, 1, 1);
			usingWagon = true;
		}
		
		else if(puid == cUnitTypeFortFrontier)
		{
			aiPlanAddUnitType(planID, cUnitTypeFortWagon,1, 1, 1);
			usingWagon = true;
		}
		
		else if(puid == gTowerUnit && kbUnitCount(cMyID,cUnitTypeOutpostWagon ,cUnitStateAlive) > 0)
		{
			aiPlanAddUnitType(planID, cUnitTypeOutpostWagon,1, 1, 1);
			usingWagon = true;
		}
		
		else if (puid == cUnitTypeBank && kbUnitCount(cMyID,cUnitTypeBankWagon ,cUnitStateAlive) > 0)
		{
			aiPlanAddUnitType(planID, cUnitTypeBankWagon,1, 1, 1);
			usingWagon = true;
		}
		
		else if (puid == cUnitTypeBank && kbUnitCount(cMyID,cUnitTypeypBankWagon ,cUnitStateAlive) > 0)
		{
			aiPlanAddUnitType(planID, cUnitTypeypBankWagon,1, 1, 1);
			usingWagon = true;
		}
		else
		{	
			int settlerCount = -1;
			if ((kbGetCiv() == cCivGermans) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) < 1) )
			{
				aiPlanAddUnitType(planID, cUnitTypeSettlerWagon, numberBuilders, numberBuilders, numberBuilders);
				static int nearestWagonSettler = -1; 
				if (nearestWagonSettler == -1) nearestWagonSettler = kbUnitQueryCreate("nearestWagonSettler");	
				kbUnitQuerySetPlayerID(nearestWagonSettler, cMyID);
				kbUnitQuerySetUnitType(nearestWagonSettler, cUnitTypeSettlerWagon);
				kbUnitQuerySetState(nearestWagonSettler, cUnitStateAlive);
				kbUnitQuerySetPosition(nearestWagonSettler, position );
				kbUnitQuerySetAscendingSort(nearestWagonSettler,true);
				kbUnitQueryResetResults(nearestWagonSettler);
				settlerCount = kbUnitQueryExecute(nearestWagonSettler);		
				aiPlanAddUnit(planID, kbUnitQueryGetResult(nearestWagonSettler, 0) );	
			}
			else
			{	
				aiPlanAddUnitType(planID, gEconUnit, numberBuilders, numberBuilders, numberBuilders);
				
				static int nearestSettler = -1; 
				if (nearestSettler == -1) nearestSettler = kbUnitQueryCreate("nearestSettler");	
				kbUnitQuerySetPlayerID(nearestSettler, cMyID);
				kbUnitQuerySetUnitType(nearestSettler, gEconUnit);
				kbUnitQuerySetState(nearestSettler, cUnitStateAlive);
				kbUnitQuerySetPosition(nearestSettler,  position);//kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); 
				kbUnitQuerySetAscendingSort(nearestSettler,true);
				kbUnitQueryResetResults(nearestSettler);
				settlerCount = kbUnitQueryExecute(nearestSettler);	
				aiPlanAddUnit(planID, kbUnitQueryGetResult(nearestSettler, 0) );
				int k = 0;
				while(true)
				{
					if(checkExcludeSettler(kbUnitQueryGetResult(nearestSettler, k)) == false)
					{
						aiPlanAddUnit(planID, kbUnitQueryGetResult(nearestSettler, k) );
						break;
					}
					else
					{
						k++;
					}
				}
			}
		}	
  		
		aiPlanSetVariableVector(planID, cBuildPlanInfluencePosition, 0, position);    // Influence toward position
		aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionDistance, 0, 100.0);     // 100m range.
		aiPlanSetVariableFloat(planID, cBuildPlanInfluencePositionValue, 0, 200.0);        // 200 points max
		aiPlanSetVariableInt(planID, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
		
		
		if(distance(position, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) < 31 && puid != gHouseUnit && kbGetCiv() != cCivXPSioux)
		{
			aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0, gTownCenter);
			aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 30);     // 30m range.
			aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -500);
			aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinearInverse); // cBPIFalloffLinear
			
		}
		
		if(distance(position, kbUnitGetPosition(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID))) < 50 && puid != gHouseUnit)
		{
			aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeHomeCityWaterSpawnFlag);
			aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitDistance, 0, 60);
			aiPlanSetVariableFloat(planID, cBuildPlanInfluenceUnitValue, 0, -500);
			aiPlanSetVariableInt(planID, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinearInverse); 
		}
		
		
		if(usingWagon == false)addItemToForecasts(puid,number);
		aiPlanSetActive(planID);
	}
	return(planID);   // Only really useful if number == 1, otherwise returns last value.
}

//==============================================================================
// createMainBase
//==============================================================================
int createMainBase(vector mainVec=cInvalidVector)
{
	//aiEcho("Creating main base at "+mainVec);
	if (mainVec == cInvalidVector)  
	return(-1); 
	int oldMainID = kbBaseGetMainID(cMyID);
	int i = 0;
	
	int count=-1;
	static int unitQueryID=-1;
	int buildingID = -1;
	string buildingName = "";
	if (unitQueryID < 0)
	{
		unitQueryID=kbUnitQueryCreate("NewMainBaseBuildingQuery");
		kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
	}
	
	//Define a query to get all matching units
	if (unitQueryID != -1)
	{
		kbUnitQuerySetPlayerRelation(unitQueryID, -1);
		kbUnitQuerySetPlayerID(unitQueryID, cMyID);
		
		kbUnitQuerySetUnitType(unitQueryID, cUnitTypeBuilding);
		kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
		kbUnitQuerySetPosition(unitQueryID, mainVec);      // Checking new base vector
		kbUnitQuerySetMaximumDistance(unitQueryID, 55.0);
	}
	
	kbUnitQueryResetResults(unitQueryID);
	count = kbUnitQueryExecute(unitQueryID);
	
	
	while (oldMainID >= 0)
	{
		//aiEcho("Old main base was "+oldMainID+" at "+kbBaseGetLocation(cMyID, oldMainID));
		kbUnitQuerySetPosition(unitQueryID,kbBaseGetLocation(cMyID, oldMainID));      // Checking old base location
		kbUnitQueryResetResults(unitQueryID);
		count = kbUnitQueryExecute(unitQueryID);
		int unitID = -1;
		
		
		// Remove old base's resource breakdowns
		aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, oldMainID);
		aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, oldMainID);
		aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, oldMainID);
		aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, oldMainID);
		aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, oldMainID);
		aiRemoveResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, oldMainID);
		aiRemoveResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, oldMainID);
		
		kbBaseDestroy(cMyID, oldMainID);
		oldMainID = kbBaseGetMainID(cMyID);
	}
	
	
	int newBaseID=kbBaseCreate(cMyID, "Base"+kbBaseGetNextID(), mainVec, 50.0);
	
	
	//kbBaseCreate(cMyID, "Base"+kbBaseGetNextID(), kbGetMapCenter()-mainVec, 50.0);
	
	
	/*
		bool kbBaseSetFrontVector( int playerID/n int baseID/n vector frontVector ): Sets the front (and back) of the base.
		bool kbBaseSetActive( int playerID/n int baseID/n bool active ): Sets the active flag of the base.
		bool kbBaseSetMain( int playerID/n int baseID/n bool main ): Sets the main flag of the base.
		bool kbBaseSetForward( int playerID/n int baseID/n bool forward ): Sets the forward flag of the base.
		bool kbBaseSetMilitary( int playerID/n int baseID/n bool military ): Sets the military flag of the base.
		bool kbBaseSetMilitaryGatherPoint( int playerID/n int baseID/n vector gatherPoint ): Sets the military gather point of the base.
		bool kbBaseSetEconomy( int playerID/n int baseID/n bool Economy ): Sets the economy flag of the base.
		void kbBaseSetMaximumResourceDistance( int playerID/n int baseID/n float distance ): Sets the maximum resource distance of the base.
	*/
	
	//aiEcho("New main base ID is "+newBaseID);
	if (newBaseID > -1)
	{    
		//Figure out the front vector.
		vector baseFront=xsVectorNormalize(kbGetMapCenter()-mainVec);
		kbBaseSetFrontVector(cMyID, newBaseID, baseFront);
		//aiEcho("Setting front vector to "+baseFront);
		//Military gather point.
		float milDist = 40.0;
		while (  kbAreaGroupGetIDByPosition(mainVec+(baseFront*milDist)) != kbAreaGroupGetIDByPosition(mainVec) )
		{
			milDist = milDist - 5.0;
			if (milDist < 6.0)
            break;
		}
		vector militaryGatherPoint = mainVec + (baseFront * milDist);
		
		kbBaseSetMilitaryGatherPoint(cMyID, newBaseID, militaryGatherPoint);
		//Set the other flags.
		kbBaseSetMilitary(cMyID, newBaseID, true);
		kbBaseSetEconomy(cMyID, newBaseID, true);
		//Set the resource distance limit.
		
		
		// 200m x 200m map, assume I'm 25 meters in, I'm 150m from enemy base.  This sets the range at 80m.
		//(cMyID, newBaseID, (kbGetMapXSize() + kbGetMapZSize())/5);   // 40% of average of map x and z dimensions.
		kbBaseSetMaximumResourceDistance(cMyID, newBaseID, 150.0); // 100 led to age-2 gold starvation
		kbBaseSetSettlement(cMyID, newBaseID, true);
		//Set the main-ness of the base.
		kbBaseSetMain(cMyID, newBaseID, true); 
		
		// Add the TC, if any.
		
		if (getUnit(gTownCenter, cMyID, cUnitStateABQ) >= 0)
		kbBaseAddUnit(cMyID, newBaseID, getUnit(gTownCenter, cMyID, cUnitStateABQ));
	}
	
	
	// Move the defend plan and reserve plan
	xsEnableRule("endDefenseReflexDelay"); // Delay so that new base ID will exist
	
	//   xsEnableRule("populateMainBase");   // Can't add units yet, they still appear to be owned by deleted base.  This rule adds a slight delay.
	
	return(newBaseID);
}

//==============================================================================
// getAllyCount() // Returns number of allies EXCLUDING self
//==============================================================================
int getAllyCount()
{
	int retVal = 0;
	
	int player = 0;
	for (player=1; < cNumberPlayers)
	{
		if (player == cMyID)
		continue;
		
		if (kbIsPlayerAlly(player) == true)
		retVal = retVal + 1;
	}
	
	return(retVal);
}


//==============================================================================
// getEnemyCount() // Returns number of enemies excluding gaia
//==============================================================================
int getEnemyCount()
{
	int retVal = 0;
	
	int player = 0;
	for (player=1; < cNumberPlayers)
	{
		if (player == cMyID)
		continue;
		
		if (kbIsPlayerEnemy(player) == true)
		retVal = retVal + 1;
	}
	
	return(retVal);
}

//==============================================================================
// arraySortFloat
/*
	Takes two arrays, the source and the target.
	Source has the original values, and is a float array.
	Target (int array) will receive the indexes into source in descending order.  For example,
	if the highest value in source is source[17] with a value of 91, then
	arraySort(source, target) will assign target[0] the value of 17, and 
	source[target[0]] will be 91.
	
*/
//==============================================================================
bool arraySortFloat(int sourceArray=-1, int targetArray=-1)
{
	int pass = 0;
	int i = 0; 
	int size = xsArrayGetSize(sourceArray);
	if (size != xsArrayGetSize(targetArray))
	{
		//aiEcho("ArraySort error, source and target are not of same size.");
		return(false);
	}
	
	float highestScore = 1000000.0;  // Highest score found on previous pass
	float highScore = -1000000.0;    // Highest score found on this pass
	int highestScoreIndex = -1;      // Which element had the high score last pass?
	int highScoreIndex = -1;         // Which element has the highest score so far this pass?
	for (pass=0; < size)             // Sort the array
	{
		highScore = -1000000.0;
		highScoreIndex = -1;
		for (i=0; < size)   // Look for highest remaining value
		{
			if ( xsArrayGetFloat(sourceArray, i) > highestScore ) // We're over the highest score, already been selected.  Skip.
            continue;
			
			if ( (xsArrayGetFloat(sourceArray, i) == highestScore) && (highestScoreIndex >= i) ) // Tie with a later one, we've been selected.  Skip.
            continue;
			
			if ( xsArrayGetFloat(sourceArray, i) <= highScore ) // We're not the highest so far on this pass, skip.
            continue;
			
			highScore = xsArrayGetFloat(sourceArray, i);    // This is the highest score this pass
			highScoreIndex = i;                                // So remember this index
		}
		//      if(xsArrayGetString(gMissionStrings, highScoreIndex) != " ")
		//         aiEcho("        "+highScoreIndex+" "+highScore+" "+xsArrayGetString(gMissionStrings,highScoreIndex));
		xsArraySetInt(targetArray, pass, highScoreIndex);
		highestScore = highScore;           // Save this for next pass
		highestScoreIndex = highScoreIndex;
	}
	return(true);
}

//==============================================================================
// getRandomPlayerByRelation
/*
	Returns a randomly selected ally or enemy.
	
*/
//==============================================================================
int getRandomPlayerByRelation(int playerRelation = -1)
{
	int retVal = -1;
	int matchCount = -1;    // I.e. there are 3 matching players
	int matchIndex = -1;    // Used for traversal
	int playerToGet = -1;   // i.e. get the 2nd matching player
	
	
	// Get a count of matching players
	matchCount = 0;
	for (matchIndex = 1; < cNumberPlayers)
	{
		if ( (playerRelation == cPlayerRelationAlly) && (kbIsPlayerAlly(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
		matchCount = matchCount + 1;
		if ( ( (playerRelation == cPlayerRelationEnemy) || (playerRelation == cPlayerRelationEnemyNotGaia) ) && (kbIsPlayerEnemy(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
		matchCount = matchCount + 1;
		if ( (playerRelation == cPlayerRelationSelf) && (cMyID == matchIndex) && (kbHasPlayerLost(matchIndex) == false))
		matchCount = matchCount + 1;
	}
	
	if (matchCount < 1)
	return(-1);
	
	playerToGet = aiRandInt(matchCount) + 1;  // If there are 3 matches, return 1, 2 or 3
	
	// Traverse the list again, and get the matching player.
	matchCount = 0;
	for (matchIndex = 1; < cNumberPlayers)
	{
		if ( (playerRelation == cPlayerRelationAlly) && (kbIsPlayerAlly(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
		matchCount = matchCount + 1;
		if ( ( (playerRelation == cPlayerRelationEnemy) || (playerRelation == cPlayerRelationEnemyNotGaia) )&& (kbIsPlayerEnemy(matchIndex) == true) && (kbHasPlayerLost(matchIndex) == false))
		matchCount = matchCount + 1;
		if ( (playerRelation == cPlayerRelationSelf) && (cMyID == matchIndex) && (kbHasPlayerLost(matchIndex) == false))
		matchCount = matchCount + 1;
		
		if (matchCount == playerToGet)
		{
			retVal = matchIndex;    // Save this player's number
			break;
		}
	}
	
	return(retVal);
}

//==============================================================================
// getTeamPosition
/*
	Returns the player's position in his/her team, i.e. in a 123 vs 456 game, 
	player 5's team position is 2, player 3 is 3, player 4 is 1.
	
	Excludes resigned players.
	
*/
//==============================================================================
int getTeamPosition(int playerID = -1)
{
	int index = -1;    // Used for traversal
	int playerToGet = -1;   // i.e. get the 2nd matching playe
	
	// Traverse list of players, increment when we find a teammate, return when we find my number.
	int retVal = 0;      // Zero if I don't exist...
	for (index = 1; < cNumberPlayers)
	{
		if ( (kbHasPlayerLost(index) == false) && (kbGetPlayerTeam(playerID) == kbGetPlayerTeam(index)) )
		retVal = retVal + 1; // That's another match
		
		if ( index == playerID )
		return(retVal);
	}
	return(-1);
}

//==============================================================================
// getEnemyPlayerByTeamPosition
/*
	Returns the ID of the Nth player on the enemy team, returns -1 if 
	there aren't that many players.
	
	Excludes resigned players.
*/

int getEnemyPlayerByTeamPosition(int position = -1)
{
	
	int matchCount = 0;
	int index = -1;    // Used for traversal
	int playerToGet = -1;   // i.e. get the 2nd matching playe
	
	// Traverse list of players, return when we find the matching player
	for (index = 1; < cNumberPlayers)
	{
		if ( (kbHasPlayerLost(index) == false) && (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(index)) )
		matchCount = matchCount + 1; // Enemy player, add to the count
		
		if ( matchCount == position )
		return(index);
	}
	return(-1);
}

//==============================================================================
// getClosestVPSite
/*
	Returns the VPSiteID of the closest VP Site that matches the parms.
	-1 means don't care, everything matches.
	To get the closest site that has been claimed (building or complete) by an enemy,
	use cVPStateAny with playerRelationOrID set to cPlayerRelationEnemy.  (Unbuilt ones have gaia ownership)
*/
//==============================================================================
int getClosestVPSite(vector location=cInvalidVector, int type=cVPAll, int state=cVPStateAny, int playerRelationOrID=-1)
{
	int retVal = -1;
	int vpList = kbVPSiteQuery(type, playerRelationOrID, state);
	vector siteLocation = cInvalidVector;
	int count = xsArrayGetSize(vpList);
	int index = 0;
	int siteID = 0;
	float dist = 0.0;
	float minDist = 100000.0;
	
	for (index = 0; < count)
	{
		siteID = xsArrayGetInt(vpList, index);
		siteLocation = kbVPSiteGetLocation(siteID);
		dist = distance(location, siteLocation);
		if (dist < minDist)
		{
			retVal = siteID;  // Remember this one.
			minDist = dist;
		}
	}
	
	return(retVal);
}

int getfarthestVPSite (vector location=cInvalidVector, int type=cVPAll, int state=cVPStateAny, int playerRelationOrID=-1)
{
	int retVal = -1;
	int vpList = kbVPSiteQuery(type, playerRelationOrID, state);
	vector siteLocation = cInvalidVector;
	int count = xsArrayGetSize(vpList);
	int index = 0;
	int siteID = 0;
	float dist = 100000;//0.0;
	float minDist = 0;//100000.0;
	
	for (index = 0; < count)
	{
		bool pass = false;
		siteID = xsArrayGetInt(vpList, index);
		siteLocation = kbVPSiteGetLocation(siteID);
		dist = distance(location, siteLocation);
		if (dist > minDist) // && pass == true
		{
			retVal = siteID;  // Remember this one.
			minDist = dist;
		}
	}
	
	return(retVal);
}


//==============================================================================
// chooseAttackPlayerID
/*
	Given a point/radius, look for enemy units, and choose the owner of one
	as an appropriate player to attack.
	
	If none found, return mostHatedEnemy.
*/
//==============================================================================
int   chooseAttackPlayerID(vector point=cInvalidVector, float radius = 50.0)
{
	int retVal = aiGetMostHatedPlayerID();
	static int queryID = -1;
	
	if (point == cInvalidVector)
	return(retVal);
	
	if (queryID < 0)
	{
		queryID = kbUnitQueryCreate("Choose attack player");
		kbUnitQuerySetPlayerRelation(queryID, cPlayerRelationEnemyNotGaia);   // Any enemy units in point/radius
		kbUnitQuerySetIgnoreKnockedOutUnits(queryID, true);
		kbUnitQuerySetUnitType(queryID, cUnitTypeUnit);
		kbUnitQuerySetState(queryID, cUnitStateAlive);
	}
	kbUnitQuerySetPosition(queryID, point);
	kbUnitQuerySetMaximumDistance(queryID, radius);
	kbUnitQueryResetResults(queryID);
	int count = kbUnitQueryExecute(queryID);
	int index = 0;
	int unitID = 0;
	for (index = 0; < count)
	{
		unitID = kbUnitQueryGetResult(queryID, index);
		if (kbUnitGetPlayerID(unitID) > 0)  // Not Gaia
		{
			retVal = kbUnitGetPlayerID(unitID);  // Owner of first (random) non-gaia unit
			break;
		}
	}
	
	return(retVal);
}

//==============================================================================
// New functions for the Draugur AI
//==============================================================================

//==============================================================================
// chooseEuropeanPolitician()
// Chooses age-up politicians for European civilizations
//==============================================================================
int chooseEuropeanPolitician()
{
	int position = 0;
	int randomizer = -1;
	int numChoices = -1;
	int politician = -1;
	int bestChoice = 0;
	int bestScore = 0;
	
	// Reset score array
	for (i=0; <6)
	xsArraySetInt(gPoliticianScores, i, 0);
	
	// Choose politician
	switch (kbGetAge())
	{
		case cAge1:
		{  // Governor for turtler, resources or settlers for rusher, biased against the Naturalist
			randomizer = aiRandInt(10); // 0-9
			
			// Create array of politicians to choose from
			for (i=0; <6)
			{
				politician = xsArrayGetInt(gAge2PoliticianList, i);
				if (kbTechGetStatus(politician) == cTechStatusObtainable)
				{
					xsArraySetInt(gAgeUpPoliticians, position, politician);
					position = position + 1;
				}
			}
			
			// Weight politicians as appropriate
			numChoices = position;
			for (i=0; <numChoices)
			{
				politician = xsArrayGetInt(gAgeUpPoliticians, i);
				if (btOffenseDefense < 0.0)
				{
					if (politician == cTechPoliticianGovernor)
					{
						xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
					}
				}
				if (btRushBoom > 0.0)
				{
					if ((politician == cTechPoliticianGovernor) ||
					(politician == cTechPoliticianNaturalist))
					{
						xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 10);
					}
				}
				if (randomizer < 5)
				{
					if (politician == cTechPoliticianNaturalist)
					{
						xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 10);
					}
				}
			}
			// Add random bonus
			randomizer = aiRandInt(numChoices);
			xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);
			
			// Choose politician with best score
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gPoliticianScores, i);
					bestChoice = i;
				}
			}
			politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
			break;
		}
		case cAge2:
		{  // Randomized, but biased towards Admiral or Pirate for water maps
			randomizer = aiRandInt(10); // 0-9
			
			// Create array of politicians to choose from
			for (i=0; <16)
			{
				politician = xsArrayGetInt(gAge3PoliticianList, i);
				if (kbTechGetStatus(politician) == cTechStatusObtainable)
				{
					xsArraySetInt(gAgeUpPoliticians, position, politician);
					position = position + 1;
				}
			}
			
			// Weight politicians as appropriate
			numChoices = position;
			for (i=0; <numChoices)
			{
				politician = xsArrayGetInt(gAgeUpPoliticians, i);
				if ((cRandomMapName == "amazonia") ||
					(cRandomMapName == "caribbean") ||
					(cRandomMapName == "ceylon") ||
				((randomizer < 5) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)))
				{
					if ((politician == cTechPoliticianAdmiral) ||
						(politician == cTechPoliticianAdmiralOttoman) ||
					(politician == cTechPoliticianPirate))
					{
						xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
					}
				}
				if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) == 0)
				{
					if ((politician == cTechPoliticianAdmiral) ||
						(politician == cTechPoliticianAdmiralOttoman) ||
					(politician == cTechPoliticianPirate))
					{
						xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) - 10);
					}
				}
			}
			// Add random bonus
			randomizer = aiRandInt(numChoices);
			xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);
			
			// Choose politician with best score
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gPoliticianScores, i);
					bestChoice = i;
				}
			}
			politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
			break;
		}
		case cAge3:
		{  // Randomized, but biased towards the Engineer
			randomizer = aiRandInt(10); // 0-9
			
			// Create array of politicians to choose from
			for (i=0; <24)
			{
				politician = xsArrayGetInt(gAge4PoliticianList, i);
				if (kbTechGetStatus(politician) == cTechStatusObtainable)
				{
					xsArraySetInt(gAgeUpPoliticians, position, politician);
					position = position + 1;
				}
			}
			
			// Weight politicians as appropriate
			numChoices = position;
			for (i=0; <numChoices)
			{
				politician = xsArrayGetInt(gAgeUpPoliticians, i);
				if (randomizer < 3)
				{
					if ((politician == cTechPoliticianEngineer) ||
					(politician == cTechPoliticianEngineerPortuguese))
					{
						xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
					}
				}
			}
			// Add random bonus
			randomizer = aiRandInt(numChoices);
			xsArraySetInt(gPoliticianScores, randomizer, xsArrayGetInt(gPoliticianScores, randomizer) + 5);
			
			// Choose politician with best score
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gPoliticianScores, i);
					bestChoice = i;
				}
			}
			politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
			break;
		}
		case cAge4:
		{  // Randomized, but heavily biased towards the General
			randomizer = aiRandInt(10); // 0-9
			
			
			//updatedOn 2019/05/01 By ageekhere  
			// Create array of politicians to choose from
			//---------------------------
			for (i=0; <7)
			{
				politician = xsArrayGetInt(gAge5PoliticianList, i);
				if (kbTechGetStatus(politician) == cTechStatusObtainable)
				{
					if(politician == 2637 && kbGetCiv() == cCivUSA)
					{
						xsArraySetInt(gAgeUpPoliticians, position, politician);
						position = position + 1;
					}
				}
			}
			//---------------------------
			
			// Weight politicians as appropriate
			numChoices = position;
			for (i=0; <numChoices)
			{
				politician = xsArrayGetInt(gAgeUpPoliticians, i);
				if (randomizer < 8)
				{
					if ((politician == cTechPoliticianGeneral) ||
						(politician == cTechPoliticianGeneralUSA) ||
						(politician == cTechPoliticianGeneralBritish) ||
						(politician == cTechPoliticianGeneralOttoman) ||
					(politician == cTechPoliticianGeneralSkirmisher))
					{
						xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
					}
				}
				else
				{
					if ((politician == cTechPoliticianPresidente) ||
					(politician == cTechPoliticianPresidenteEU))
					{
						xsArraySetInt(gPoliticianScores, i, xsArrayGetInt(gPoliticianScores, i) + 10);
					}
				}
			}
			
			// Choose politician with best score
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gPoliticianScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gPoliticianScores, i);
					bestChoice = i;
				}
			}
			politician = xsArrayGetInt(gAgeUpPoliticians, bestChoice);
			break;
		}
	}
	
	// aiEcho("Chosen age-up politician: "+kbGetTechName(politician));
	return(politician);
}

//==============================================================================
// chooseNativeCouncilMember()
// Chooses age-up council members for native civilizations
//==============================================================================
int chooseNativeCouncilMember()
{
	int randomizer = -1;
	int numChoices = -1;
	int politician = -1;
	int bestChoice = 0;
	int bestScore = 0;
	
	for (i=0; <6)
	xsArraySetInt(gNatCouncilScores, i, 0);   // reset array
	
	switch (kbGetAge())
	{
		case cAge1:
		{  // Aztec chief and wise woman to be avoided
			numChoices = aiGetPoliticianListCount(cAge2);
			for (i=0; <numChoices)
			{
				politician = aiGetPoliticianListByIndex(cAge2, i);
				if ((politician == cTechTribalAztecChief2) ||
				(politician == cTechTribalAztecWisewoman2))
				{
					xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
				}
			}
			randomizer = aiRandInt(numChoices);
			xsArraySetInt(gNatCouncilScores, randomizer, xsArrayGetInt(gNatCouncilScores, randomizer) + 5);
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gNatCouncilScores, i);
					bestChoice = i;
				}
			}
			politician = aiGetPoliticianListByIndex(cAge2, bestChoice);
			break;
		}
		case cAge2:
		{  // Aztec chief to be avoided
			numChoices = aiGetPoliticianListCount(cAge3);
			for (i=0; <numChoices)
			{
				politician = aiGetPoliticianListByIndex(cAge3, i);
				if (politician == cTechTribalAztecChief3)
				{
					xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
				}
				if (kbTechGetStatus(politician) != cTechStatusObtainable)
				{
					xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 50);
				}
				xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
			}
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gNatCouncilScores, i);
					bestChoice = i;
				}
			}
			politician = aiGetPoliticianListByIndex(cAge3, bestChoice);
			break;
		}
		case cAge3:
		{  // Aztec chief, Iroquois shaman, Sioux wise woman and all messengers to be avoided if possible
			numChoices = aiGetPoliticianListCount(cAge4);
			for (i=0; <numChoices)
			{
				politician = aiGetPoliticianListByIndex(cAge4, i);
				if ((politician == cTechTribalAztecChief4) ||
					(politician == cTechTribalIroquoisShaman4) ||
					(politician == cTechTribalSiouxWisewoman4) ||
					(politician == cTechTribalAztecYouth4) ||
					(politician == cTechTribalIroquoisYouth4) ||
				(politician == cTechTribalSiouxYouth4))
				{
					xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
				}
				if (kbTechGetStatus(politician) != cTechStatusObtainable)
				{
					xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 50);
				}
				xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
			}
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gNatCouncilScores, i);
					bestChoice = i;
				}
			}
			politician = aiGetPoliticianListByIndex(cAge4, bestChoice);
			break;
		}
		case cAge4:
		{  // Aztec chief, Iroquois shaman, Sioux wise woman and all messengers to be avoided if possible
			numChoices = aiGetPoliticianListCount(cAge5);
			for (i=0; <numChoices)
			{
				politician = aiGetPoliticianListByIndex(cAge5, i);
				if ((politician == cTechTribalAztecChief5) ||
					(politician == cTechTribalIroquoisShaman5) ||
					(politician == cTechTribalSiouxWisewoman5) ||
					(politician == cTechTribalAztecYouth5) ||
					(politician == cTechTribalIroquoisYouth5) ||
				(politician == cTechTribalSiouxYouth5))
				{
					xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 10);
				}
				if (kbTechGetStatus(politician) != cTechStatusObtainable)
				{
					xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) - 50);
				}
				xsArraySetInt(gNatCouncilScores, i, xsArrayGetInt(gNatCouncilScores, i) + aiRandInt(10));
			}
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gNatCouncilScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gNatCouncilScores, i);
					bestChoice = i;
				}
			}
			politician = aiGetPoliticianListByIndex(cAge5, bestChoice);
			break;
		}
	}
		//aiChat(1,"politician " + kbTechGetStatus(politician));
	//aiEcho("Chosen age-up council member: "+kbGetTechName(politician));
	return(politician);
}

//==============================================================================
// chooseAsianWonder()
// Chooses age-up wonders for Asian civilizations
//==============================================================================
int chooseAsianWonder()
{
	int numChoices = -1;
	int politician = -1;
	int ageUpWonder = -1;
	int bestChoice = 0;
	int bestScore = 0;
	
	for (i=0; <6)
	xsArraySetInt(gAsianWonderScores, i, 0);   // reset array
	
	switch (kbGetAge())
	{
		case cAge1:
		{
			numChoices = aiGetPoliticianListCount(cAge2);
			for (i=0; <numChoices)
			{
				politician = aiGetPoliticianListByIndex(cAge2, i);
				if (politician == cTechYPWonderChinesePorcelainTower2) // slight bias against porcelain tower
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
				}
				if (politician == cTechYPWonderIndianAgra2) // slight bias towards agra fort
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
				}
				if (politician == cTechYPWonderIndianTajMahal2) // avoid Taj Mahal
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
				}
				if (politician == cTechYPWonderJapaneseGiantBuddha2) // slight bias against giant buddha
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
				}
				xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
			}
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gAsianWonderScores, i);
					bestChoice = i;
				}
			}
			politician = aiGetPoliticianListByIndex(cAge2, bestChoice);
			//aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));
			
			// Find building corresponding to chosen tech (i.e. "politician")
			for (i=0; <15)
			{
				if (xsArrayGetInt(gAge2WonderTechList, i) == politician)
				{
					ageUpWonder = xsArrayGetInt(gAge2WonderList, i);
				}
			}
			break;
		}
		case cAge2:
		{
			numChoices = aiGetPoliticianListCount(cAge3);
			for (i=0; <numChoices)
			{
				politician = aiGetPoliticianListByIndex(cAge3, i);
				if (politician == cTechYPWonderChinesePorcelainTower3) // slight bias against porcelain tower
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
				}
				if (politician == cTechYPWonderIndianAgra3) // slight bias towards agra fort
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
				}
				if (politician == cTechYPWonderIndianTajMahal3) // avoid Taj Mahal
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
				}
				if (politician == cTechYPWonderJapaneseGiantBuddha3) // slight bias against giant buddha
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
				}
				if (politician == cTechYPWonderJapaneseGoldenPavillion3) // slight bias towards golden pavillion
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
				}
				if (politician == cTechYPWonderJapaneseShogunate3) // slight bias towards shogunate
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 5);
				}
				if (kbTechGetStatus(politician) != cTechStatusObtainable)
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
				}
				xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
			}
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gAsianWonderScores, i);
					bestChoice = i;
				}
			}
			politician = aiGetPoliticianListByIndex(cAge3, bestChoice);
			//aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));
			
			// Find building corresponding to chosen tech (i.e. "politician")
			for (i=0; <15)
			{
				if (xsArrayGetInt(gAge3WonderTechList, i) == politician)
				{
					ageUpWonder = xsArrayGetInt(gAge3WonderList, i);
				}
			}
			break;
		}
		case cAge3:
		{
			numChoices = aiGetPoliticianListCount(cAge4);
			for (i=0; <numChoices)
			{
				politician = aiGetPoliticianListByIndex(cAge4, i);
				if (politician == cTechYPWonderChinesePorcelainTower4) // strong bias towards porcelain tower
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (politician == cTechYPWonderChineseConfucianAcademy4) // strong bias towards confucian academy
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (politician == cTechYPWonderChineseWhitePagoda4) // slight bias against white pagoda
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
				}
				if (politician == cTechYPWonderIndianCharminar4) // strong bias towards charminar gate
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (politician == cTechYPWonderIndianTajMahal4) // avoid Taj Mahal
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
				}
				if (politician == cTechYPWonderJapaneseGiantBuddha4) // slight bias against giant buddha
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
				}
				if (politician == cTechYPWonderJapaneseGoldenPavillion4) // strong bias towards golden pavillion
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (politician == cTechYPWonderJapaneseShogunate4) // strong bias towards shogunate
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (kbTechGetStatus(politician) != cTechStatusObtainable)
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
				}
				xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
			}
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gAsianWonderScores, i);
					bestChoice = i;
				}
			}
			politician = aiGetPoliticianListByIndex(cAge4, bestChoice);
			//aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));
			
			// Find building corresponding to chosen tech (i.e. "politician")
			for (i=0; <15)
			{
				if (xsArrayGetInt(gAge4WonderTechList, i) == politician)
				{
					ageUpWonder = xsArrayGetInt(gAge4WonderList, i);
				}
			}
			break;
		}
		case cAge4:
		{
			numChoices = aiGetPoliticianListCount(cAge5);
			for (i=0; <numChoices)
			{
				politician = aiGetPoliticianListByIndex(cAge5, i);
				if (politician == cTechYPWonderChinesePorcelainTower5) // strong bias towards porcelain tower
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (politician == cTechYPWonderChineseConfucianAcademy5) // strong bias towards confucian academy
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (politician == cTechYPWonderChineseTempleOfHeaven5) // avoid temple of heaven
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
				}
				if (politician == cTechYPWonderChineseWhitePagoda5) // slight bias against white pagoda
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
				}
				if (politician == cTechYPWonderIndianCharminar5) // strong bias towards charminar gate
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (politician == cTechYPWonderIndianTajMahal5) // avoid Taj Mahal
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 10);
				}
				if (politician == cTechYPWonderJapaneseGiantBuddha5) // slight bias against giant buddha
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 5);
				}
				if (politician == cTechYPWonderJapaneseGoldenPavillion5) // strong bias towards golden pavillion
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (politician == cTechYPWonderJapaneseShogunate5) // strong bias towards shogunate
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + 10);
				}
				if (kbTechGetStatus(politician) != cTechStatusObtainable)
				{
					xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) - 50);
				}
				xsArraySetInt(gAsianWonderScores, i, xsArrayGetInt(gAsianWonderScores, i) + aiRandInt(10));
			}
			for (i=0; <numChoices)
			{
				if (xsArrayGetInt(gAsianWonderScores, i) >= bestScore)
				{
					bestScore = xsArrayGetInt(gAsianWonderScores, i);
					bestChoice = i;
				}
			}
			politician = aiGetPoliticianListByIndex(cAge5, bestChoice);
			//aiEcho("Chosen age-up wonder: "+kbGetTechName(politician));
			
			// Find building corresponding to chosen tech (i.e. "politician")
			for (i=0; <15)
			{
				if (xsArrayGetInt(gAge5WonderTechList, i) == politician)
				{
					ageUpWonder = xsArrayGetInt(gAge5WonderList, i);
				}
			}
			break;
		}
		
	}
	//aiEcho("Chosen age-up wonder: "+kbGetProtoUnitName(ageUpWonder));
	return(ageUpWonder);
}

//==============================================================================
// Economy
//==============================================================================

void startTCBuildPlan(vector location=cInvalidVector)
{
	if (cvOkToBuild == false)
	return;
	//aiEcho("Creating a TC build plan.");
	// Make a town center, pri 100, econ, main base, 1 builder.
	int buildPlan=aiPlanCreate("TC Build plan ", cPlanBuild);
	// What to build
	aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTownCenter);
	// Priority.
	aiPlanSetDesiredPriority(buildPlan, 100);
	// Mil vs. Econ.
	aiPlanSetMilitary(buildPlan, false);
	aiPlanSetEconomy(buildPlan, true);
	// Escrow.
	aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
	// Builders.
	int villcount = 1;
	if(getUnit(gTownCenter, cMyID, cUnitStateABQ) < 1)villcount = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
	aiPlanAddUnitType(buildPlan, gCoveredWagonUnit, villcount, villcount, villcount);
	
	// Instead of base ID or areas, use a center position and falloff.
	aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, location);
	aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 50.00);
	
	// Add position influences for trees, gold, TCs.
	aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 4, true);
	aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 4, true);
	aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 4, true);
	aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 4, true);
	
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 30.0);     // 30m range.
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);        // 10 points per tree
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
	
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1,40.0);              // 40 meter range for gold
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 300.0);                // 300 points each
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
	
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2, 10.0);              // 10 meter inhibition to keep some space
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -300.0);                // -300 points each
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);      // Cliff falloff
	
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, gTownCenter);
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 3, 40.0);              // 40 meter inhibition around TCs.
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 3, -500.0);                // -500 points each
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, cBPIFalloffNone);      // Cliff falloff
	
	
	// Weight it to prefer the general starting neighborhood
	aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, location);    // Position influence for landing position
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 100.0);     // 100m range.
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);        // 300 points max
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
	
	
	
	aiPlanSetActive(buildPlan);
	aiPlanSetEventHandler(buildPlan, cPlanEventStateChange, "tcPlacedEventHandler");
	gTCBuildPlanID = buildPlan;   // Save in a global var so the rule can access it.
	
	
}

//==============================================================================
/* rule econUpgrades
	
	Make sure we always have an econ upgrade plan running.  Go cheapest first.
*/
//==============================================================================

rule econUpgrades
inactive
group tcComplete
minInterval 30
{
	//return();
	int planState = -1;
	int techToGet = -1;
	float lowestCost = 1000000.0;
	static int gatherTargets = -1;   // Array to hold the list of things we gather from, i.e. mill, tree, etc.
	static int gatherTargetTypes = -1;  // Array.  If gatherTargets(x) == mill, then gatherTargetTypes(x) = cResourceFood.
	int target = -1;  // Index used to step through arrays
	static int startTime = -1;       // Time last plan was started, to make sure we're not waiting on an obsolete tech.
	
	if (gatherTargets < 0)  // Array not initialized
	{  // Set up our list of target units (what we gather from) and their resource categories.
		gatherTargets = xsArrayCreateInt(10, -1, "Gather Targets");
		gatherTargetTypes = xsArrayCreateInt(10, -1, "Gather Target Types");
		
		xsArraySetInt(gatherTargets, 0, gFarmUnit); // Mills and farms generate food
		xsArraySetInt(gatherTargetTypes, 0, cResourceFood);
		
		xsArraySetInt(gatherTargets, 1, cUnitTypeTree); // Trees generate wood
		xsArraySetInt(gatherTargetTypes, 1, cResourceWood);
		
		xsArraySetInt(gatherTargets, 2, cUnitTypeAbstractMine); // Mines generate gold
		xsArraySetInt(gatherTargetTypes, 2, cResourceGold);
		
		if ( (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) {
			xsArraySetInt(gatherTargets, 3, cUnitTypeHuntable);   // Huntables generate food, BHG: not for the japanese!
		}
		xsArraySetInt(gatherTargetTypes, 3, cResourceFood);
		
		xsArraySetInt(gatherTargets, 4, cUnitTypeFish);       // Fish generate food
		xsArraySetInt(gatherTargetTypes, 4, cResourceFood);
		
		xsArraySetInt(gatherTargets, 5, gPlantationUnit);       // Plantations generate gold
		xsArraySetInt(gatherTargetTypes, 5, cResourceGold);
		
		xsArraySetInt(gatherTargets, 6, cUnitTypeBerryBush);
		xsArraySetInt(gatherTargetTypes, 6, cResourceFood);
		
		xsArraySetInt(gatherTargets, 7, cUnitTypeypBerryBuilding);
		xsArraySetInt(gatherTargetTypes, 7, cResourceFood);
	}
	
	planState = aiPlanGetState(gEconUpgradePlan);
	
	if ( planState < 0 )
	{  // Plan is done or doesn't exist
		aiPlanDestroy(gEconUpgradePlan); // Nuke the old one, if it exists
		startTime = -1;
		
		int techID = -1;        // The cheapest tech for the current target unit type      
		float rawCost = -1.0;   // The cost of the upgrade
		float relCost = -1.0;   // The cost, relative to some estimate of the number of gatherers
		float numGatherers = -1.0;  // Number of gatherers assigned to the resource type (i.e food)
		
		/*
			Step through the array of gather targets.  For each, calculate the cost of the upgrade
			relative to the number of gatherers that would benefit.  Choose the one with the best 
			payoff.
		*/
		for (target=0; < 10)    
		{
			if (xsArrayGetInt(gatherTargets, target) < 0)   // No target specified
            continue;
			techID =  kbTechTreeGetCheapestEconUpgrade(xsArrayGetInt(gatherTargets, target));
			if (techID < 0)   // No tech available for this target type
            continue;
			rawCost = kbGetTechAICost(techID);
			if (rawCost == 0.0)
            rawCost = -1.0;
			
			// Percent of gatherers assigned to this resource, times the number of econ units.
			numGatherers = aiGetResourceGathererPercentage( xsArrayGetInt(gatherTargetTypes, target), cRGPActual ) *  kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
			
			// Calculate the relative cost
			switch( xsArrayGetInt(gatherTargets, target) )
			{
				case cUnitTypeHuntable:
				{
					// Assume all food gatherers are hunting unless we have a mill.
					relCost = rawCost / numGatherers;
					if (kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive) > 0)
					relCost = -1.0;   // Do NOT get hunting dogs once we're farming
					break;
				}
				case cUnitTypeFish:
				{
					numGatherers = kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive);
					if ( numGatherers > 0.0)
					relCost = rawCost / numGatherers;
					else
					relCost = -1.0;
					break;
				}
				default: // All other resources
				{
					if (numGatherers > 0.0)
					relCost = rawCost / numGatherers;
					else
					relCost = -1.0;                  
					break;
				}
			}
			
			// We now have the relative cost for the cheapest tech that gathers from this target type.
			// See if it's > 0, and the cheapest so far.  If so, save the stats, as long as it's obtainable.
			
			if ( (techID >= 0) && (relCost < lowestCost) && (relCost > 0.0) && (kbTechGetStatus(techID) == cTechStatusObtainable) )
			{
				lowestCost = relCost;
				techToGet = techID;
			}
		}
		
		
		if ( (techToGet >= 0) && (lowestCost < 40.0) )  // We have a tech, and it doesn't cost more than 40 per gatherer
		{
			
			// If a plan has been running for 3 minutes...
			if ( (startTime > 0) && (xsGetTime() > (startTime + 180000)) )
			{
				// If it's still the tech we want, reset the start time counter and quit out.  Otherwise, kill it.
				if (aiPlanGetVariableInt(gEconUpgradePlan, cProgressionPlanGoalTechID, 0) == techToGet)
				{
					startTime = xsGetTime();
					return;
				}
				else
				{
					//aiEcho("***** Destroying econ upgrade plan # "+gEconUpgradePlan+" because it has been running more than 3 minutes.");
					aiPlanDestroy(gEconUpgradePlan);
				}
			}
			// Plan doesn't exist, or we just killed it due to timeout....
			gEconUpgradePlan = aiPlanCreate("Econ upgrade tech "+techToGet, cPlanProgression);
			aiPlanSetVariableInt(gEconUpgradePlan, cProgressionPlanGoalTechID, 0, techToGet);
			aiPlanSetDesiredPriority(gEconUpgradePlan, 92);
			aiPlanSetEscrowID(gEconUpgradePlan, cEconomyEscrowID);
			aiPlanSetBaseID(gEconUpgradePlan, kbBaseGetMainID(cMyID));
			aiPlanSetActive(gEconUpgradePlan);
			startTime = xsGetTime();
			
			//aiEcho("                **** Creating upgrade plan for "+kbGetTechName(techToGet)+" is "+gEconUpgradePlan);
			//aiEcho("                **** Status for tech "+kbGetTechName(techToGet)+" is "+kbTechGetStatus(techToGet));
			//aiEcho("                **** Relative cost (score) was lowest at "+lowestCost);
		}
	}
	// Otherwise, if a plan already existed, let it run...
}

//==============================================================================
// getLowestResourceAmount
/*
	Returns the amount of the resource that's in shortest supply.
	Note:  It does not identify WHICH resource, it just returns the lowest amount.
	Food, wood and gold/coin are considered, others are not.
*/
//==============================================================================

float getLowestResourceAmount()
{
	float retVal = 1000000.0;
	if (kbResourceGet(cResourceWood) < retVal)
	retVal = kbResourceGet(cResourceWood);
	if (kbResourceGet(cResourceFood) < retVal)
	retVal = kbResourceGet(cResourceFood);
	if (kbResourceGet(cResourceGold) < retVal)
	retVal = kbResourceGet(cResourceGold); 
	return(retVal);   
}

//==============================================================================
// updateSettlerCounts
/*
	Set the settler maintain plan according to age and our behavior traits  
*/
//==============================================================================
void updateSettlerCounts(void)
{
	int normalTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge());
	if (kbGetAge() == cvMaxAge)   // If we're capped at this age, build our full complement of villagers.
	normalTarget = xsArrayGetInt(gTargetSettlerCounts, cAge5);
	int modifiedTarget = normalTarget;
	
	switch (kbGetAge())
	{
		case cAge1:
		{
			modifiedTarget = normalTarget - (5.0 * btRushBoom);   // Rushers five less, boomers 5 more
			break;
		}
		case cAge2:
		{
			modifiedTarget = normalTarget + (5.0 * btRushBoom);  //  Rushers 5 more (stay in age 2 longer), boomers 5 less (go to age 3 ASAP)
			break;
		}
		case cAge3:
		{
			modifiedTarget = normalTarget - (10.0 * btRushBoom);  //  Boomers 10 more, i.e. boom now means 'more econ'.
			break;
		}
		case cAge4:
		{
			modifiedTarget = normalTarget - (10.0 * btRushBoom);
			break;
		}
		case cAge5:
		{
			modifiedTarget = normalTarget - (10.0 * btRushBoom);
			break;
		}
	}
	if (kbGetCiv() != cCivOttomans)
	aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0, modifiedTarget);
	else
	aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0, 0);
	
}

//==============================================================================
// updateEscrows
/*
	Set the econ/mil escrow balances based on age, personality and our current
	settler pop compared to what we want to have.
	
	When we lose a lot of settlers, the economy escrow is expanded and the 
	military escrow is reduced until the econ recovers.  
*/
//==============================================================================
void updateEscrows(void)
{
	float econPercent = 0.0; 
	float milPercent = 0.0;
	float villTarget = xsArrayGetInt(gTargetSettlerCounts, kbGetAge());  // How many we want to have this age
	float villCount = kbUnitCount(cMyID, gEconUnit, cUnitStateABQ);   // How many do we have?
	float villRatio = 1.00;   
	if (villTarget > 0.0)
	villRatio = villCount / villTarget;  // Actual over desired.
	float villShortfall = 1.0 - villRatio;  // 0.0 means at target, 0.3 means 30% short of target
	
	switch(kbGetAge())
	{
		case cAge1:
		{
			econPercent = 0.90 - (0.1 * btRushBoom);  // 80% rushers, 100% boomers
			break;
		}
		case cAge2:
		{
			econPercent = 0.45 - (0.35 * btRushBoom);  // 10% rushers, 80% boomers
			break;
		}
		case cAge3:
		{
			econPercent = 0.30 - (0.15 * btRushBoom) + (0.3 * villShortfall);  // 0.3,  +/- up to 0.15, + up to 0.3 if we have no vills.
			// At 1/2 our target vill pop, this works out to 0.45 +/- rushBoom effect.  At vill pop, it's 0.3 +/- rushBoom factor.
			break;
		}
		case cAge4:
		{
			econPercent = 0.30 - (0.1 * btRushBoom) + (0.3 * villShortfall);
			break;
		}
		case cAge5:
		{
			econPercent = 0.20 - (0.1 * btRushBoom) + (0.3 * villShortfall);
			break;
		}
	}
	if (econPercent < 0.0)
	econPercent = 0.0;
	if (econPercent > 0.8)
	econPercent = 0.8;
	milPercent = 0.8 - econPercent;
	if (kbGetAge() == cAge1)
	milPercent = 0.0;
	
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, econPercent);
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, econPercent/2.0);   // Leave most wood at the root  
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, econPercent);
	
	
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceFame, 0.0);
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceSkillPoints, 0.0);
	kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 1000);    // Save for age upgrades
	kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 200);
	if (kbGetAge() >= cAge3)
	kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 600); // Needed for mills, plantations
	kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 1000);   // Save for age upgrades
	if (kbGetCiv() == cCivDutch)
	{
		kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 350); // Needed for banks
		kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 350);
	}
	else if ( (cvMaxAge > -1) && (kbGetAge() >= cvMaxAge) )
	{  // Not dutch, and not facing age upgrade, so reduce food/gold withholding
		kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 250); 
		kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 250);      
	}
	
	//updatedOn 2019/03/29 By ageekhere  
	//--------------------------- 
	
	if(kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 1)
	{
		kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 600); //save for town center
	}
	//--------------------------- 
	
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, milPercent);
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, milPercent/2.0);  
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, milPercent);
	
	
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFame, 0.0);
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceSkillPoints, 0.0);
	kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 300);
	kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 200);
	kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 300);
	
	xsEnableRule("refresh_escrows");
}

rule refresh_escrows
inactive
minInterval 5
{
	kbEscrowAllocateCurrentResources();
}

//==============================================================================
// updateGatherers
/*
	Given the desired allocation of gatherers, set the desired number
	of gatherers for each active econ base, and the breakdown between
	resources for each base.
*/
//==============================================================================
void updateGatherers(void)
{
	int i = 0;
	
	static int resourcePriorities = -1;    // An array that holds our priorities for cResourceFood, etc.
	if (resourcePriorities < 0)            // Initialize if needed
	resourcePriorities = xsArrayCreateFloat(cNumResourceTypes, 0.0, "resourcePriorities");
	
	aiSetResourceGathererPercentageWeight(cRGPScript, 1.0);
	aiSetResourceGathererPercentageWeight(cRGPCost, 0.0);
	
	/*
		Allocate gatherers based on a weighted average of two systems.  The first system is based
		on the forecasts, ignoring current inventory, i.e. it wants to keep gatherers aligned with
		out medium-term demand, and not swing based on inventory.  The second system is based
		on forecast minus inventory, or shortfall.  This is short-term, highly reactive, and volatile.
		The former factor will be weighted more heavily when inventories are large, the latter when 
		inventories are tight.  (When inventories are zero, they are the same...the second method
		reacts strongly when one resource is at or over forecast, and others are low.)
	*/
	float forecastWeight = 1.0;
	float reactiveWeight = 0.0;   // reactive + forecast = 1.0
	static int forecastValues = -1;  // Array holding the relative forecast-oriented values.
	static int reactiveValues = -1;
	static int gathererPercentages = -1;
	
	if (forecastValues < 0)
	{
		forecastValues = xsArrayCreateFloat(cNumResourceTypes, 0.0, "forecast oriented values");
		reactiveValues = xsArrayCreateFloat(cNumResourceTypes, 0.0, "reactive values");
		gathererPercentages = xsArrayCreateFloat(cNumResourceTypes, 0.0, "gatherer percentages");
	}
	
	float totalForecast = 0.0;
	float totalShortfall = 0.0;
	float fcst = 0.0;
	float shortfall = 0.0;
	for (i=0; <cNumResourceTypes)
	{
		fcst = xsArrayGetFloat(gForecasts, i);
		shortfall = fcst - kbResourceGet(i);
		totalForecast = totalForecast + fcst;
		if (shortfall > 0.0)
		totalShortfall = totalShortfall + shortfall;
	}
	
	if (totalForecast > 0)
	reactiveWeight = totalShortfall / totalForecast;
	else
	reactiveWeight = 1.0;
	forecastWeight = 1.0 - reactiveWeight;
	// Make reactive far more important
	if (totalShortfall > (0.3 * totalForecast))  // we have a significant shortfall
	{  // If it was 40/60 reactive:forecast, this makes it 82/18.
		// 10/90 becomes 73/27;  80/20 becomes 94/6
		reactiveWeight = reactiveWeight + (0.7 * forecastWeight);
		forecastWeight = 1.0 - reactiveWeight;
	}
	
	// Update the arrays
	float scratch = 0.0;
	for (i=0; <cNumResourceTypes)
	{
		fcst = xsArrayGetFloat(gForecasts, i);
		shortfall = fcst - kbResourceGet(i);
		xsArraySetFloat(forecastValues, i, fcst / totalForecast);   // This resource's share of the total forecast
		if ( shortfall > 0 )
		xsArraySetFloat(reactiveValues, i, shortfall / totalShortfall);
		else
		xsArraySetFloat(reactiveValues, i, 0.0);
		
		scratch = xsArrayGetFloat(forecastValues, i) * forecastWeight;
		scratch = scratch + (xsArrayGetFloat(reactiveValues, i) * reactiveWeight);
		xsArraySetFloat(gathererPercentages, i, scratch);
	}   
	//aiEcho("Forecast values:");
	//for (i=0; < cNumResourceTypes)
	//aiEcho("    "+i+" "+xsArrayGetFloat(forecastValues, i));
	
	//aiEcho("Shortfall values:");
	//for (i=0; < cNumResourceTypes)
	//aiEcho("    "+i+" "+xsArrayGetFloat(reactiveValues, i));
	
	//aiEcho("Shortfall weight is "+reactiveWeight);
	
	//aiEcho("Raw gatherer percentages:");
	//for (i=0; < cNumResourceTypes)
	//aiEcho("    "+i+" "+xsArrayGetFloat(gathererPercentages, i));
	
	float totalPercentages = 0.0;
	
	// Adjust for wood and gold being slower to gather
	xsArraySetFloat(gathererPercentages, cResourceWood, xsArrayGetFloat(gathererPercentages, cResourceWood) * 1.4);
	xsArraySetFloat(gathererPercentages, cResourceGold, xsArrayGetFloat(gathererPercentages, cResourceGold) * 1.2);
	
	// Normalize if not 1.0
	totalPercentages = 0.0;
	for(i=0; <cNumResourceTypes)
	totalPercentages = totalPercentages + xsArrayGetFloat(gathererPercentages, i);
	for(i=0; <cNumResourceTypes)
	xsArraySetFloat(gathererPercentages, i, xsArrayGetFloat(gathererPercentages, i) / totalPercentages);
	
	//aiEcho("Wood-adjusted gatherer percentages:");
	//for (i=0; < cNumResourceTypes)
	//aiEcho("    "+i+" "+xsArrayGetFloat(gathererPercentages, i)); 
	
	// Now, consider the effects of dedicated gatherers, like fishing boats, factories and banks, since we need to end up with settler/coureur assignments to pick up the balance.
	float coreGatherers = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
	coreGatherers = coreGatherers + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive);
	float goldGatherers = (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) * 5);
	if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 1)
	goldGatherers = goldGatherers + ((kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) - 1) * 10); // first factory will always produce artillery
	float foodGatherers = kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive);
	float totalGatherers = coreGatherers + goldGatherers + foodGatherers;
	//aiEcho("We have "+goldGatherers+" dedicated gold gatherers.");
	//aiEcho("We have "+foodGatherers+" dedicated food gatherers.");   
	
	float goldWanted = totalGatherers * xsArrayGetFloat(gathererPercentages, cResourceGold);
	if (goldWanted < goldGatherers)
	goldWanted = goldGatherers;
	float foodWanted = totalGatherers * xsArrayGetFloat(gathererPercentages, cResourceFood);
	if (foodWanted < foodGatherers)
	foodWanted = foodGatherers;
	float woodWanted = totalGatherers * xsArrayGetFloat(gathererPercentages, cResourceWood);
	
	
	// What percent of our core gatherers should be on each resource?
	xsArraySetFloat(gathererPercentages, cResourceGold, (goldWanted - goldGatherers) / coreGatherers);
	xsArraySetFloat(gathererPercentages, cResourceFood, (foodWanted - foodGatherers) / coreGatherers);
	xsArraySetFloat(gathererPercentages, cResourceWood, (woodWanted) / coreGatherers);
	// Normalize
	totalPercentages = 0.0;
	for(i=0; <cNumResourceTypes)
	totalPercentages = totalPercentages + xsArrayGetFloat(gathererPercentages, i);
	for(i=0; <cNumResourceTypes)
	xsArraySetFloat(gathererPercentages, i, xsArrayGetFloat(gathererPercentages, i) / totalPercentages);
	
	// Stop gathering wood upon forest depletion
	if (kbGetAmountValidResources(kbBaseGetMainID(cMyID), cResourceWood, cAIResourceSubTypeEasy, 100.0)<3000.0)
	xsArraySetFloat(gathererPercentages, cResourceWood, 0.0);
	
	// Normalize
	totalPercentages = 0.0;
	for(i=0; <cNumResourceTypes)
	totalPercentages = totalPercentages + xsArrayGetFloat(gathererPercentages, i);
	for(i=0; <cNumResourceTypes)
	xsArraySetFloat(gathererPercentages, i, xsArrayGetFloat(gathererPercentages, i) / totalPercentages);
	
	//aiEcho("Gatherer percentages, adjusted for dedicated gatherers:");
	//for (i=0; < cNumResourceTypes)
	//aiEcho("    "+i+" "+xsArrayGetFloat(gathererPercentages, i)); 
	
	// Set the new values.
	for (i=0; <cNumResourceTypes)
	aiSetResourceGathererPercentage(i, xsArrayGetFloat(gathererPercentages, i), false, cRGPScript);
	
	aiNormalizeResourceGathererPercentages(cRGPScript);   // Set them to 1.0 total, just in case these don't add up.
}

void findEnemyBase(void)
{
	if ( (cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "ceylon") )   
	return();   // No sense trying that on these standard maps
	
	if (cvOkToExplore == false)
	return();
	
	// Decide on which unit type to use as scout
	// If possible, cheap infantry is used
	int scoutType = -1;
	if (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeCrossbowman;
	else if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypePikeman;
	else if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeStrelet;
	else if (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeLongbowman;
	else if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeMusketeer;
	else if (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarrior;
	else if (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpAenna;
	else if (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpTomahawk;
	else if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpMacehualtin;
	else if (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpPumaMan;
	else if (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarBow;
	else if (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarClub;
	else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawPistol, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeSaloonOutlawPistol;
	else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawRifleman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeSaloonOutlawRifleman;
	else if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeJanissary;
	else if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypQiangPikeman;
	else if (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypChuKoNu;
	else if (kbUnitCount(cMyID, cUnitTypeypMonkDisciple, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypMonkDisciple;
	else if (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypArquebusier;
	else if (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypChangdao;
	else if (kbUnitCount(cMyID, cUnitTypeypSepoy, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypSepoy;
	else if (kbUnitCount(cMyID, cUnitTypeypNatMercGurkha, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypNatMercGurkha;
	else if (kbUnitCount(cMyID, cUnitTypeypRajput, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypRajput;
	else if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypYumi;
	else if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypAshigaru;
	else if (kbUnitCount(cMyID, cUnitTypeEnvoy, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeEnvoy;
	else if (kbUnitCount(cMyID, cUnitTypeNativeScout, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeNativeScout;
	else if (kbUnitCount(cMyID, cUnitTypeypMongolScout, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypMongolScout;
	else
	scoutType = cUnitTypeLogicalTypeValidSharpshoot;
	
	//Create an explore plan to go there.
	vector myBaseLocation=kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Main base location...need to find reflection.
	vector centerOffset = kbGetMapCenter() - myBaseLocation;
	vector targetLocation = kbGetMapCenter() + centerOffset;
	// TargetLocation is now a mirror image of my base.
	//aiEcho("My base is at "+myBaseLocation+", enemy base should be near "+targetLocation);
	int exploreID=aiPlanCreate("Probe Enemy Base", cPlanExplore);
	if (exploreID >= 0)
	{
		aiPlanAddUnitType(exploreID, scoutType, 1, 1, 1); // Infantry or cavalry only, no explorer!
		aiPlanAddWaypoint(exploreID, targetLocation);
		aiPlanSetVariableBool(exploreID, cExplorePlanDoLoops, 0, false);
		aiPlanSetVariableBool(exploreID, cExplorePlanQuitWhenPointIsVisible, 0, true);
		aiPlanSetVariableBool(exploreID, cExplorePlanAvoidingAttackedAreas, 0, false);
		aiPlanSetVariableInt(exploreID, cExplorePlanNumberOfLoops, 0, -1);
		aiPlanSetRequiresAllNeedUnits(exploreID, true);
		aiPlanSetVariableVector(exploreID, cExplorePlanQuitWhenPointIsVisiblePt, 0, targetLocation);
		aiPlanSetDesiredPriority(exploreID, 100);
		aiPlanSetActive(exploreID);
	}
}

//==============================================================================
/*
	Tower manager
	
	Tries to maintain gNumTowers for the number of towers near the main base.
	
	If there are idle outpost wagons, use them.  If not, use villagers to build outposts.
	Russians use blockhouses via gTowerUnit. Natives build war huts (Iroquois), 
	nobles huts (Aztecs) and teepees (Sioux), and Asians build castles, again 
	selected via gTowerUnit.
	
	Placement algorithm is brain-dead simple.  Check a point that is mid-edge or a 
	corner of a square around the base center.  Look for a nearby tower.  If none, 
	do a tight build plan.  If there is one, try again.    If no luck, try a build
	plan that just avoids other towers.
	
*/
//==============================================================================
/*
	rule fireBase
	inactive
	minInterval 5
	{
	return;
	if(controlCenter == true)
	{
	vector baseCreepLocation = cInvalidVector;
	int playerAttack = aiGetMostHatedPlayerID();
	vector playerBaseLocation=kbBaseGetLocation(playerAttack, kbBaseGetMainID(playerAttack));
	
	int towerFirebase = -1;
	if (towerFirebase == -1) towerFirebase = kbUnitQueryCreate("towerFirebase");
	kbUnitQuerySetPlayerID(towerFirebase, cMyID, false);
	kbUnitQuerySetUnitType(towerFirebase, gTowerUnit);
	kbUnitQuerySetState(towerFirebase, cUnitStateAlive);
	
	float nearestDist = 999999;
	int nearestId = -1;
	for (i = 0; < kbUnitQueryExecute(towerFirebase))
	{
	int unitID = kbUnitQueryGetResult(towerFirebase, i);
	float dist = distance(playerBaseLocation, kbUnitGetPosition(unitID));
	if(dist < nearestDist)
	{
	nearestDist = dist;
	nearestId = unitID;
	}
	}
	//	if(nearestDist > distance(playerBaseLocation, kbGetMapCenter()))return;
	baseCreepLocation = playerBaseLocation - (kbGetMapCenter() + kbUnitGetPosition(unitID));
	
	
	
	float lastDist =99999;
	float dx = 0;
	float dz = 0;
	for(i = 0;<8)
	{
	vector vectorCheck = cInvalidVector;
	switch(i)
	{ 
	case 0:
	{  // W
	dx = -0.9 * dx;
	dz = 0.9 * dz;
	//aiEcho("West...");
	break;
	}
	case 1:
	{  // NW
	dx = 0.0;
	//aiEcho("Northwest...");
	break;
	}
	case 2:
	{  // N
	dx = 0.9 * dx;
	dz = 0.9 * dz;
	//aiEcho("North...");
	break;
	}
	case 3:
	{  // NE
	dz = 0.0;
	//aiEcho("NorthEast...");
	break;
	}
	case 4:
	{  // E
	dx = 0.9 * dx;
	dz = -0.9 * dz;
	//aiEcho("East...");
	break;
	}
	case 5:
	{  // SE
	dx = 0.0;
	dz = -1.0 * dz;
	//aiEcho("SouthEast...");
	break;
	}
	case 6:
	{  // S
	dx = -0.9 * dx;
	dz = -0.9 * dz;
	//aiEcho("South...");
	break;
	}
	case 7:
	{  // SW
	dx = -1.0 * dx;
	dz = 0;
	//aiEcho("SouthWest...");
	break;
	}
	}
	vectorCheck = xsVectorSetX(baseCreepLocation, xsVectorGetX(baseCreepLocation) + dx);
	vectorCheck = xsVectorSetZ(baseCreepLocation, xsVectorGetZ(baseCreepLocation) + dz);
	if(lastDist > distance(playerBaseLocation, vectorCheck))
	{
	lastDist = distance(playerBaseLocation, vectorCheck);
	baseCreepLocation = vectorCheck;
	}			
	}
	if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeOutpost) == -1) createLocationBuildPlan(cUnitTypeOutpost, 1, 100, false, cMilitaryEscrowID, baseCreepLocation, 1);
	
	
	}
	}
*/
vector selectForwardBaseLocation(void)
{
	vector retVal = cInvalidVector;
	vector mainBaseVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	vector delta = cInvalidVector; // Scratch variable for intermediate calcs.
	vector v = cInvalidVector; // Scratch variable for intermediate calcs.
	
	//aiEcho("Selecting forward base location.");
	float distanceMultiplier = 0.0;
	float dist = 0.0;
	
	distanceMultiplier = (aiRandInt(3) + 3);
	distanceMultiplier = (distanceMultiplier * 0.1) - 0.05; // 0.25 - 0.45; used to determine how far out the fort will be placed
	
	int enemyTC = getUnitByLocation(gTownCenter, cPlayerRelationEnemy, cUnitStateABQ, mainBaseVec, 500.0);
	if (enemyTC < 0)
	{  
		retVal = kbGetMapCenter();   // Start with map center
		delta = (mainBaseVec - retVal) * 0.5;
		retVal = retVal + delta; // halfway between main base and map center
		//aiEcho("    No enemy TC found, using map center");
	}
	else  // enemy TC found
	{
		v = kbUnitGetPosition(enemyTC) - mainBaseVec;   // Vector from main base to enemy TC
		v = v * distanceMultiplier;
		retVal = mainBaseVec + v;  // retval is point between main base and chosen enemy TC
		//aiEcho("    Enemy TC ("+enemyTC+") found at "+kbUnitGetPosition(enemyTC));
		//aiEcho("    Using waypoint at "+retVal);
	}
	// Now, make sure it's on the same areagroup, back up if it isn't.
	dist = distance(mainBaseVec, retVal);
	int mainAreaGroup = kbAreaGroupGetIDByPosition(mainBaseVec);
	delta = (mainBaseVec - retVal) * 0.1;
	int step = 0;
	bool siteFound = false;
	if (dist > 0.0)
	{
		for (step = 0; < 9)
		{
			//aiEcho("    "+retVal+" is in area group "+kbAreaGroupGetIDByPosition(retVal));
			if ( getUnitByLocation(cUnitTypeFortFrontier, cPlayerRelationEnemy, cUnitStateABQ, retVal, 60.0) >= 0 )
            continue;   // DO NOT build anywhere near an enemy fort!
			if ( getUnitByLocation(gTownCenter, cPlayerRelationEnemy, cUnitStateABQ, retVal, 60.0) >= 0 )
            continue;   // Ditto enemy TCs.
			if (mainAreaGroup == kbAreaGroupGetIDByPosition(retVal)) 
			{  // DONE!
				//aiEcho("        Good location found.");
				siteFound = true;
				break;
			}
			retVal = retVal + delta;   // Move 1/10 of way back to main base, try again.
		}
	}
	if (siteFound == false)
	retVal = mainBaseVec;
	if (aiGetWorldDifficulty() < cDifficultyModerate)
	retVal = mainBaseVec;   // Easy and Sandbox will never forward build.
	//aiEcho("    New forward base location will be "+retVal);
	return(retVal);
}

extern int outpostWagonId = -1;
void outpostWangonManager()
{
	int sendOutpost = -1;
	sendOutpost = kbUnitQueryCreate("sendOutpost");
	kbUnitQuerySetPlayerID(sendOutpost, cMyID, false);
	kbUnitQuerySetUnitType(sendOutpost, cUnitTypeOutpostWagon);
	kbUnitQuerySetState(sendOutpost, cUnitStateAlive);
	kbUnitQuerySetActionType(sendOutpost,7);
	
	for (i = 0; < kbUnitQueryExecute(sendOutpost))
	{
		int outpostId = kbUnitQueryGetResult(sendOutpost, i);
		
		
		int attempt = 0;
		vector testVec = cInvalidVector;
		float spacingDistance = 25.0; // Mid- and corner-spots on a square with 'radius' spacingDistance, i.e. each side is 2 * spacingDistance.
		float exclusionRadius = spacingDistance / 2.0;
		float dx = spacingDistance;
		float dz = spacingDistance;
		static int towerSearch = -1;
		bool success = false;
		
		for (attempt = 0; < 10) // Take ten tries to place it
		{
			/*
			if(kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) == 0)
			{
				testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
			}
			
			else if(losingDigin == false)
			{
				testVec = selectForwardBaseLocation();
			}
			else
			{
				testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Start with base location
			}
			*/
			testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
			switch(aiRandInt(8)) // 0..7
			{  // Use 0.9 * on corners to "round them" a bit
				case 0:
				{  // W
					dx = -0.9 * dx;
					dz = 0.9 * dz;
					//aiEcho("West...");
					break;
				}
				case 1:
				{  // NW
					dx = 0.0;
					//aiEcho("Northwest...");
					break;
				}
				case 2:
				{  // N
					dx = 0.9 * dx;
					dz = 0.9 * dz;
					//aiEcho("North...");
					break;
				}
				case 3:
				{  // NE
					dz = 0.0;
					//aiEcho("NorthEast...");
					break;
				}
				case 4:
				{  // E
					dx = 0.9 * dx;
					dz = -0.9 * dz;
					//aiEcho("East...");
					break;
				}
				case 5:
				{  // SE
					dx = 0.0;
					dz = -1.0 * dz;
					//aiEcho("SouthEast...");
					break;
				}
				case 6:
				{  // S
					dx = -0.9 * dx;
					dz = -0.9 * dz;
					//aiEcho("South...");
					break;
				}
				case 7:
				{  // SW
					dx = -1.0 * dx;
					dz = 0;
					//aiEcho("SouthWest...");
					break;
				}
			}
			testVec = xsVectorSetX(testVec, xsVectorGetX(testVec) + dx);
			testVec = xsVectorSetZ(testVec, xsVectorGetZ(testVec) + dz);
			// aiEcho("Testing tower location "+testVec);
			if (towerSearch < 0)
			{  // init
				towerSearch = kbUnitQueryCreate("Tower placement search");
				kbUnitQuerySetPlayerRelation(towerSearch, cPlayerRelationAny);
				kbUnitQuerySetUnitType(towerSearch, gTowerUnit);
				kbUnitQuerySetState(towerSearch, cUnitStateABQ);
			}
			kbUnitQuerySetPosition(towerSearch, testVec);
			kbUnitQuerySetMaximumDistance(towerSearch, exclusionRadius);
			kbUnitQueryResetResults(towerSearch);
			if (kbUnitQueryExecute(towerSearch) < 1)
			{  // Site is clear, use it
				if ( kbAreaGroupGetIDByPosition(testVec) == kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) )
				{  // Make sure it's in same areagroup.
					success = true;
					break;
				}
			}
		}
		
		// We have found a location (success == true) or we need to just do a brute force placement around the TC.
		if (success == false) testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
		
		
		int buildPlan=aiPlanCreate("Outpost wagon "+outpostId, cPlanBuild);
		// What to build
		
		aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
		// Priority.
		aiPlanSetDesiredPriority(buildPlan, 100);
		// Econ, because mil doesn't get enough wood.
		aiPlanSetMilitary(buildPlan, false);
		aiPlanSetEconomy(buildPlan, true);
		// Escrow.
		aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
		// Builders.
		aiPlanAddUnitType(buildPlan, cUnitTypeOutpostWagon, 1, 1, 1);
		aiPlanAddUnit(buildPlan,outpostId);
		
		// Instead of base ID or areas, use a center position and falloff.
		aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, testVec);
		if (success == true)
		aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, exclusionRadius);
		else
		aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 55.0);
		
		// Add position influence for nearby towers
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);   // Russian's won't notice ally towers and vice versa...oh well.
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, spacingDistance);    
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, -20.0);        // -20 points per tower
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
		
		// Weight it to stay very close to center point.
		aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, testVec);    // Position influence for landing position
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, exclusionRadius);     // 100m range.
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 10.0);        // 10 points for center
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
		
		aiPlanSetActive(buildPlan);
		
	}	
}

rule towerManager
inactive
minInterval 10
{
   if (cvOkToFortify == false)
   {
      return;  // Oops.  I shouldn't be running.
   }
   
   static int towerUpgradePlan = -1;
   int towerUpgrade1 = cTechFrontierOutpost;
   int towerUpgrade2 = cTechFortifiedOutpost;
   if (kbGetCiv() == cCivRussians)
   {
      towerUpgrade1 = cTechFrontierBlockhouse;
      towerUpgrade2 = cTechFortifiedBlockhouse;
   }
   if (kbGetCiv() == cCivXPIroquois)
   {
      towerUpgrade1 = cTechStrongWarHut;
      towerUpgrade2 = cTechMightyWarHut;
   }
   if (kbGetCiv() == cCivXPAztec)
   {
      towerUpgrade1 = cTechStrongNoblesHut;
      towerUpgrade2 = cTechMightyNoblesHut;
   }
   if (kbGetCiv() == cCivXPSioux)
   {
      towerUpgrade1 = cTechStrongWarHut;
      towerUpgrade2 = cTechMightyWarHut;
   }
   if (civIsAsian() == true)
   {
      towerUpgrade1 = cTechypFrontierCastle;
      towerUpgrade2 = cTechypFortifiedCastle;
   }
  
   if (towerUpgradePlan >= 0)
   {
      if ((aiPlanGetState(towerUpgradePlan) < 0) || (aiPlanGetVariableInt(towerUpgradePlan, cResearchPlanBuildingID, 0) < 0))
      {
         aiPlanDestroy(towerUpgradePlan);
         towerUpgradePlan = -1;
         aiEcho("Invalid tower upgrade plan destroyed.");
      }
   }

   if ( (kbTechGetStatus(towerUpgrade1) == cTechStatusObtainable) && (towerUpgradePlan == -1) ) // The first upgrade is available, and I'm not researching it. 
   {
      if (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) >= 3)
      {  // I have at least 3 towers
         towerUpgradePlan = createSimpleResearchPlan(towerUpgrade1, -1, cMilitaryEscrowID, 75);
         aiEcho("Starting research plan for first tower upgrade in plan # "+towerUpgradePlan);
      }
   }
   
   if ( (kbTechGetStatus(towerUpgrade2) == cTechStatusObtainable) && (towerUpgradePlan == -1) ) // The second upgrade is available, and I'm not researching it. 
   {
      if (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) >= 5)
      {  // I have at least 5 towers
         towerUpgradePlan = createSimpleResearchPlan(towerUpgrade2, -1, cMilitaryEscrowID, 75);
         aiEcho("Starting research plan for second tower upgrade in plan # "+towerUpgradePlan);
      }
   }
   
   if ( (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) >= gNumTowers) && (kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateAlive) <= 0) && (kbUnitCount(cMyID, cUnitTypeYPCastleWagon, cUnitStateAlive) <= 0) )
      return;  // We have enough, thank you, and no idle outpost or castle wagons.
   
   if ( aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gTowerUnit) >= 0 )
      return;  // We're already building one.
   
   if (civIsAsian() == false) { //BHG: Asians have different outpost wagon types so it's ok to keep going
      if ( aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeOutpost) >= 0 )
         return;  // We're already building one.  (Weird case of civs that don't usually make towers having an outpost wagon given to them.
   }
   
   // Need more, not currently building any.  Need to select a builder type (settler or outpostWagon) and a location.
   int builderType = -1;
   
   if ( (civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateAlive) > 0) )
      builderType = cUnitTypeOutpostWagon;
   else if ( (civIsAsian() == true) && (kbUnitCount(cMyID, cUnitTypeYPCastleWagon, cUnitStateAlive) > 0) )
      builderType = cUnitTypeYPCastleWagon;
   else
      builderType = gEconUnit;
   
   int attempt = 0;
   vector testVec = cInvalidVector;
   float spacingDistance = 25.0; // Mid- and corner-spots on a square with 'radius' spacingDistance, i.e. each side is 2 * spacingDistance.
   float exclusionRadius = spacingDistance / 2.0;
   float dx = spacingDistance;
   float dz = spacingDistance;
   static int towerSearch = -1;
   bool success = false;
   
   for (attempt = 0; < 10) // Take ten tries to place it
   {
      testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); // Start with base location
      
      switch(aiRandInt(8)) // 0..7
      {  // Use 0.9 * on corners to "round them" a bit
         case 0:
         {  // W
            dx = -0.9 * dx;
            dz = 0.9 * dz;
            aiEcho("West...");
            break;
         }
         case 1:
         {  // NW
            dx = 0.0;
            aiEcho("Northwest...");
            break;
         }
         case 2:
         {  // N
            dx = 0.9 * dx;
            dz = 0.9 * dz;
            aiEcho("North...");
            break;
         }
         case 3:
         {  // NE
            dz = 0.0;
            aiEcho("NorthEast...");
            break;
         }
         case 4:
         {  // E
            dx = 0.9 * dx;
            dz = -0.9 * dz;
            aiEcho("East...");
            break;
         }
         case 5:
         {  // SE
            dx = 0.0;
            dz = -1.0 * dz;
            aiEcho("SouthEast...");
            break;
         }
         case 6:
         {  // S
            dx = -0.9 * dx;
            dz = -0.9 * dz;
            aiEcho("South...");
            break;
         }
         case 7:
         {  // SW
            dx = -1.0 * dx;
            dz = 0;
            aiEcho("SouthWest...");
            break;
         }
      }
      testVec = xsVectorSetX(testVec, xsVectorGetX(testVec) + dx);
      testVec = xsVectorSetZ(testVec, xsVectorGetZ(testVec) + dz);
      aiEcho("Testing tower location "+testVec);
      if (towerSearch < 0)
      {  // init
         towerSearch = kbUnitQueryCreate("Tower placement search");
         kbUnitQuerySetPlayerRelation(towerSearch, cPlayerRelationAny);
         kbUnitQuerySetUnitType(towerSearch, gTowerUnit);
         kbUnitQuerySetState(towerSearch, cUnitStateABQ);
      }
      kbUnitQuerySetPosition(towerSearch, testVec);
      kbUnitQuerySetMaximumDistance(towerSearch, exclusionRadius);
      kbUnitQueryResetResults(towerSearch);
      if (kbUnitQueryExecute(towerSearch) < 1)
      {  // Site is clear, use it
         if ( kbAreaGroupGetIDByPosition(testVec) == kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) )
         {  // Make sure it's in same areagroup.
            success = true;
            break;
         }
      }
   }
   
   // We have found a location (success == true) or we need to just do a brute force placement around the TC.
   if (success == false)
      testVec = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
   
   int buildPlan=aiPlanCreate("Tower build plan ", cPlanBuild);
   // What to build
   if ( (builderType == cUnitTypeOutpostWagon) && (civIsAsian() == false) )
      aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeOutpost);
   else
      aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTowerUnit);
   // Priority.
   aiPlanSetDesiredPriority(buildPlan, 85);
   // Econ, because mil doesn't get enough wood.
   aiPlanSetMilitary(buildPlan, false);
   aiPlanSetEconomy(buildPlan, true);
   // Escrow.
   aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
   // Builders.
   aiPlanAddUnitType(buildPlan, builderType, 1, 1, 1);

   // Instead of base ID or areas, use a center position and falloff.
   aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, testVec);
   if (success == true)
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, exclusionRadius);
   else
      aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 55.0);

   // Add position influence for nearby towers
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, gTowerUnit);   // Russian's won't notice ally towers and vice versa...oh well.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, spacingDistance);    
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, -20.0);        // -20 points per tower
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff

   // Weight it to stay very close to center point.
   aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, testVec);    // Position influence for landing position
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, exclusionRadius);     // 100m range.
   aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 10.0);        // 10 points for center
   aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff

   aiEcho("Starting building plan ("+buildPlan+") for tower at location "+testVec);
   aiEcho("Cheapest tech for tower buildings is "+ kbGetTechName(kbTechTreeGetCheapestUnitUpgrade(gTowerUnit)) );
   aiEcho("Cheapest tech ID is "+kbTechTreeGetCheapestUnitUpgrade(gTowerUnit));
   aiPlanSetActive(buildPlan);
}

//updatedOn 2019/07/25 By ageekhere    
//---------------------------       
//Builds a runaway base, turned off for now 
rule runaway
inactive
minInterval 15
{ //runaway to a new base 
	if(ourTeamSizeMain == 1)xsDisableSelf();
	
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) > 0 && baseRelocate == true) baseRelocate = false; //Turn off base Relocate
	
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1 && baseRelocate == true)
	{
		createSimpleBuildPlan(gTownCenter, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1 && baseRelocate == false)
	{ //runaway to new base
		int score = 0; //Best team player socre
		int moveTo = 0; //Where is that base
		for (x = 0; < cNumberPlayers)
		{ //loop through players
			if (kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(x) && cMyID != x)
			{ //That are on my team and not me
				if (score < aiGetScore(x))
				{ //get the highest score
					score = aiGetScore(x); //score
					moveTo = x; //move to player x
				} //end if
			} //end if
		} //end if
		newBase = moveTo; //new base is
		newBaseAi = cMyID; //the ai which is running
		baseRelocate = true; //ai is relocated
		baseRelocateEver = true; //This will stop the ai from building forwardBuildings and walls
		
		//for (i = 0; < 100)
		//{ //clear all build plans
			//		aiPlanDestroy(i);
		//}
		gMainBase = createMainBase(kbBaseGetLocation(newBase, kbBaseGetMainID(newBase))); //create a new base
		xsEnableRule("townCenterComplete"); //activate town center complete
		kbBaseSetActive(cMyID, gMainBase, true); //set base as active
		updateEscrows(); //update to save for new TC
		xsEnableRule("tcMonitor");
		
		for (v = 0; < kbUnitCount(cMyID, gEconUnit, cUnitStateABQ))
		{ //move all settlers to new base
			aiTaskUnitMove(kbUnitCount(cMyID, gEconUnit, cUnitStateAlive), (kbBaseGetLocation(newBase, kbBaseGetMainID(newBase))));
		} //end for
		xsEnableRule("runningAway");
		
		
		for (j = 1; < cNumberPlayers)
		{ //loop through players
			if (kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(j) && cMyID != j && getUnit(gTownCenter, j, cUnitStateABQ) < 1 && kbResourceGet(cResourceWood) > 200 && kbIsPlayerHuman(j) == false)
			{ //Get the team ai to send wood to the running ai
				aiTribute(j, cResourceWood, 400);
			} //end if
		} //end for
		
	} //end if
} //end runaway
//---------------------------  

//updatedOn 2019/04/29 By ageekhere    
//---------------------------  
rule runningAway
inactive
minInterval 5
{ //keep running 4 times
	runAwayCount++;
	for (v = 0; < kbUnitCount(cMyID, cUnitTypeSettler, cUnitStateAlive))
	{
		int allVills = getUnit(cUnitTypeSettler, cMyID, cUnitStateAny);
		aiTaskUnitMove(allVills, (kbBaseGetLocation(newBase, kbBaseGetMainID(newBase))));
	} // gEconUnit
	
	if (runAwayCount == 4)
	{
		xsDisableSelf();
		runAwayCount = 0;
	}
}
//---------------------------  

//updatedOn 2019/05/14 By ageekhere    
//---------------------------
rule setupFowardBuildings
active
mininterval 5
{
	if(kbVPSiteQuery(cVPAll, cPlayerRelationAny, cVPStateAny) == -1) return;
	buildListArray = xsArrayCreateVector(kbVPSiteQuery(cVPAll, cPlayerRelationAny, cVPStateAny), cInvalidVector, "listOfsites");
	for(x = 0; < kbVPSiteQuery(cVPAll, cPlayerRelationAny, cVPStateAny))
	{
		xsArraySetVector(buildListArray, x, cInvalidVector);
	}
	xsDisableSelf();
}
//300
rule forwardBuildings
active
minInterval 60
{ //create a foward base
	if (kbGetAge() < cAge4 || baseRelocateEver == true || kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) < 40) return; //wait untill age 3
	if(aiTreatyActive() == true) return;
	if(wallMidPosition == cInvalidVector) wallMidPosition = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	fowardBaseCount++;
	buildFrontLocation = kbVPSiteGetLocation(getfarthestVPSite(wallMidPosition, cVPAll, cVPStateCompleted, cPlayerRelationSelf));
	if (buildFrontLocation == cInvalidVector)
	{ //if there is no VP Sites try and build in the middle of the map 
		buildFrontLocation = kbGetMapCenter(); //set base locaton for middle
	} //end if
	else
	{ //build small base at vp site
		for (i = 0; < kbVPSiteQuery(cVPAll, cPlayerRelationEnemy, cVPStateAny))
		{ //loop through all vp sites	
			for (j = 0; < xsArrayGetSize(buildListArray))
			{ //look through all own sites
				int vpList = kbVPSiteQuery(cVPAll, cPlayerRelationEnemy, cVPStateAny);
				int siteID = xsArrayGetInt(vpList, j);
				if (kbVPSiteGetLocation(siteID) == xsArrayGetVector(buildListArray, j) && kbVPSiteGetLocation(siteID) != cInvalidVector)
				{ //reset site exclude
					xsArraySetVector(buildListArray, j, cInvalidVector);
				} // end if
			} //end for	j				
		} //end for i
		
		for (x = 0; < xsArrayGetSize(buildListArray))
		{ //loop through our sites
			if (xsArrayGetVector(buildListArray, x) == buildFrontLocation)
			{ //have already built here exclude
				buildFrontLocation = kbGetMapCenter();
				break;
			} //end if
			
		} //end for x	
		
		if (buildFrontLocation != kbGetMapCenter())
		{ //exclude location
			for (x = 0; < xsArrayGetSize(buildListArray))
			{
				if (xsArrayGetVector(buildListArray, x) == vector(0, 0, 0) || xsArrayGetVector(buildListArray, x) == cInvalidVector)
				{
					xsArraySetVector(buildListArray, x, buildFrontLocation);
					break;
				}
			}
		} //end
	} //end else
	
	int unitbuiltCount = 0;
	int unitEnemyCount = 0;
	
	if(buildFrontLocation == kbGetMapCenter())
	{
		if(getUnitByLocation(cUnitTypeBarracks, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeBarracks, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeStable, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeStable, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeArtilleryDepot, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeArtilleryDepot, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeOutpost, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeOutpost, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeBlockhouse, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeBlockhouse, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeWarHut, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeWarHut, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeypBarracksJapanese, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeypBarracksJapanese, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeypWarAcademy, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeypWarAcademy, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeYPBarracksIndian, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeYPBarracksIndian, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeCorral, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeCorral, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeypStableJapanese, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeypStableJapanese, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeypCaravanserai, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeypCaravanserai, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeypCastle, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeypCastle, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeYPOutpostAsian, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeYPOutpostAsian, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeLookout, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeLookout, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeFortFrontier, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeFortFrontier, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(getUnitByLocation(cUnitTypeTradingPost, cPlayerRelationAny, cUnitStateABQ, buildFrontLocation, 40.0) != -1) unitbuiltCount++;
		if(getUnitByLocation(cUnitTypeTradingPost, cPlayerRelationEnemy, cUnitStateAlive, buildFrontLocation, 40.0) != -1) unitEnemyCount++;
		
		if(unitEnemyCount == 0) controlCenter = true;
		if(unitEnemyCount > 0) controlCenter = false;
		if(unitbuiltCount > 2 || unitEnemyCount > 0) return;
		
	}
	if(buildFrontLocation == kbGetMapCenter())
	{ //Try and build one of each for center
		if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeOutpost) == -1 &&
		getUnitByLocation(cUnitTypeOutpost, cPlayerRelationAny, cUnitStateAlive, buildFrontLocation, 40.0) == -1) createLocationBuildPlan(cUnitTypeOutpost, 1, 100, false, cMilitaryEscrowID, buildFrontLocation, 1);
		
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPOutpostAsian) == -1) createLocationBuildPlan(cUnitTypeYPOutpostAsian, 1, 100, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCastle) == -1) createLocationBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);	
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeLookout) == -1 && civIsAsian() == true) createLocationBuildPlan(cUnitTypeLookout , 1, 100, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBarracks) == -1) createLocationBuildPlan(cUnitTypeBarracks, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut) == -1) createLocationBuildPlan(cUnitTypeWarHut, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPBarracksIndian) == -1) createLocationBuildPlan(cUnitTypeYPBarracksIndian, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBlockhouse) == -1) createLocationBuildPlan(cUnitTypeBlockhouse, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBarracksJapanese) == -1) createLocationBuildPlan(cUnitTypeypBarracksJapanese, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeStable) == -1) createLocationBuildPlan(cUnitTypeStable, 1, 98, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCorral) == -1) createLocationBuildPlan(cUnitTypeCorral, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypStableJapanese) == -1) createLocationBuildPlan(cUnitTypeypStableJapanese, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArtilleryDepot) == -1) createLocationBuildPlan(cUnitTypeArtilleryDepot, 1, 99, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypWarAcademy) == -1) createLocationBuildPlan(cUnitTypeypWarAcademy, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCaravanserai) == -1) createLocationBuildPlan(cUnitTypeypCaravanserai, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
	}
	
	int nearestPlayer = cMyID;
	int lowestDist = 9999999;
	int currentDist = 0;
	bool donotbuild = false;
	
	//float midDist = distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbGetMapCenter());
	/*	
		for (x = 0; < cNumberPlayers)
		{ //loop through players
		vector tcLocation = kbUnitGetPosition(getUnit(gTownCenter, x, cUnitStateAlive));
		currentDist = distance(tcLocation, buildFrontLocation);
		if(currentDist < lowestDist)
		{
		nearestPlayer = x;
		lowestDist = currentDist; 
		}
		}
		
		if (kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(nearestPlayer) ||nearestPlayer == cMyID)
		{ //That are on my team
		donotbuild = true;
		}
	*/
	if(buildFrontLocation != kbGetMapCenter() && donotbuild == false)
	{
		if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeOutpost) == -1) createLocationBuildPlan(cUnitTypeOutpost, 1, 100, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPOutpostAsian) == -1) createLocationBuildPlan(cUnitTypeYPOutpostAsian, 1, 100, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCastle) == -1) createLocationBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);	
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeLookout) == -1 && civIsAsian() == true) createLocationBuildPlan(cUnitTypeLookout , 1, 100, false, cMilitaryEscrowID, buildFrontLocation, 1);
		
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBarracks) == -1) createLocationBuildPlan(cUnitTypeBarracks, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut) == -1) createLocationBuildPlan(cUnitTypeWarHut, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPBarracksIndian) == -1) createLocationBuildPlan(cUnitTypeYPBarracksIndian, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBlockhouse) == -1) createLocationBuildPlan(cUnitTypeBlockhouse, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBarracksJapanese) == -1) createLocationBuildPlan(cUnitTypeypBarracksJapanese, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeStable) == -1) createLocationBuildPlan(cUnitTypeStable, 1, 98, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCorral) == -1) createLocationBuildPlan(cUnitTypeCorral, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypStableJapanese) == -1) createLocationBuildPlan(cUnitTypeypStableJapanese, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypWarAcademy) == -1) createLocationBuildPlan(cUnitTypeypWarAcademy, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);
		else if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCaravanserai) == -1) createLocationBuildPlan(cUnitTypeypCaravanserai, 1, 97, false, cMilitaryEscrowID, buildFrontLocation, 1);	
	}
	
} //end forwardBuildings
//---------------------------  

//==============================================================================
// forwardBaseManager
// updatedOn 2020/03/09 By ageekhere
//==============================================================================
/*
	Forward base manager
	
	Handles the planning, construction, defense and maintenance of a forward military base.
	
	The steps involved:
	1)  Choose a location
	2)  Defend it and send a fort wagon to build a fort.
	3)  Define it as the military base, move defend plans there, move military production there.
	4)  Undo those settings if it needs to be abandoned.
	
*/
//==============================================================================
//rule forwardBaseManager
//inactive
//group tcComplete
//minInterval 30
void forwardBaseManager()
{
	int fortWagon = getUnit(cUnitTypeFortWagon, cMyID, cUnitStateAlive);
	if ( (cvOkToBuild == false) || (cvOkToBuildForts == false) || (fortWagon == -1)) return;
	switch(gForwardBaseState)
	{
		case cForwardBaseStateNone:
		{
			// Check if we should go to state Building
			if (kbUnitCount(cMyID, cUnitTypeFortWagon, cUnitStateAlive) > 0)
			{  // Yes.
				// get the fort wagon, start a build plan, keep it defended
				gForwardBaseLocation = selectForwardBaseLocation();
				gForwardBaseBuildPlan = aiPlanCreate("Fort build plan ", cPlanBuild);
				aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeFortFrontier);
				aiPlanSetDesiredPriority(gForwardBaseBuildPlan, 87);
				// Military
				aiPlanSetMilitary(gForwardBaseBuildPlan, true);
				aiPlanSetEconomy(gForwardBaseBuildPlan, false);
				aiPlanSetEscrowID(gForwardBaseBuildPlan, cMilitaryEscrowID);
				aiPlanAddUnitType(gForwardBaseBuildPlan, cUnitTypeFortWagon, 1, 1, 1);
				
				// Instead of base ID or areas, use a center position
				aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanCenterPosition, 0, gForwardBaseLocation);
				aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanCenterPositionDistance, 0, 50.0);
				
				// Weight it to stay very close to center point.
				aiPlanSetVariableVector(gForwardBaseBuildPlan, cBuildPlanInfluencePosition, 0, gForwardBaseLocation);    // Position influence for center
				aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionDistance, 0,  50.0);     // 100m range.
				aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluencePositionValue, 0, 100.0);        // 100 points for center
				aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
				
				// Add position influence for nearby towers
				aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeFortFrontier);   // Don't build anywhere near another fort.
				aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitDistance, 0, 50.0);    
				aiPlanSetVariableFloat(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitValue, 0, -200.0);        // -20 points per fort
				aiPlanSetVariableInt(gForwardBaseBuildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffNone);  // Cliff falloff
				
				
				aiPlanSetActive(gForwardBaseBuildPlan);
				
				// Chat to my allies
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIWillBuildMilitaryBase, gForwardBaseLocation);
				
				gForwardBaseState = cForwardBaseStateBuilding;
				//aiEcho(" ");
				//aiEcho("    BUILDING FORWARD BASE, MOVING DEFEND PLANS TO COVER.");
				//aiEcho("    PLANNED LOCATION IS "+gForwardBaseLocation); 
				//aiEcho(" ");
				
				if (gDefenseReflex == false)
				endDefenseReflex();  // Causes it to move to the new location
			}
			break;
		}
		case cForwardBaseStateBuilding:
		{
			int fortUnitID = getUnitByLocation(cUnitTypeFortFrontier, cMyID, cUnitStateAlive, gForwardBaseLocation, 100.0);
			if ( fortUnitID >= 0 )
			{  // Building exists and is complete, go to state Active
				if ( kbUnitGetBaseID(fortUnitID) >= 0) 
				{  // Base has been created for it.
					gForwardBaseState = cForwardBaseStateActive;
					gForwardBaseID = kbUnitGetBaseID(fortUnitID);
					gForwardBaseLocation = kbUnitGetPosition(fortUnitID);  
					//aiEcho("Forward base location is "+gForwardBaseLocation+", Base ID is "+gForwardBaseID+", Unit ID is "+fortUnitID);
					// Tell the attack goal where to go.
					aiPlanSetBaseID(gMainAttackGoal, gForwardBaseID);
					//aiEcho(" ");
					//iEcho("    FORWARD BASE COMPLETED, GOING TO STATE ACTIVE, MOVING ATTACK GOAL.");
					//aiEcho(" ");
				}
				else
				{
					aiEcho(" ");
					//aiEcho("    FORT COMPLETE, WAITING FOR FORWARD BASE ID.");
					//aiEcho(" ");
				}
			}
			else  // Check if plan still exists. If not, go back to state 'none'.
			{
				if (aiPlanGetState(gForwardBaseBuildPlan) < 0)
				{  // It failed?
					gForwardBaseState = cForwardBaseStateNone;
					gForwardBaseLocation = cInvalidVector;
					gForwardBaseID = -1;
					gForwardBaseBuildPlan = -1;
					//aiEcho(" ");
					//aiEcho("    FORWARD BASE PLAN FAILED, RETURNING TO STATE NONE.");
					//aiEcho(" ");
				}
			}
			
			break;
		}
		case cForwardBaseStateActive:
		{  // Normal state.  If fort is destroyed and base overrun, bail.
			if ( getUnitByLocation(cUnitTypeFortFrontier, cMyID, cUnitStateAlive, gForwardBaseLocation, 50.0) < 0 )
			{
				// Fort is missing, is base still OK?  
				if ( ((gDefenseReflexBaseID == gForwardBaseID) && (gDefenseReflexPaused == true)) 
				|| ( kbBaseGetNumberUnits( cMyID, gForwardBaseID, cPlayerRelationSelf, cUnitTypeBuilding ) < 1))   // Forward base under attack and overwhelmed, or gone.
				{  // No, not OK.  Get outa Dodge.
					gForwardBaseState = cForwardBaseStateNone;
					gForwardBaseID = -1;
					gForwardBaseLocation = cInvalidVector;
					// Tell the attack goal to go back to the main base.
					aiPlanSetBaseID(gMainAttackGoal, kbBaseGetMainID(cMyID));
					endDefenseReflex();
					//aiEcho(" ");
					//aiEcho("    ABANDONING FORWARD BASE, RETREATING TO MAIN BASE.");
					//aiEcho(" ");
				}
			}
			break;
		}
	}
}

void deathMatchSetup(void)
{  // Make a bunch of changes to get a deathmatch start
	//aiEcho("RUNNING DEATHMATCH SETUP");
	// 10 houses, pronto.
	if (cMyCiv != cCivXPSioux)
	createSimpleBuildPlan(gHouseUnit, 10, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	// 1 each of the main military buildings, ASAP.
	if ( (civIsNative() == false) && (civIsAsian() == false) )
	{
		createSimpleBuildPlan(cUnitTypeBarracks, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		createSimpleBuildPlan(cUnitTypeStable, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		else if ( (cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese) ) {
			createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		else {
			createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		createSimpleBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	else
	{      
		createSimpleBuildPlan(cUnitTypeWarHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		if (cMyCiv == cCivXPAztec)
		createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		else
		createSimpleBuildPlan(cUnitTypeCorral, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	if ( (civIsNative() == false) || (cMyCiv == cCivXPIroquois) ) {
		if (civIsAsian() == false)
		createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		else
		createSimpleBuildPlan(cUnitTypeypCastle, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	if (civIsAsian() == false)
	{
		gNumTowers = 7;   // Load up on towers.
	}
	else
	{
		gNumTowers = 5;   // Load up on castles.
	}
	xsEnableRule("turtleUp");
	xsEnableRule("moreDMHouses");
}

rule moreDMHouses
inactive
minInterval 60
{  // After 60 seconds, make 10 more houses
	if (cMyCiv != cCivXPSioux)
	createSimpleBuildPlan(gHouseUnit, 10, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	// 1 each of the main military buildings, ASAP.
	if ( (civIsNative() == false) && (civIsAsian() == false) )
	{
		createSimpleBuildPlan(cUnitTypeBarracks, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		createSimpleBuildPlan(cUnitTypeStable, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);   
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		else if ( (cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese) ) {
			createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		else {
			createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		createSimpleBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	else
	{      
		createSimpleBuildPlan(cUnitTypeWarHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		if (cMyCiv == cCivXPAztec)
		createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		else
		createSimpleBuildPlan(cUnitTypeCorral, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	if ( (civIsNative() == false) || (cMyCiv == cCivXPIroquois) ) {
		if (civIsAsian() == false)
		createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		else
		createSimpleBuildPlan(cUnitTypeypCastle, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	
	xsEnableRule("finalDMHouses");
}

rule finalDMHouses
inactive
minInterval 100
{
	int count = kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive);
	int max = kbGetBuildLimit(cMyID, gHouseUnit);
	
	count = max - count; // Count is number needed.
	if ( aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit) >= 0 )
	count = count - 1;
	if (cMyCiv == cCivXPSioux)
	count = 0;
	
	if (count > 0)
	createSimpleBuildPlan(gHouseUnit, count, 99, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	// 1 each of the main military buildings, ASAP.
	if ( (civIsNative() == false) && (civIsAsian() == false) )
	{
		createSimpleBuildPlan(cUnitTypeBarracks, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		createSimpleBuildPlan(cUnitTypeStable, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);   
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy)) {
			createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		else if ( (cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese) ) {
			createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		else {
			createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		createSimpleBuildPlan(cUnitTypeypCastle, 1, 97, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	else
	{      
		createSimpleBuildPlan(cUnitTypeWarHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		if (cMyCiv == cCivXPAztec)
		createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		else
		createSimpleBuildPlan(cUnitTypeCorral, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	if ( (civIsNative() == false) || (cMyCiv == cCivXPIroquois) ) {
		if (civIsAsian() == false)
		createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		else
		createSimpleBuildPlan(cUnitTypeypCastle, 1, 96, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	
	xsDisableSelf();
}


rule updateAttackGoal
active
minInterval 300
{
	newAttackGoal = -1;
	
}
//==============================================================================
/*
	Military Manager
	
	Create maintain plans for military unit lines.  Control 'maintain' levels,
	buy upgrades.  
*/
//==============================================================================
float armyRatio(int value = 0)
{
	if(value < 20)
	{
		return(0.13);
	}
	else if(value < 25)
	{
		return(0.16);
	}
	else if(value < 30)
	{
		return(0.19);
	}
	else if(value < 35)
	{
		return(0.22);
	}
	else if(value < 40)
	{
		return(0.25);
	}
	else if(value < 45)
	{
		return(0.28);
	}
	else if(value < 50)
	{
		return(0.31);
	}
	else if(value < 55)
	{
		return(0.34);
	}
	else if(value < 60)
	{
		return(0.37);
	}
	else
	{
		return(0.4);
	}
	return(0.0);
}
//==============================================================================
// getWarriorNatMerc
/*
	Returns The highest costing cUnitTypeAbstractNativeWarrior or cUnitTypeMercenary that is Available
*/
//==============================================================================
int getWarriorNatMerc(int unitType = -1) //cUnitTypeAbstractNativeWarrior; cUnitTypeMercenary;
{
	static bool arraySortDone = false; //is sorting down
	static int numDifferentTypes = 200; //Number of different unit types
	static int nativeWarriorArray = -1; //Native Warrior Array
	static int mercenaryArray = -1; //Mercenary Array
	static int unitCount = 0;
	static int addedUnit = 0;
	static int unitToTrain = -1;
	int minval = -1;
	int temp = -1;	
	if(nativeWarriorArray == -1) nativeWarriorArray = xsArrayCreateInt(numDifferentTypes, -1, "Native Warrior Array"); //create a new Native Warrior Array
	if(mercenaryArray == -1) mercenaryArray = xsArrayCreateInt(numDifferentTypes, -1, "Mercenary Array"); //create a new Mercenary Array
	int arrayTarget = -1; //array type (nativeWarriorArray or mercenaryArray)
	int unitTypeID = -1; //unit ID cUnitTypeAbstractNativeWarrior or cUnitTypeMercenary
	
	if(arraySortDone == false)
	{ //Find all units of type and sort based on cost	
		arraySortDone = true;
		for(k = 0; < 2)
		{
			if(k == 0) 
			{
				arrayTarget = nativeWarriorArray;
				unitTypeID = cUnitTypeAbstractNativeWarrior;
			}
			if(k == 1) 
			{
				arrayTarget = mercenaryArray;
				unitTypeID = cUnitTypeMercenary;
			}		
			unitCount = 0;
			addedUnit = 0;
			while(true) 
			{
				if( kbProtoUnitIsType(cMyID, unitCount ,unitTypeID )  == true) 
				{
					xsArraySetInt(arrayTarget, addedUnit, unitCount);
					addedUnit++;
				}
				if (unitCount > 2000) break;
				unitCount++;
			}
			minval = xsArrayGetInt(arrayTarget, 0);
			temp = 0;		
			for(i = 0; < addedUnit)
			{ //sort based on cost
				for(j = 0; < (addedUnit -1))
				{
					if( kbUnitGetCurrentAICost(xsArrayGetInt(arrayTarget, (j+1) )) > kbUnitGetCurrentAICost(xsArrayGetInt(arrayTarget, j)))
					{
						temp = xsArrayGetInt(arrayTarget, (j+1)); //temp=input[j+1];
						xsArraySetInt(arrayTarget, (j+1),xsArrayGetInt(arrayTarget, j)); ////input[j+1]=input[j];
						xsArraySetInt(arrayTarget, j, temp); // input[j]=temp; 
					}
				}
			}
		}
	}
	unitToTrain = -1;
	if(unitType == cUnitTypeAbstractNativeWarrior) 
	{
		arrayTarget = nativeWarriorArray;
	}
	if(unitType == cUnitTypeMercenary) 
	{
		arrayTarget = mercenaryArray;
	}
	
	for(i = 0; < numDifferentTypes)
	{
		if(xsArrayGetInt(arrayTarget, i) == -1)break;
		if (kbProtoUnitAvailable(xsArrayGetInt(arrayTarget, i)) == true )
		{
			if(kbGetBuildLimit(cMyID,xsArrayGetInt(arrayTarget, i)) == -1)
			{
				unitToTrain = xsArrayGetInt(arrayTarget, i);
			}
			else if(kbUnitCount(cMyID, xsArrayGetInt(arrayTarget, i), cUnitStateAlive) < kbGetBuildLimit(cMyID,xsArrayGetInt(arrayTarget, i)))
			{
				unitToTrain = xsArrayGetInt(arrayTarget, i);
			}
			else continue;
		}
	}	
	return (unitToTrain);
}

void armyTrain()
{
	if(aiTreatyActive() == true)return;
	int mainCav = -1;
	int mainCavlow = -1;
	int antiCav = -1;
	int mainArt = -1;
	int mainArtlow = -1;
	int mainArtAnti = -1;
	int mainINF = -1;
	int mainINFlow = -1;
	int antiHI = -1;
	int antiHIlow = -1;
	int antiLI = -1;
	int antiLIlow = -1;
	int antiLC = -1;
	int antiLClow = -1;
	int antiCAVINF = -1;
	int antiCAVlow = -1;
	int baseCavAnti = -1;
	int mainNativeWarrior = -1;
	int mainMercenary = -1;
	
	static int mainCavPlan = -1;
	static int mainCavlowPlan = -1;
	static int antiCavPlan = -1;
	static int mainArtPlan = -1;
	static int mainArtlowPlan = -1;
	static int mainArtAntiPlan = -1;
	static int mainINFPlan = -1;
	static int mainINFlowPlan = -1;
	static int antiHIPlan = -1;
	static int antiHILowPlan = -1;
	static int antiLIPlan = -1;
	static int antiLIlowPlan = -1;
	static int antiLCPlan = -1;
	static int antiLClowPlan = -1;
	static int antiCAVINFPlan = -1;
	static int antiCAVlowPlan = -1;
	static int baseCavAntiPlan = -1;
	static int mainNativeWarriorPlan = -1;
	static int mainMercenaryPlan = -1;
	
	if ( mainCavPlan != -1 ) aiPlanDestroy(mainCavPlan);
	if ( mainCavlowPlan != -1 ) aiPlanDestroy(mainCavlowPlan);
	if ( antiCavPlan != -1 ) aiPlanDestroy(antiCavPlan);
	if ( mainArtPlan != -1 ) aiPlanDestroy(mainArtPlan);
	if ( mainArtlowPlan != -1 ) aiPlanDestroy(mainArtlowPlan);
	if ( mainArtAntiPlan != -1 ) aiPlanDestroy(mainArtAntiPlan);
	if ( mainINFPlan != -1 ) aiPlanDestroy(mainINFPlan);
	if ( mainINFlowPlan != -1 ) aiPlanDestroy(mainINFlowPlan);
	if ( antiHIPlan != -1 ) aiPlanDestroy(antiHIPlan);
	if ( antiHILowPlan != -1 ) aiPlanDestroy(antiHILowPlan);
	if ( antiLIPlan != -1 ) aiPlanDestroy(antiLIPlan);
	if ( antiLIlowPlan != -1 ) aiPlanDestroy(antiLIlowPlan);
	if ( antiLCPlan != -1 ) aiPlanDestroy(antiLCPlan);
	if ( antiLClowPlan != -1 ) aiPlanDestroy(antiLClowPlan);
	if ( antiCAVINFPlan != -1 ) aiPlanDestroy(antiCAVINFPlan);
	if ( antiCAVlowPlan != -1 ) aiPlanDestroy(antiCAVlowPlan);
	if ( baseCavAntiPlan != -1 ) aiPlanDestroy(baseCavAntiPlan);
	if ( mainNativeWarriorPlan != -1 ) aiPlanDestroy(mainNativeWarriorPlan);
	if ( mainMercenaryPlan != -1 ) aiPlanDestroy(mainMercenaryPlan);
	
	
	float mainCavValue = 0.0;
	float mainCavlowValue = 0.0;
	float antiCavValue = 0.0;
	float mainArtValue = 0.0;
	float mainArtlowValue = 0.0;
	float mainArtAntiValue = 0.0;
	float mainINFValue = 0.0;
	float mainINFlowValue = 0.0;
	float antiHIValue = 0.0;
	float antiHILowValue = 0.0;
	float antiLIValue = 0.0;
	float antiLIlowValue = 0.0;
	float antiLCValue = 0.0;
	float antiLClowValue = 0.0;
	float antiCAVINFValue = 0.0;
	float antiCAVlowValue = 0.0;
	float baseCavAntiValue = 0.0;
	float mainNativeWarriorValue = 0.0;
	float mainMercenaryValue = 0.0;
	
	switch (kbGetCiv())
	{
		case cCivFrench:
		{
			mainCav = cUnitTypeHussar;
			mainCavlow = cUnitTypeHussar;
			antiCav = cUnitTypeDragoon;		
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;	
			mainINF = cUnitTypeMusketeer;
			mainINFlow = cUnitTypeMusketeer;
			antiHI = cUnitTypeSkirmisher;
			antiHIlow = cUnitTypeCrossbowman;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeMusketeer;
			antiLC = cUnitTypeSkirmisher;
			antiLClow = cUnitTypeCrossbowman;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeMusketeer;
			baseCavAnti = cUnitTypePikeman;
			
			if(kbGetAge() > cAge3)
			{
				antiHIlow = cUnitTypeSkirmisher;
				antiLClow = cUnitTypeSkirmisher;
				mainCav = cUnitTypeCuirassier;
				mainINF = cUnitTypeMusketeer;
			}
			
			break;
		}
		case cCivJapanese:
		{
			mainCav = cUnitTypeypNaginataRider;
			mainCavlow = cUnitTypeypNaginataRider;
			antiCav = cUnitTypeypYabusame;		
			mainArt = cUnitTypeypFlamingArrow;	
			mainArtlow = cUnitTypeypFlamingArrow;
			mainArtAnti = cUnitTypeypFlamingArrow;	
			mainINF = cUnitTypeypAshigaru;
			mainINFlow = cUnitTypeypAshigaru;
			antiHI = cUnitTypeypYumi;
			antiHIlow = cUnitTypeypYumi;
			antiLI = cUnitTypeSohei;
			antiLIlow = cUnitTypeSohei;
			antiLC = cUnitTypeypKensei;
			antiLClow =cUnitTypeypKensei;
			antiCAVINF = cUnitTypeypKensei;
			antiCAVlow = cUnitTypeypKensei;
			baseCavAnti = cUnitTypeypKensei;
			break;
		}
		case cCivSpanish:
		{
			mainCav = cUnitTypeLancer;
			mainCavlow = cUnitTypeHussar;
			antiCav = cUnitTypeDragoon;		
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;
			mainINF = cUnitTypeRodelero;
			mainINFlow = cUnitTypeMusketeer;
			antiHI = cUnitTypeSkirmisher;
			antiHIlow = cUnitTypeCrossbowman;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeMusketeer;
			antiLC = cUnitTypeSkirmisher;
			antiLClow = cUnitTypeCrossbowman;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeMusketeer;
			baseCavAnti = cUnitTypePikeman;
			
			if(kbGetAge() > cAge3)
			{
				antiHIlow = cUnitTypeSkirmisher;
				antiLClow = cUnitTypeSkirmisher;
			}
			if(kbGetAge() < cAge3)
			{
				mainINF = cUnitTypeMusketeer;
			}
			
			break;
		}
		case cCivBritish:
		{
			mainCav = cUnitTypeHussar;
			mainCavlow = cUnitTypeHussar;
			antiCav = cUnitTypeDragoon;		
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;		
			mainINF = cUnitTypeHalberdier;
			mainINFlow = cUnitTypeMusketeer;
			antiHI = cUnitTypeGrenadier;
			antiHIlow = cUnitTypeLongbowman;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeMusketeer;
			antiLC = cUnitTypeLongbowman;
			antiLClow = cUnitTypeLongbowman;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeMusketeer;
			baseCavAnti = cUnitTypePikeman;
			
			if(kbGetAge() < cAge3)
			{
				mainINF = cUnitTypeMusketeer;
			}
			break;
		}
		
		case cCivPortuguese:
		{
			mainCav = cUnitTypeCavalaria;
			mainCavlow = cUnitTypeCavalaria;
			antiCav = cUnitTypeDragoon;		
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeOrganGun;
			mainArtAnti = cUnitTypeCulverin;		
			mainINF = cUnitTypeHalberdier;
			mainINFlow = cUnitTypeMusketeer;
			antiHI = cUnitTypeCacadore;
			antiHIlow = cUnitTypeCrossbowman;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeMusketeer;
			antiLC = cUnitTypeCacadore;
			antiLClow = cUnitTypeCrossbowman;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeMusketeer;
			baseCavAnti = cUnitTypePikeman;
			
			if(kbGetAge() > cAge3)
			{
				antiHIlow = cUnitTypeCacadore;
				antiLClow = cUnitTypeCacadore;
			}
			if(kbGetAge() < cAge3)
			{
				mainINF = cUnitTypeMusketeer;
			}
			break;
		}
		case cCivDutch:
		{	
			mainCav = cUnitTypeHussar;
			mainCavlow = cUnitTypeHussar;
			antiCav = cUnitTypeRuyter;		
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;		
			mainINF = cUnitTypeHalberdier;
			mainINFlow = cUnitTypeSchutze;
			antiHI = cUnitTypeGrenadier;
			antiHIlow = cUnitTypeSkirmisher;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeSchutze;
			antiLC = cUnitTypeSkirmisher;
			antiLClow = cUnitTypeSkirmisher;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeSchutze;
			baseCavAnti = cUnitTypePikeman;
			
			if(kbGetAge() < cAge3)
			{
				mainINF = cUnitTypeMusketeer;
			}
			break;
		}
		case cCivRussians:
		{
			mainCav = cUnitTypeOprichnik;
			mainCavlow = cUnitTypeCossack;
			antiCav = cUnitTypeCavalryArcher;		
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;
			mainINF = cUnitTypeHalberdier;
			mainINFlow = cUnitTypeMusketeer;
			antiHI = cUnitTypeGrenadier;
			antiHIlow = cUnitTypeStrelet;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeMusketeer;
			antiLC = cUnitTypeMusketeer;
			antiLClow = cUnitTypeStrelet;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeMusketeer;
			baseCavAnti = cUnitTypePikeman;
			if(kbGetAge() < cAge3)
			{
				mainINF = cUnitTypeMusketeer;
			}
			break;
		}
		case cCivGermans:
		{	
			mainCav = cUnitTypeWarWagon;
			mainCavlow = cUnitTypeUhlan;
			antiCav = cUnitTypeWarWagon;		
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;		
			mainINF = cUnitTypeDopplesoldner;
			mainINFlow = cUnitTypeDopplesoldner;
			antiHI = cUnitTypeSkirmisher;
			antiHIlow = cUnitTypeCrossbowman;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeDopplesoldner;
			antiLC = cUnitTypeSkirmisher;
			antiLClow = cUnitTypeCrossbowman;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeDopplesoldner;
			baseCavAnti = cUnitTypePikeman;
			
			if(kbGetAge() > cAge3)
			{
				antiHIlow = cUnitTypeSkirmisher;
				antiLClow = cUnitTypeSkirmisher;
			}
			break;
		}
		
		case cCivOttomans:
		{
			mainCav = cUnitTypeSpahi;
			mainCavlow = cUnitTypeHussar;
			antiCav = cUnitTypeCavalryArcher;		
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;			
			mainINF = cUnitTypeAzap;
			mainINFlow = cUnitTypeJanissary;
			antiHI = cUnitTypeAbusGun;
			antiHIlow = cUnitTypeJanissary;
			antiLI = cUnitTypeGrenadier;
			antiLIlow = cUnitTypeJanissary;
			antiLC = cUnitTypeAbusGun;
			antiLClow = cUnitTypeJanissary;
			antiCAVINF = cUnitTypeJanissary;
			antiCAVlow = cUnitTypeGrenadier;
			baseCavAnti = cUnitTypeJanissary;		
			break;
		}
		case cCivXPIroquois:
		{
			mainCav = cUnitTypexpHorseman;
			mainCavlow = cUnitTypexpHorseman;
			antiCav = cUnitTypexpMusketRider;	
			mainArt = cUnitTypexpLightCannon;
			mainArtlow = cUnitTypexpLightCannon;
			mainArtAnti = cUnitTypexpLightCannon;		
			mainINF = cUnitTypexpAenna;
			mainINFlow = cUnitTypexpMantlet;
			antiHI = cUnitTypexpMusketWarrior;
			antiHIlow = cUnitTypexpMantlet;
			antiLI = cUnitTypexpTomahawk;
			antiLIlow = cUnitTypexpMantlet;
			antiLC = cUnitTypexpMusketWarrior;
			antiLClow = cUnitTypexpMantlet;
			antiCAVINF = cUnitTypexpTomahawk;
			antiCAVlow = cUnitTypexpMantlet;
			baseCavAnti = cUnitTypexpTomahawk;
			break;
		}
		case cCivXPSioux:
		{	
			mainCav = cUnitTypexpAxeRider;
			mainCavlow = cUnitTypexpBowRider;
			antiCav = cUnitTypexpRifleRider;		
			mainArt = cUnitTypexpCoupRider;
			mainArtlow = cUnitTypexpCoupRider;
			mainArtAnti = cUnitTypexpAxeRider;	
			mainINF = cUnitTypexpWarClub;
			mainINFlow = cUnitTypexpWarRifle;
			antiHI = cUnitTypexpWarRifle;
			antiHIlow = cUnitTypexpWarBow;
			antiLI = cUnitTypexpWarClub;
			antiLIlow = cUnitTypexpWarRifle;
			antiLC = cUnitTypexpWarRifle;
			antiLClow = cUnitTypexpWarBow;
			antiCAVINF = cUnitTypexpWarClub;
			antiCAVlow = cUnitTypexpWarRifle;
			baseCavAnti = cUnitTypexpWarClub;
			
			if(kbGetAge() < cAge3)
			{
				antiCav = cUnitTypexpBowRider;
				mainINFlow = cUnitTypexpWarBow;
				antiHI = cUnitTypexpWarRifle;
				antiLIlow = cUnitTypexpWarBow;
				antiLC = cUnitTypexpWarClub;
				antiCAVlow = cUnitTypexpWarClub;
			}
			
			break;
		}
		case cCivXPAztec:
		{
			mainCav = cUnitTypeNatHuaminca;
			mainCavlow = cTechEliteCoyotemen;
			antiCav = cUnitTypexpEagleKnight;			
			mainArt = cUnitTypexpCoupRider;
			mainArtlow = cUnitTypexpCoupRider;
			mainArtAnti = cUnitTypexpArrowKnight;			
			mainINF = cUnitTypexpPumaMan;
			mainINFlow = cUnitTypexpJaguarKnight;
			antiHI = cUnitTypexpJaguarKnight;
			antiHIlow = cUnitTypexpMacehualtin;
			antiLI = cTechEliteCoyotemen;
			antiLIlow = cUnitTypexpJaguarKnight;
			antiLC = cUnitTypexpJaguarKnight;
			antiLClow = cUnitTypexpMacehualtin;
			antiCAVINF = cTechEliteCoyotemen;
			antiCAVlow = cUnitTypexpJaguarKnight;
			baseCavAnti = cTechEliteCoyotemen;
			if(kbGetAge() > cAge3)
			{
				mainINF = cUnitTypexpJaguarKnight;
			}
			break;
		}
		
		case cCivUSA:
		{
			mainCav = cUnitTypeSaber;
			mainCavlow = cUnitTypeSaber;
			antiCav = cUnitTypeMountedRifleman;	
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;	
			mainINF = cUnitTypeUSColonialMarines;
			mainINFlow = cUnitTypeUSColonialMarines;
			antiHI = cUnitTypeUSColonialMilitia;
			antiHIlow = cUnitTypeGrenadier; 
			antiLI = cUnitTypeUSGatlingGuns; 
			antiLIlow = cUnitTypeUSColonialMarines;
			antiLC = cUnitTypeUSRiflemenRegiment;
			antiLClow = cUnitTypeUSColonialMarines;
			antiCAVINF = cUnitTypeUSColonialMarines;
			antiCAVlow = cUnitTypeUSColonialMarines;
			baseCavAnti = cUnitTypeUSColonialMarines;
			
			if(kbGetAge() > cAge3)
			{
				antiHI = cUnitTypeGrenadier;
			}
			break;
		}
		case cCivSwedish:
		{
			mainCav = cUnitTypePistolS;
			mainCavlow = cUnitTypeHussar;
			antiCav = cUnitTypeDragoon;	
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;		
			mainINF = cUnitTypeHandgonne;
			mainINFlow = cUnitTypeMusketeer;
			antiHI = cUnitTypeSharpshooter;
			antiHIlow = cUnitTypeMusketeer;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeMusketeer;
			antiLC = cUnitTypeSharpshooter;
			antiLClow = cUnitTypeMusketeer;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeMusketeer;
			baseCavAnti = cUnitTypePikeman;
			
			if(kbGetAge() > cAge3)
			{
				antiHIlow = cUnitTypeSharpshooter;
				antiLClow = cUnitTypeSharpshooter;
			}
			if(kbGetAge() < cAge3)
			{
				mainINF = cUnitTypeMusketeer;
			}
			break;
		}
		case cCivItalians:
		{
			mainCav = cUnitTypeHussar;
			mainCavlow = cUnitTypeHussar;
			antiCav = cUnitTypeMountedCrossbowman;
			mainArt = cUnitTypexpHorseArtillery;
			mainArtlow = cUnitTypeFalconet;
			mainArtAnti = cUnitTypeCulverin;	
			mainINF = cUnitTypeMusketeer;
			mainINFlow = cUnitTypeMusketeer;
			antiHI = cUnitTypeSaker;
			antiHIlow = cUnitTypeFlatbowman;
			antiLI = cUnitTypePikeman;
			antiLIlow = cUnitTypeMusketeer;
			antiLC = cUnitTypeSkirmisher;
			antiLClow = cUnitTypeFlatbowman;
			antiCAVINF = cUnitTypePikeman;
			antiCAVlow = cUnitTypeMusketeer;
			baseCavAnti = cUnitTypePikeman;
			break;
		}
		case cCivIndians:
		{
			mainCav = cUnitTypeypSowarMansabdar;
			mainCavlow = cUnitTypeypSowarMansabdar;
			antiCav = cUnitTypeypZamburak;	
			mainArt = cUnitTypeypMercFlailiphantMansabdar;
			mainArtlow = cUnitTypeypMercFlailiphantMansabdar;
			mainArtAnti = cUnitTypeypSiegeElephantMansabdar;
			mainINF = cUnitTypeypUrumi;
			mainINFlow = cUnitTypeypIGCSepoy;
			antiHI = cUnitTypeypNatMercGurkha;
			antiHIlow = cUnitTypeypIGCSepoy;
			antiLI = cUnitTypeypMahoutMansabdar;
			antiLIlow = cUnitTypeypMahoutMansabdar;
			antiLC = cUnitTypeypNatMercGurkha;
			antiLClow = cUnitTypeypIGCSepoy;
			antiCAVINF = cUnitTypeypHowdahMansabdar;
			antiCAVlow = cUnitTypeypHowdahMansabdar;
			baseCavAnti = cUnitTypeypRajput;
			break;
		}
		case cCivChinese:
		{
			mainCav = cUnitTypeypForbiddenArmy;
			mainCavlow = cUnitTypeypBlackFlagArmy;
			antiCav = cUnitTypeypMongolianArmy;			
			mainArt = cUnitTypeypFlameThrower;
			mainArtlow = cUnitTypeypFlameThrower;
			mainArtAnti = cUnitTypeypHandMortar;	
			mainINF = cUnitTypeypTerritorialArmy;
			mainINFlow = cUnitTypeypStandardArmySpawn;
			antiHI = cUnitTypeypImperialArmy;
			antiHIlow = cUnitTypeypOldHanArmy;
			antiLI = cUnitTypeypMingArmy;
			antiLIlow = cUnitTypeypStandardArmySpawn;
			antiLC = cUnitTypeypImperialArmy;
			antiLClow = cUnitTypeypOldHanArmy;
			antiCAVINF = cUnitTypeypMingArmy;
			antiCAVlow = cUnitTypeypStandardArmySpawn;
			baseCavAnti = cUnitTypeypMingArmy;	
			
			if(kbGetAge() > cAge3)
			{
				mainINFlow = cUnitTypeypTerritorialArmy;
				antiHIlow = cUnitTypeypTerritorialArmy;
				antiLI = cUnitTypeypImperialArmy;
				antiLIlow = cUnitTypeypTerritorialArmy;
				antiLClow =cUnitTypeypTerritorialArmy;
				antiCAVINF = cUnitTypeypImperialArmy;
				antiCAVlow = cUnitTypeypTerritorialArmy;
				
			}
			break;
		}
		
	}
	
	mainNativeWarrior = getWarriorNatMerc(cUnitTypeAbstractNativeWarrior); 
	mainMercenary = getWarriorNatMerc(cUnitTypeMercenary);
	
	int heavyInfantryCountEnemy = -1;
	int lightInfantryCountEnemy = -1;
	int lightCavalryCountEnemy = -1;
	int heavyCavalryCountEnemy = -1;
	int artilleryCountEnemy = -1;
	int totalEnemyCount = -1;
	int totalEnemyInfantryCount = -1;
	int totalCavEnemy = -1;
	int totalEnemyInfantry = -1;
	int enemyToCounter = -1;
	for (x = 1; < cNumberPlayers)
	{ //loop through players
		if (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(x) && (x != cMyID) && kbHasPlayerLost(x) == false)
		{ //that are not on my team and is not me and are not dead
			enemyToCounter = x;
			heavyInfantryCountEnemy = heavyInfantryCountEnemy + kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive);
			lightInfantryCountEnemy = lightInfantryCountEnemy + kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive) - heavyInfantryCountEnemy;
			lightCavalryCountEnemy = lightCavalryCountEnemy + kbUnitCount(enemyToCounter, cUnitTypeAbstractLightCavalry, cUnitStateAlive) + kbUnitCount(enemyToCounter, cUnitTypexpEagleKnight, cUnitStateAlive); // Aztec eagle knights count as light cavalry
			heavyCavalryCountEnemy = heavyCavalryCountEnemy + kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) + kbUnitCount(enemyToCounter, cUnitTypexpCoyoteMan, cUnitStateAlive); // Aztec coyote runners count as heavy cavalry
			artilleryCountEnemy = artilleryCountEnemy + kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive);
			totalEnemyCount = totalEnemyCount + lightInfantryCountEnemy + heavyInfantryCountEnemy + lightCavalryCountEnemy + heavyCavalryCountEnemy + artilleryCountEnemy;
			totalEnemyInfantryCount = totalEnemyInfantryCount + lightInfantryCountEnemy + heavyInfantryCountEnemy;
			totalCavEnemy = totalCavEnemy + lightCavalryCountEnemy + heavyCavalryCountEnemy;
			totalEnemyInfantry = totalEnemyInfantry + heavyInfantryCountEnemy+lightInfantryCountEnemy;
		}
	}
	int ratio = 1.0;
	int diff = 0;
	int unitCount = 0;
	float scoreLeft = 1.0;
	//cav
	int enemyCavBase = kbUnitQueryCreate("enemyCavBase");
	kbUnitQuerySetPlayerRelation(enemyCavBase, cPlayerRelationEnemyNotGaia);
	kbUnitQuerySetUnitType(enemyCavBase, cUnitTypeAbstractCavalry);
	kbUnitQuerySetPosition(enemyCavBase, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetMaximumDistance(enemyCavBase, 30.0);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyCavBase, true);
	kbUnitQuerySetState(enemyCavBase, cUnitStateAlive);
	
	if(kbUnitQueryExecute(enemyCavBase) > 15)
	{ //defend the base with anti cav
		if(kbProtoUnitAvailable(baseCavAnti) == true  && scoreLeft > 0)
		{
			baseCavAntiValue = 1.0;
			scoreLeft = 0.0;
		}	
	}
	
	unitCount = kbUnitCount(cMyID, antiHI, cUnitStateABQ) + kbUnitCount(cMyID, antiHIlow, cUnitStateABQ);
	if(heavyInfantryCountEnemy > unitCount && kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) != 0 )
	{ //counter HI
		
		diff = heavyInfantryCountEnemy - unitCount;
		if(diff < 15 )
		{// use low couter
			if(kbProtoUnitAvailable(antiHIlow) == true  && scoreLeft > 0.0) antiHILowValue = armyRatio(diff);
			
			
			if(antiHILowValue > scoreLeft) antiHILowValue = scoreLeft;
			scoreLeft = scoreLeft - antiHILowValue;
		}
		
		else
		{
			if(kbProtoUnitAvailable(antiHI) == true  && scoreLeft > 0) antiHIValue = armyRatio(diff);	
			if(antiHIValue > scoreLeft) antiHIValue = scoreLeft;
			scoreLeft = scoreLeft - antiHIValue;
		}	
		
	}
	
	unitCount = kbUnitCount(cMyID, antiCav, cUnitStateABQ);
	if(totalCavEnemy > unitCount && kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) != 0)
	{
		diff = totalCavEnemy - unitCount;
		if(kbProtoUnitAvailable(antiCav) == true  && scoreLeft > 0) antiCavValue = armyRatio(diff);
		if(antiCavValue > scoreLeft) antiCavValue = scoreLeft;
		scoreLeft = scoreLeft - antiCavValue;
	}
	
	unitCount = kbUnitCount(cMyID, mainCavlow, cUnitStateABQ);
	if(artilleryCountEnemy > unitCount && kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) != 0)
	{
		diff = artilleryCountEnemy - unitCount;
		if(kbProtoUnitAvailable(mainCavlow) == true  && scoreLeft > 0)  mainCavlowValue = armyRatio(diff);
		if(mainCavlowValue > scoreLeft) mainCavlowValue = scoreLeft;
		scoreLeft = scoreLeft - mainCavlowValue;
	}
	
	
	unitCount = kbUnitCount(cMyID, antiLI, cUnitStateABQ) + kbUnitCount(cMyID, antiLIlow, cUnitStateABQ);
	if(lightInfantryCountEnemy > unitCount && kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) != 0)
	{
		diff = heavyInfantryCountEnemy - unitCount;
		if(diff < 15 )
		{
			if(kbProtoUnitAvailable(antiLIlow) == true  && scoreLeft > 0) antiLIlowValue = armyRatio(diff);
			if(antiLIlowValue > scoreLeft) antiLIlowValue = scoreLeft;
			scoreLeft = scoreLeft - antiLIlowValue;
		}
		else
		{
			if(kbProtoUnitAvailable(antiLI) == true  && scoreLeft > 0) antiLIValue = armyRatio(diff);	
			if(antiLIValue > scoreLeft) antiLIValue = scoreLeft;
			scoreLeft = scoreLeft - antiLIValue;
		}
		
	}
	
	unitCount = kbUnitCount(cMyID, antiCAVINF, cUnitStateABQ) + kbUnitCount(cMyID, antiCAVlow, cUnitStateABQ);
	if(heavyCavalryCountEnemy > unitCount && kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) != 0)
	{
		diff = heavyCavalryCountEnemy - unitCount;
		if(diff < 15 )
		{
			if(kbProtoUnitAvailable(antiCAVlow) == true  && scoreLeft > 0) antiCAVlowValue = armyRatio(diff);
			if(antiCAVlowValue > scoreLeft) antiCAVlowValue = scoreLeft;
			scoreLeft = scoreLeft - antiCAVlowValue;
		}
		else
		{
			if(kbProtoUnitAvailable(antiCAVINF) == true  && scoreLeft > 0) antiCAVINFValue = armyRatio(diff);
			if(antiCAVINFValue > scoreLeft) antiCAVINFValue = scoreLeft;
			scoreLeft = scoreLeft - antiCAVINFValue;
		}
	}
	
	unitCount = kbUnitCount(cMyID, antiLC, cUnitStateABQ) + kbUnitCount(cMyID, antiLClow, cUnitStateABQ);
	if(lightCavalryCountEnemy > unitCount && kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) != 0)
	{
		diff = heavyCavalryCountEnemy - unitCount;
		if(diff < 15 )
		{
			if(kbProtoUnitAvailable(antiLClow) == true  && scoreLeft > 0) antiLClowValue = armyRatio(diff);
			if(antiLClowValue > scoreLeft) antiLClowValue = scoreLeft;
			scoreLeft = scoreLeft - antiLClowValue;
		}
		else
		{
			if(kbProtoUnitAvailable(antiLC) == true  && scoreLeft > 0) antiLCValue = armyRatio(diff);
			if(antiLCValue > scoreLeft) antiLCValue = scoreLeft;
			scoreLeft = scoreLeft - antiLCValue; 
		}
	}
	
	unitCount = kbUnitCount(cMyID, mainArt, cUnitStateABQ);
	unitCount = unitCount * 3;
	if(totalEnemyInfantry > unitCount && kbUnitCount(cMyID, gArtilleryDepotUnit, cUnitStateAlive) != 0)
	{
		diff = totalEnemyInfantry - unitCount;
		//diff = diff / 2;
		if(kbProtoUnitAvailable(mainArt) == true  && scoreLeft > 0)
		{
			mainArtValue = armyRatio(diff);	
			if(mainArtValue > scoreLeft) mainArtValue = scoreLeft;
			scoreLeft = scoreLeft - mainArtValue;
			
		}
		else
		{
			if(kbProtoUnitAvailable(mainArtlowValue) == true  && scoreLeft > 0) mainArtlowValue = armyRatio(diff);
			if(mainArtlowValue > scoreLeft) mainArtlowValue = scoreLeft;
			scoreLeft = scoreLeft - mainArtlowValue;
			
		}
	}
	
	unitCount = kbUnitCount(cMyID, mainArtAnti, cUnitStateABQ);
	if(artilleryCountEnemy > unitCount && kbUnitCount(cMyID, gArtilleryDepotUnit, cUnitStateAlive) != 0)
	{
		diff = artilleryCountEnemy - unitCount;
		if(kbProtoUnitAvailable(mainArtAnti) == true  && scoreLeft > 0) mainArtAntiValue = armyRatio(diff);
		//if(mainArtAntiValue > 0.3) mainArtAntiValue = 0.3;
		if(mainArtAntiValue > scoreLeft) mainArtAntiValue = scoreLeft;
		scoreLeft = scoreLeft - mainArtAntiValue;
	}
	
	if(kbGetPop() > 200 && kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) != 0) 
	{
		mainMercenaryValue = scoreLeft;
		scoreLeft = 0.0;
		
	}
	
	//inf
	unitCount = kbUnitCount(cMyID, mainINF, cUnitStateABQ);
	if(totalEnemyInfantryCount > unitCount && kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) != 0)
	{
		diff = totalEnemyInfantryCount - unitCount;
		
		if(diff < 15 )
		{
			if(kbProtoUnitAvailable(mainINFlow) == true  && scoreLeft > 0) mainINFlowValue = armyRatio(diff);
			scoreLeft = scoreLeft - mainINFlowValue;	
		}
		
		else if(kbProtoUnitAvailable(mainINF) == true  && scoreLeft > 0)
		{
			if(kbProtoUnitAvailable(mainINF) == true  && scoreLeft > 0)  mainINFValue = armyRatio(diff);
			scoreLeft = scoreLeft - mainINFValue;
			
		}
	}
	
	if(kbProtoUnitAvailable(mainCav) == true  && scoreLeft > 0 && kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) != 0)
	{
		mainCavValue = scoreLeft;
		scoreLeft = 0.0;
	}
	
	else
	{
		if(kbProtoUnitAvailable(mainCavlow) == true  && scoreLeft > 0 && kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) != 0) 
		{
			mainCavlowValue = scoreLeft;
			scoreLeft = 0.0;
		}
	}
	if(kbGetPop() > 180)
	{
		mainCavValue = 0.0;
		mainCavlowValue = 0.0;
		antiCavValue = 0.0;
		mainArtValue = 0.0;
		mainArtlowValue = 0.0;
		mainArtAntiValue = 0.0;
		mainINFValue = 0.0;
		mainINFlowValue = 0.0;
		antiHIValue = 0.0;
		antiHILowValue = 0.0;
		antiLIValue = 0.0;
		antiLIlowValue = 0.0;
		antiLCValue = 0.0;
		antiLClowValue = 0.0;
		antiCAVINFValue = 0.0;
		antiCAVlowValue = 0.0;
		baseCavAntiValue = 0.0;
		mainNativeWarriorValue = 0.2;
		mainMercenaryValue = 0.8;
	}				 
	
	if(kbGetPop() == (kbGetPopCap()))
	{
		mainCavValue = 0.0;
		mainCavlowValue = 0.0;
		antiCavValue = 0.0;
		mainArtValue = 0.0;
		mainArtlowValue = 0.0;
		mainArtAntiValue = 0.0;
		mainINFValue = 0.0;
		mainINFlowValue = 0.0;
		antiHIValue = 0.0;
		antiHILowValue = 0.0;
		antiLIValue = 0.0;
		antiLIlowValue = 0.0;
		antiLCValue = 0.0;
		antiLClowValue = 0.0;
		antiCAVINFValue = 0.0;
		antiCAVlowValue = 0.0;
		baseCavAntiValue = 0.0;
		mainNativeWarriorValue = 0.5;
		mainMercenaryValue = 0.5;
	}
	
	if(kbResourceGet(cResourceFood) < 200 && kbGetCiv() != cCivDutch)
	{
		mainCavValue = 0.0;
		mainCavlowValue = 0.0;
		antiCavValue = 0.0;
		mainArtValue = 0.0;
		mainArtlowValue = 0.0;
		mainArtAntiValue = 0.0;
		mainINFValue = 0.0;
		mainINFlowValue = 0.0;
		antiHIValue = 0.0;
		antiHILowValue = 0.0;
		antiLIValue = 0.0;
		antiLIlowValue = 0.0;
		antiLCValue = 0.0;
		antiLClowValue = 0.0;
		antiCAVINFValue = 0.0;
		antiCAVlowValue = 0.0;
		baseCavAntiValue = 0.0;
		mainNativeWarriorValue = 0.0;
		mainMercenaryValue = 0.0;
	}
	
	if(kbResourceGet(cResourceGold) < 200 && kbGetCiv() == cCivDutch)
	{
		mainCavValue = 0.0;
		mainCavlowValue = 0.0;
		antiCavValue = 0.0;
		mainArtValue = 0.0;
		mainArtlowValue = 0.0;
		mainArtAntiValue = 0.0;
		mainINFValue = 0.0;
		mainINFlowValue = 0.0;
		antiHIValue = 0.0;
		antiHILowValue = 0.0;
		antiLIValue = 0.0;
		antiLIlowValue = 0.0;
		antiLCValue = 0.0;
		antiLClowValue = 0.0;
		antiCAVINFValue = 0.0;
		antiCAVlowValue = 0.0;
		baseCavAntiValue = 0.0;
		mainNativeWarriorValue = 0.0;
		mainMercenaryValue = 0.0;
	}
	
	
	if(kbGetAge() < cAge3)
	{
		mainCavPlan = createSimpleMaintainPlan(mainCav, 10, true, kbBaseGetMainID(cMyID), 5);
		addItemToForecasts(mainCav, 10); 
		
		mainINFPlan = createSimpleMaintainPlan(mainINF, 10, true, kbBaseGetMainID(cMyID), 5);
		addItemToForecasts(mainINF, 10); 	
	}
	
	else
	{
		mainNativeWarriorPlan = createSimpleMaintainPlan(mainNativeWarrior, (gMaxPopFixValue * mainNativeWarriorValue), true, kbBaseGetMainID(cMyID), 5);
		mainMercenaryPlan = createSimpleMaintainPlan(mainMercenary, (gMaxPopFixValue * mainMercenaryValue), true, kbBaseGetMainID(cMyID), 5);
		baseCavAntiPlan = createSimpleMaintainPlan(baseCavAnti, (gMaxPopFixValue * baseCavAntiValue), true, kbBaseGetMainID(cMyID), 5);	
		antiHILowPlan = createSimpleMaintainPlan(antiHIlow, (gMaxPopFixValue * antiHILowValue), true, kbBaseGetMainID(cMyID), 5);
		antiHIPlan = createSimpleMaintainPlan(antiHI, (gMaxPopFixValue * antiHIValue), true, kbBaseGetMainID(cMyID), 5);
		antiLIlowPlan = createSimpleMaintainPlan(antiLIlow, (gMaxPopFixValue * antiLIlowValue), true, kbBaseGetMainID(cMyID), 5);
		antiLIPlan = createSimpleMaintainPlan(antiLI, (gMaxPopFixValue * antiLIValue), true, kbBaseGetMainID(cMyID), 5);
		antiLCPlan = createSimpleMaintainPlan(antiLC, (gMaxPopFixValue * antiLCValue), true, kbBaseGetMainID(cMyID), 5);
		antiLClowPlan = createSimpleMaintainPlan(antiLClow, (gMaxPopFixValue * antiLClowValue), true, kbBaseGetMainID(cMyID), 5);
		antiCavPlan = createSimpleMaintainPlan(antiCav, (gMaxPopFixValue * antiCavValue), true, kbBaseGetMainID(cMyID), 5);
		mainCavlowPlan = createSimpleMaintainPlan(antiCAVlow, (gMaxPopFixValue * antiCAVlowValue), true, kbBaseGetMainID(cMyID), 5);
		antiCAVINFPlan = createSimpleMaintainPlan(antiCAVINF, (gMaxPopFixValue * antiCAVINFValue), true, kbBaseGetMainID(cMyID), 5);
		mainArtAntiPlan = createSimpleMaintainPlan(mainArtAnti, (gMaxPopFixValue * mainArtAntiValue), true, kbBaseGetMainID(cMyID), 5);
		mainArtlowPlan = createSimpleMaintainPlan(mainArtlow, (gMaxPopFixValue * mainArtlowValue), true, kbBaseGetMainID(cMyID), 5);
		mainArtPlan = createSimpleMaintainPlan(mainArt, (gMaxPopFixValue * mainArtValue), true, kbBaseGetMainID(cMyID), 5);
		mainINFlowPlan = createSimpleMaintainPlan(mainINFlow, (gMaxPopFixValue * mainINFlowValue), true, kbBaseGetMainID(cMyID), 5);
		antiCAVlowPlan = createSimpleMaintainPlan(mainCavlow, (gMaxPopFixValue * mainCavlowValue), true, kbBaseGetMainID(cMyID), 5);
		mainINFPlan = createSimpleMaintainPlan(mainINF, (gMaxPopFixValue * mainINFValue), true, kbBaseGetMainID(cMyID), 5);
		mainCavPlan = createSimpleMaintainPlan(mainCav, (gMaxPopFixValue * mainCavValue), true, kbBaseGetMainID(cMyID), 5);
			
		addItemToForecasts(mainNativeWarrior, (gMaxPopFixValue * mainNativeWarriorValue));
		addItemToForecasts(mainMercenary, (gMaxPopFixValue * mainMercenary));
		addItemToForecasts(baseCavAnti, (gMaxPopFixValue * baseCavAnti));
		addItemToForecasts(antiHIlow, (gMaxPopFixValue * antiHIlow));
		addItemToForecasts(antiHI, (gMaxPopFixValue * antiHI));
		addItemToForecasts(antiLIlow, (gMaxPopFixValue * antiLIlow));
		addItemToForecasts(antiLI, (gMaxPopFixValue * antiLI));
		addItemToForecasts(antiLC, (gMaxPopFixValue * antiLC));
		addItemToForecasts(antiLClow, (gMaxPopFixValue * antiLClow));
		addItemToForecasts(antiCav, (gMaxPopFixValue * antiCav));
		addItemToForecasts(antiCAVlow, (gMaxPopFixValue * antiCAVlow));
		addItemToForecasts(antiCAVINF, (gMaxPopFixValue * antiCAVINF));
		addItemToForecasts(mainArtAnti, (gMaxPopFixValue * mainArtAnti));
		addItemToForecasts(mainArtlow, (gMaxPopFixValue * mainArtlow));
		addItemToForecasts(mainArt, (gMaxPopFixValue * mainArt));
		addItemToForecasts(mainINFlow, (gMaxPopFixValue * mainINFlow));
		addItemToForecasts(mainCavlow, (gMaxPopFixValue * mainCavlow));
		addItemToForecasts(mainINF, (gMaxPopFixValue * mainINF));
		addItemToForecasts(mainCav, (gMaxPopFixValue * mainCav)); 
	}
	/*
	if(kbUnitCount(cMyID, mainCav, cUnitStateAlive) < 5)
	{
		aiTaskUnitTrain(getUnit(gStableUnit), kbUnitGetProtoUnitID(mainCav));
		aiTaskUnitTrain(getUnit(gStableUnit), kbUnitGetProtoUnitID(mainCav));
		aiTaskUnitTrain(getUnit(gStableUnit), kbUnitGetProtoUnitID(mainCav));
		aiTaskUnitTrain(getUnit(gStableUnit), kbUnitGetProtoUnitID(mainCav));
		aiTaskUnitTrain(getUnit(gStableUnit), kbUnitGetProtoUnitID(mainCav));
		addItemToForecasts(mainCav, 5); 
	}	*/
}


rule militaryManager
active
minInterval 30 //30
{
	
	static bool init = false;   // Flag to indicate vars, plans are initialized
	int i = 0;
	int proto = 0;
	int planID = -1;
	
	//if (aiGetWorldDifficulty() == cDifficultyExpert) kbLookAtAllUnitsOnMap();
	
	if(kbGetCiv() == cCivFrench || 
		kbGetCiv() == cCivJapanese || 
		kbGetCiv() == cCivSpanish || 
		kbGetCiv() == cCivBritish || 
		kbGetCiv() == cCivPortuguese || 
		kbGetCiv() == cCivDutch || 
		kbGetCiv() == cCivRussians || 
		kbGetCiv() == cCivGermans || 
		kbGetCiv() == cCivOttomans || 
		kbGetCiv() == cCivXPIroquois || 
		kbGetCiv() == cCivXPSioux || 
		kbGetCiv() == cCivXPAztec || 
		kbGetCiv() == cCivUSA || 
		kbGetCiv() == cCivSwedish || 
		kbGetCiv() == cCivChinese || 
		kbGetCiv() == cCivIndians || 
	kbGetCiv() == cCivItalians)
	{		
		armyTrain();
	}
	else
	{
		if (init == true)
		{     
			// Need to initialize, if we're allowed to.
			if (cvOkToTrainArmy == true)
			{
				init = false;
				//if (cvNumArmyUnitTypes >= 0)
				//gNumArmyUnitTypes = cvNumArmyUnitTypes;
				//else
				gNumArmyUnitTypes = 19;
				gLandUnitPicker = initUnitPicker("Land military units", gNumArmyUnitTypes, 1, 60, -1, -1, 1, true); 
				
				// now the goal
				// wmj -- hard coded for now, but this should most likely ramp up as the ages progress
				//aiSetMinArmySize(15);
				aiPlanDestroy(gMainAttackGoal);
				gMainAttackGoal = createSimpleAttackGoal("AttackGoal", aiGetMostHatedPlayerID(), gLandUnitPicker, -1, cAge2, -1, gMainBase, false);
				aiPlanSetVariableInt(gMainAttackGoal, cGoalPlanReservePlanID, 0, gLandReservePlan);
			}
		}
	}
	
	
	
	/*
		//static bool init = false;   // Flag to indicate vars, plans are initialized
		int i = 0;
		int proto = 0;
		int planID = -1;
		
		// if (init == false)
		//{  
		if (newAttackGoal == -1)
		{     
		//newAttackGoal = 0;
		aiPlanDestroyByName("AttackGoal");
		// Need to initialize, if we're allowed to.
		if (cvOkToTrainArmy == true)
		{
		
		
		//				init = true;
		if (cvNumArmyUnitTypes >= 0)
		gNumArmyUnitTypes = cvNumArmyUnitTypes;
		else
		gNumArmyUnitTypes = 19;
		
		gLandUnitPicker = initUnitPicker("Land military units", gNumArmyUnitTypes, 1, 60, -1, -1, 1, true); 
		
		
		// now the goal
		// wmj -- hard coded for now, but this should most likely ramp up as the ages progress
		//aiSetMinArmySize(15);
		
		gMainAttackGoal = createSimpleAttackGoal("AttackGoal", aiGetMostHatedPlayerID(), gLandUnitPicker, -1, cAge2, -1, gMainBase, false);
		aiPlanSetVariableInt(gMainAttackGoal, cGoalPlanReservePlanID, 0, gLandReservePlan);
		}
		}
		//}
	*/
	//updatedOn 2019/05/10 By ageekhere  
	//---------------------------
	if(gLandUnitPicker != -1)
	{
		setUnitPickerPreference(gLandUnitPicker); // Update preferences in case btBiasEtc vars have changed, or cvPrimaryArmyUnit has changed.
		//if(capedPop != -1)
		//{
			//	kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 5);
			//	kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, gMaxPopFixValue);
		//}
		if(revolted == true)
		{
			kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 10);
			kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, gMaxPopFixValue);
		}
		
		else if(kbGetAge() == cAge2)
		{
			kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 20);     
			kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, gMaxPopFixValue);
		}
		
		else if(kbGetAge() == cAge3)
		{
			kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 60);                                                           
			kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, gMaxPopFixValue);
		}
		else if(kbGetAge() == cAge4)
		{
			kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 80);
			kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, gMaxPopFixValue);
		}
		else if(kbGetAge() == cAge5)
		{
			kbUnitPickSetMinimumNumberUnits(gLandUnitPicker, 100);
			kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, gMaxPopFixValue);
			//kbUnitPickSetMaximumNumberUnits(gLandUnitPicker, 90);
		}
	}
	//---------------------------
	
	switch(kbGetAge())
	{
		case cAge1:
		{
			break;
		}
		case cAge2:
		{
			aiSetMinArmySize(20); // Now irrelevant?  (Was used to determine when to launch attack, but attack goal and opp scoring now do this.)
			break;
		}
		case cAge3:
		{
			aiSetMinArmySize(60);
			break;
		}
		case cAge4:
		{
			aiSetMinArmySize(80);//25
			break;
		}
		case cAge5:
		{
			aiSetMinArmySize(100);//30
			break;
		}
	}
}

void navyTarget(int myUnit = -1,int targetUnit = -1,float dist = -1.0 )
{
	bool skipShip = false;
	//if(kbUnitQueryExecute(targetUnit) > 0 && kbUnitQueryExecute(myUnit) > kbUnitQueryExecute(targetUnit))
	//{
		for (i = 0; < kbUnitQueryExecute(myUnit))
		{
			skipShip = false;
			for(j = 0; < xsArrayGetSize(transportShipsArray))
			{
				if(xsArrayGetInt(transportShipsArray,j) == kbUnitQueryGetResult(myUnit,i) || currentShipTransport == kbUnitQueryGetResult(myUnit,i)) 
				{
					skipShip = true;
					break;
				}
			}
			if (skipShip == false)
			{
				//for(k = 0; < kbUnitQueryExecute(targetUnit) )
				for(k = kbUnitQueryExecute(targetUnit) -1; > -1)
				{
					//if( kbCanSimPath(kbUnitGetPosition(kbUnitQueryGetResult(myUnit, i)) , kbUnitGetPosition(kbUnitQueryGetResult(targetUnit, k)), kbUnitQueryGetResult(myUnit, i) , 1000 ) == false )continue;
					if( dist < distance( kbUnitGetPosition(kbUnitQueryGetResult(myUnit,i)), kbUnitGetPosition(kbUnitQueryGetResult(targetUnit, k)) ) )
					{
						aiPlanDestroy(kbUnitGetPlanID(kbUnitQueryGetResult(myUnit,i)));
						aiTaskUnitWork(kbUnitQueryGetResult(myUnit,i),kbUnitQueryGetResult(targetUnit, k));	
					}
				}
			}
		}
	//}
	
}

//==============================================================================
// waterAttack
// updatedOn 2020/04/04 By ageekhere
//==============================================================================
void waterAttack()
{
	int myNavy = kbUnitQueryCreate("myNavy");
	kbUnitQuerySetPlayerID(myNavy, cMyID);
	kbUnitQuerySetUnitType(myNavy, cUnitTypeAbstractWarShip);
	kbUnitQuerySetPosition(myNavy, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetAscendingSort(myNavy,false);
	kbUnitQuerySetIgnoreKnockedOutUnits(myNavy, true);
	kbUnitQuerySetActionType(myNavy,7);
	kbUnitQuerySetState(myNavy, cUnitStateAlive);
	
	int enemyNavy = kbUnitQueryCreate("enemyNavy");
	kbUnitQuerySetPlayerRelation(enemyNavy, cPlayerRelationEnemyNotGaia);
	kbUnitQuerySetUnitType(enemyNavy, cUnitTypeAbstractWarShip);
	kbUnitQuerySetPosition(enemyNavy, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetAscendingSort(enemyNavy,false);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyNavy, true);
	kbUnitQuerySetState(enemyNavy, cUnitStateAlive);
	
	int enemyNavyDock = kbUnitQueryCreate("enemyNavyDock");
	kbUnitQuerySetPlayerRelation(enemyNavyDock, cPlayerRelationEnemyNotGaia);
	kbUnitQuerySetUnitType(enemyNavyDock, cUnitTypeAbstractDock);
	kbUnitQuerySetPosition(enemyNavyDock, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetAscendingSort(enemyNavyDock,false);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyNavyDock, true);
	kbUnitQuerySetState(enemyNavyDock, cUnitStateAlive);
	
	int enemyNavyFishing = kbUnitQueryCreate("enemyNavyFishing");
	kbUnitQuerySetPlayerRelation(enemyNavyFishing, cPlayerRelationEnemyNotGaia);
	kbUnitQuerySetUnitType(enemyNavyFishing, cUnitTypeAbstractFishingBoat);
	kbUnitQuerySetPosition(enemyNavyFishing, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetAscendingSort(enemyNavyFishing,false);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyNavyFishing, true);
	kbUnitQuerySetState(enemyNavyFishing, cUnitStateAlive);
	
	int guardianWater = kbUnitQueryCreate("guardianWater");
	kbUnitQuerySetPlayerRelation(guardianWater, cPlayerRelationEnemy);
	kbUnitQuerySetUnitType(guardianWater, cUnitTypeWaterGuardian);
	kbUnitQuerySetPosition(guardianWater, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetAscendingSort(guardianWater,false);
	kbUnitQuerySetIgnoreKnockedOutUnits(guardianWater, true);
	kbUnitQuerySetState(guardianWater, cUnitStateAlive);
	
	int nuggetWater = kbUnitQueryCreate("nuggetWater");
	kbUnitQuerySetPlayerRelation(nuggetWater, cPlayerRelationEnemy);
	kbUnitQuerySetUnitType(nuggetWater, cUnitTypeAbstractNuggetWater);
	kbUnitQuerySetPosition(nuggetWater, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetAscendingSort(nuggetWater,true);
	kbUnitQuerySetIgnoreKnockedOutUnits(nuggetWater, true);
	kbUnitQuerySetState(nuggetWater, cUnitStateAlive);
	
	int nuggetNavy = kbUnitQueryCreate("nuggetNavy");
	kbUnitQuerySetPlayerID(nuggetNavy, cMyID);
	kbUnitQuerySetUnitType(nuggetNavy, gCaravelUnit);
	kbUnitQuerySetPosition(nuggetNavy, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetAscendingSort(nuggetNavy,false);
	kbUnitQuerySetIgnoreKnockedOutUnits(nuggetNavy, true);
	kbUnitQuerySetActionType(nuggetNavy,7);
	kbUnitQuerySetState(nuggetNavy, cUnitStateAlive);
	
	/*
		int fishQuery=kbUnitQueryCreate("fish query");
		kbUnitQuerySetIgnoreKnockedOutUnits(fishQuery, true);
		kbUnitQuerySetPlayerID(fishQuery, 0);
		kbUnitQuerySetUnitType(fishQuery, cUnitTypeAbstractFish);
		kbUnitQuerySetState(fishQuery, cUnitStateAny);
		kbUnitQuerySetPosition(fishQuery, kbUnitGetPosition( getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID) ));
		kbUnitQuerySetAscendingSort(fishQuery, true);
		
	*/
	bool skipShip = false;
	if(kbUnitQueryExecute(myNavy) == 0)return;
	
	for (j = 0; < kbUnitQueryExecute(myNavy))
	{
		if( currentShipTransport == kbUnitQueryGetResult(myNavy,j) ) continue;		
		int fish = getUnit(cUnitTypeAbstractFish, 0, cUnitStateAny);
		aiTaskUnitWork(kbUnitQueryGetResult(myNavy,j),fish);
		
	}
	
	if(kbUnitQueryExecute(enemyNavy) > 0 && kbUnitQueryExecute(myNavy) > kbUnitQueryExecute(enemyNavy))
	{
		navyTarget(myNavy,enemyNavy,30);
		
	}
	
	else if(kbUnitQueryExecute(enemyNavy) == 0 && kbUnitQueryExecute(enemyNavyDock) > 0 && kbUnitQueryExecute(myNavy) > 3)
	{
		navyTarget(myNavy,enemyNavyDock,30);
	}
	
	else if(kbUnitQueryExecute(enemyNavyFishing) > 0)
	{
		navyTarget(myNavy,enemyNavyFishing,30);
	}
	
	else if (islandLanded == true)
	{
		for (j = 0; < kbUnitQueryExecute(myNavy))
		{
			aiTaskUnitMove( kbUnitQueryGetResult(myNavy,j) ,kbUnitGetPosition(islandLandedLocationUnit) );	
		}
		
	}
	
	else if(kbUnitQueryExecute(guardianWater) > 0 && kbUnitQueryExecute(myNavy) > 2)
	{
		navyTarget(myNavy,guardianWater,10);
	}
	
	else if (kbUnitQueryExecute(myNavy) > 4)
	{
		bool breakj = false;
		skipShip = false;
		for(i = 0; < xsArrayGetSize(shorelineEnemyBuildingsArray))
		{
			int enemyBuilding = xsArrayGetInt(shorelineEnemyBuildingsArray,i);
			if(enemyBuilding == -1) break;
			if( kbUnitGetHealth(enemyBuilding) > 0.0 )
			{
				breakj = true;
				for (j = 0; < kbUnitQueryExecute(myNavy))
				{
					if( currentShipTransport == kbUnitQueryGetResult(myNavy,j) ) continue;	
					skipShip = false;
					for(k = 0; < xsArrayGetSize(transportShipsArray))
					{
						if(xsArrayGetInt(transportShipsArray,k) == kbUnitQueryGetResult(myNavy,j) || currentShipTransport == kbUnitQueryGetResult(myNavy,j)) 
						{
							skipShip = true;
							break;
						}
					}
					
					if(skipShip == false)
					{
						aiTaskUnitWork(kbUnitQueryGetResult(myNavy,j),enemyBuilding);
					}	
				}	
			}
			if(breakj == true) break;
		}	
	}
	
	
	if (kbUnitQueryExecute(nuggetWater) > 0)
	{
		for (i = 0; < kbUnitQueryExecute(nuggetNavy))
		{
			if( currentShipTransport == kbUnitQueryGetResult(nuggetNavy,i) ) continue;	
			skipShip = false;
			
			for(t = 0; < xsArrayGetSize(transportShipsArray))
			{
				if(xsArrayGetInt(transportShipsArray,t) == kbUnitQueryGetResult(nuggetNavy,i) || currentShipTransport == kbUnitQueryGetResult(nuggetNavy,i)) 
				{
					skipShip = true;
					break;
				}
			}
			if(skipShip == false)
			{
				for (h = kbUnitQueryExecute(nuggetWater) -1; > -1)
				{
					bool skipNugget = false;
					//if( kbCanSimPath(kbUnitGetPosition(kbUnitQueryGetResult(nuggetNavy, i)) , kbUnitGetPosition(kbUnitQueryGetResult(nuggetWater, h)), kbUnitQueryGetResult(nuggetNavy, i) , 1000 ) == false )continue;					
					for(j = 0; < kbUnitQueryExecute(guardianWater) )
					{
						float dist = distance(kbUnitGetPosition(kbUnitQueryGetResult(nuggetWater,h)), kbUnitGetPosition(kbUnitQueryGetResult(guardianWater,j))); 
						if(dist < 10 )
						{
							skipNugget = true;
							break;
						}	
					}
					
					if(skipNugget == false)
					{
						aiTaskUnitWork(kbUnitQueryGetResult(nuggetNavy,i),kbUnitQueryGetResult(nuggetWater,h));
						break;
					}
					
				}
			}
			
		}
	}
}

int getNavalTargetPlayer()    // Find an enemy player ID to attack on the water.
{
	int count = 0;
	int retVal = -1;
	static int unitQueryID = -1;
	
	//If we don't have the query yet, create one.
	if (unitQueryID < 0)
	{
		unitQueryID=kbUnitQueryCreate("navy target count");
		kbUnitQuerySetIgnoreKnockedOutUnits(unitQueryID, true);
		kbUnitQuerySetPlayerRelation(unitQueryID, cPlayerRelationEnemyNotGaia);
	}
	
	kbUnitQuerySetUnitType(unitQueryID, gFishingUnit);   // Fishing boats
	kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
	kbUnitQueryResetResults(unitQueryID);
	count = kbUnitQueryExecute(unitQueryID);  
	//aiEcho("Enemy fishing boats: "+ count);
	
	kbUnitQuerySetUnitType(unitQueryID, cUnitTypeAbstractWarShip);   // Warships
	kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
	count = kbUnitQueryExecute(unitQueryID);  // Cumulative, don't clear it.
	//aiEcho("Enemy fishing boats and warships: "+ count);
	
	kbUnitQuerySetUnitType(unitQueryID, gDockUnit);   // Docks
	kbUnitQuerySetState(unitQueryID, cUnitStateABQ);
	count = kbUnitQueryExecute(unitQueryID);  // Cumulative, don't clear it.
	//aiEcho("Enemy fishing boats, warships and docks: "+ count);
	
	if (count > 0)
	retVal = kbUnitGetPlayerID(kbUnitQueryGetResult(unitQueryID,0));
	
	//aiEcho("Enemy boat owner is player "+retVal);
	
	return(retVal);
}

//rule waterAttackDefend
//active
//minInterval 15
void waterAttackDefend()
{  // Broke this out separately (from navyManager) so that scenarios that start with a pre-made navy will work. 
	
	return;
	if (cvInactiveAI == true)
	{
		// xsDisableSelf();
		return;
	}
	int navyUnit = getUnit(cUnitTypeAbstractWarShip, cMyID, cUnitStateAlive);
	
	if (navyUnit < 0)
	return;
	
	//updatedOn 2019/03/11 By ageekhere    
	//---------------------------
	//Get ai to send navy to Enemy
	int flagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, getEnemyPlayerByTeamPosition(getTeamPosition(cMyID)));
	
	int defendflagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
	vector defendNavy = kbUnitGetPosition(defendflagUnit);
	//   if(aiGetWorldDifficulty() == cDifficultySandbox) flagUnit= defendNavy;
	if (flagUnit >= 0)
	gNavyVec = kbUnitGetPosition(flagUnit);
	else
	gNavyVec = kbUnitGetPosition(navyUnit);
	
	
	
	
	
	if (gNavyDefendPlan < 0)
	{
		gNavyDefendPlan = aiPlanCreate("Primary Water Defend", cPlanDefend);
		aiPlanAddUnitType(gNavyDefendPlan, cUnitTypeAbstractWarShip , 1, 1, 200);    // Grab first caravel and any others     
		aiPlanSetVariableVector(gNavyDefendPlan, cDefendPlanDefendPoint, 0, defendNavy);
		aiPlanSetVariableFloat(gNavyDefendPlan, cDefendPlanEngageRange, 0, 100.0);    // Loose
		aiPlanSetVariableBool(gNavyDefendPlan, cDefendPlanPatrol, 0, false);
		aiPlanSetVariableFloat(gNavyDefendPlan, cDefendPlanGatherDistance, 0, 40.0);
		aiPlanSetInitialPosition(gNavyDefendPlan, defendNavy);
		aiPlanSetUnitStance(gNavyDefendPlan, cUnitStanceDefensive);
		aiPlanSetVariableInt(gNavyDefendPlan, cDefendPlanRefreshFrequency, 0, 20);
		aiPlanSetVariableInt(gNavyDefendPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
		aiPlanSetDesiredPriority(gNavyDefendPlan, 20);    // Very low priority, gather unused units.
		aiPlanSetActive(gNavyDefendPlan); 
		//aiEcho("Creating primary navy defend plan at "+defendNavy);
	}
	
	if (((aiPlanGetNumberUnits(gNavyDefendPlan, cUnitTypeAbstractWarShip) >= 3 ) && (civIsNative() == false)) ||
	((aiPlanGetNumberUnits(gNavyDefendPlan, cUnitTypeAbstractWarShip) >= 6 ) && (civIsNative() == true))) 
	{  // Time to start an attack?
		int attackPlan = aiPlanCreate("Navy attack plan", cPlanAttack);
		aiPlanSetVariableInt(attackPlan, cAttackPlanPlayerID, 0, getNavalTargetPlayer());
		aiPlanSetNumberVariableValues(attackPlan, cAttackPlanTargetTypeID, 2, true);
		aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 0, cUnitTypeUnit);
		aiPlanSetVariableInt(attackPlan, cAttackPlanTargetTypeID, 1, gDockUnit);
		aiPlanSetVariableVector(attackPlan, cAttackPlanGatherPoint, 0, gNavyVec);
		aiPlanSetVariableFloat(attackPlan, cAttackPlanGatherDistance, 0, 30.0);
		aiPlanSetVariableInt(attackPlan, cAttackPlanRefreshFrequency, 0, 5);
		aiPlanSetDesiredPriority(attackPlan, 48); // Above defend, fishing.  Below explore.
		aiPlanAddUnitType(attackPlan, cUnitTypeAbstractWarShip, 1, 10, 200); 
		aiPlanSetInitialPosition(attackPlan, gNavyVec);
		//aiEcho("***** LAUNCHING NAVAL ATTACK, plan ID is "+attackPlan); 
		aiPlanSetActive(attackPlan, true);
	}   
}

//==============================================================================
/*
	Navy Manager
	
	Create maintain plans for navy unit lines.  Control 'maintain' levels.
*/
//==============================================================================
bool sendNavyForLanding = false;
//int dockBuildPlan = -1;
int dockBuildTry = 0;
rule navyManager
inactive
minInterval 30
{			
	if (gNavyMap == false || aiGetWorldDifficulty() == cDifficultySandbox)
	{
		gNavyMode = cNavyModeOff;
		//aiEcho("gNavyMap was false, turning off navy manager.");
		xsDisableSelf();
		return;
	}
	/*
		if (getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID) < 0)
		{
		aiEcho("**** NO WATER FLAG, TURNING NAVY OFF ****");
		xsDisableSelf();
		return;
		}
	*/
	
	
	// If it was not full on...
	if ( (gNavyMode == cNavyModeOff) ) 
	{  // We're not currently training a navy...see if we should be
		// Turning it on by default, now that we have variable maintain levels
		gNavyMode = cNavyModeActive;
		//      if (getNavalTargetPlayer() > 0)
		//      {
		//         gNavyMode = cNavyModeActive;  // They have a navy.
		//         aiEcho("Saw enemy naval units.");
		//      }
		
		if (cvOkToTrainNavy == false)
		gNavyMode = cNavyModeOff; // Overrides others. 
		
		if (gNavyMode == cNavyModeActive)   // We're turning it on
		{
			if (gCaravelMaintain >= 0)
            aiPlanSetActive(gCaravelMaintain, true);
			if (gGalleonMaintain >= 0)
            aiPlanSetActive(gGalleonMaintain, true);
			if (gFrigateMaintain >= 0)
            aiPlanSetActive(gFrigateMaintain, true);
			if (gMonitorMaintain >= 0)
            aiPlanSetActive(gMonitorMaintain, true);
			//aiEcho("**** TURNING NAVY ON ****");
		}
		else
		{
			aiEcho("No navy targets detected.");
		}
		
	}
    
	
	if (gNavyMode == cNavyModeOff)
	return;  // We didn't turn it on, so we're done
	
	// If we're here, navyMode is active.  See if we need to turn it off
	if (cvOkToTrainNavy == false)
	gNavyMode = cNavyModeOff;
	
	// If we don't see any naval targets or threats, turn it off.
	// Disabling this now that we added variable maintain plans.  If no enemy navy is visible, maintain a small force.
	//if ( getNavalTargetPlayer() < 0 )
	//   gNavyMode = cNavyModeOff;      // No need for a navy, we don't see targets any more
	
	
	
	if ( gNavyMode != cNavyModeActive ) 
	{  // It's been turned off or set to explore, stop the plans
		//aiEcho("**** TURNING NAVY OFF BECAUSE WE SEE NO DOCKS OR SHIPS ****");
		if (gCaravelMaintain >= 0)
		aiPlanSetActive(gCaravelMaintain, false);
		if (gGalleonMaintain >= 0)
		aiPlanSetActive(gGalleonMaintain, false);
		if (gFrigateMaintain >= 0)
		aiPlanSetActive(gFrigateMaintain, false);
		if (gMonitorMaintain >= 0)
		aiPlanSetActive(gMonitorMaintain, false);
	} 
	if (gNavyMode == cNavyModeOff)
	return;
	
	// If we're here, gNavyMode is active, and it should be.  Make sure we have a dock, then make sure maintain plans exist.
	
	vector flagVec =  cInvalidVector;
	int flagUnit = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
	
	if (flagUnit >= 0)
	{      
		flagVec = kbUnitGetPosition(flagUnit);
	}
	else
	{
		int closestDock = getUnitByLocation(gDockUnit, cMyID, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 500.0); //500
		if (closestDock >= 0)
		{
			flagVec = kbUnitGetPosition(closestDock);
		}
	}
	
	if ( (gNavyVec == cInvalidVector) && (flagVec != cInvalidVector) )
	{
		gNavyVec = flagVec;   // Set global vector   
	}
	
	
	
	//updatedOn 2019/04/13 By ageekhere    
	//---------------------------
	switch(kbGetAge())
	{ //Finds the age the ai is in and sets the max amount of docks it can build
		case cAge1:{dockBuikdNum = 2;break;}
		case cAge2:{dockBuikdNum = 4;break;}
		case cAge3:{dockBuikdNum = 6;break;}
		case cAge4:{dockBuikdNum = 8;break;}
		case cAge5:{dockBuikdNum = 10;break;}
	}
	if(kbResourceGet(cResourceWood) < 2000)
	{
		dockBuikdNum = 2;
	}
	
	if(kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) == 0) dockBuikdNum = 0;
	if(kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) == 1) dockBuikdNum = 1;
	if(kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) == 2) dockBuikdNum = 2;
	
	if (kbUnitCount(cMyID, gDockUnit, cUnitStateAlive) < dockBuikdNum)    
	{  // No dock or under the dockBuikdNum limit.  If no fishing plan, and no dock plan, then start one...otherwise just wait.
		// Nobody making a dock, let's start a plan
		
		bool dockFailed = false;
		static int dockPlan = -1;
		if(dockBuildTry == 4 )//&& dockBuildPlan == dockPlan)
		{
			//aiPlanDestroy(dockPlan);
			dockBuildTry = 0;
			dockPlan = -1;
			dockFailed = true;
		}
		if(dockPlan == -1)
		{
			//dockBuildPlan = dockPlan;
			
			dockPlan = aiPlanCreate("military dock plan", cPlanBuild);
			mainDockPlan = dockPlan;
			aiPlanSetVariableInt(dockPlan, cBuildPlanBuildingTypeID, 0, gDockUnit);
			aiPlanSetDesiredPriority(dockPlan, 100); //80
			aiPlanSetMilitary(dockPlan, true);
			aiPlanSetEconomy(dockPlan, false);
			aiPlanSetEscrowID(dockPlan, cMilitaryEscrowID);
			
			if (kbUnitCount(cMyID, cUnitTypeYPDockWagon, cUnitStateAlive) > 0) 
			{
				aiPlanAddUnitType(dockPlan, cUnitTypeYPDockWagon, 1, 1, 1);
			}
			else {
				aiPlanAddUnitType(dockPlan, gEconUnit, 1, 1, 1);
			}
			aiPlanSetNumberVariableValues(dockPlan, cBuildPlanDockPlacementPoint, 2, true); 
			
			//alternate dock placement
			if ( (cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "ceylon") || (cRandomMapName == "borneo") || (cRandomMapName == "honshu") || dockFailed == true)
			{
				if(dockPlacement0 == 0)
				{
					dockPlacement0 = 1;
					dockPlacement1 = 0;
				}
				else
				{
					dockPlacement0 = 0;
					dockPlacement1 = 1;
				}
			}
			else
			{
				dockPlacement0 = 0;
				dockPlacement1 = 1;
			}	
			
			
			aiPlanSetVariableVector(dockPlan, cBuildPlanDockPlacementPoint, dockPlacement0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); // One point at main base 
			aiPlanSetVariableVector(dockPlan, cBuildPlanDockPlacementPoint, dockPlacement1, gNavyVec); // One point at water flag
			aiPlanSetActive(dockPlan);
			//aiEcho("**** STARTING NAVY DOCK PLAN, plan ID "+dockPlan);
			if (kbUnitCount(cMyID, gDockUnit, cUnitStateABQ) < 1) return;  // Nothing else to do until first dock is complete
		}
		dockBuildTry++;
	}
	
	closestDock = getUnitByLocation(gDockUnit, cMyID, cUnitStateAlive, flagVec, 500.0);
	if (closestDock < 0)
	closestDock = getUnit(gDockUnit, cMyID, cUnitStateAlive);
	
	if(gWaterExplorePlan < 0)
	{
		vector location = cInvalidVector;
		if (getUnit(gFishingUnit, cMyID, cUnitStateAlive) >= 0)
		location = kbUnitGetPosition(getUnit(gFishingUnit, cMyID, cUnitStateAlive));
		else
		location = gNavyVec;
		gWaterExplorePlan=aiPlanCreate("Water Explore", cPlanExplore);
		aiPlanSetVariableBool(gWaterExplorePlan, cExplorePlanReExploreAreas, 0, false);
		aiPlanSetInitialPosition(gWaterExplorePlan, location);
		aiPlanSetDesiredPriority(gWaterExplorePlan, 45);   // Low, so that transport plans can steal it as needed, but just above fishing plans.
		aiPlanAddUnitType(gWaterExplorePlan, gFishingUnit, 1, 1, 1);
		aiPlanSetEscrowID(gWaterExplorePlan, cEconomyEscrowID);
		aiPlanSetVariableBool(gWaterExplorePlan, cExplorePlanDoLoops, 0, false);
		aiPlanSetActive(gWaterExplorePlan);
	}
	
	if (closestDock < 0)
	return;  // Don't fire up maintain plans until we have a dock
	
	int baseID = kbUnitGetBaseID(closestDock);
	if (baseID < 0) 
	return;  // Don't fire up maintain plans until we have a base ID
	
	
	if(gWaterExploreMaintain < 0)
	{
		gWaterExploreMaintain = createSimpleMaintainPlan(gFishingUnit, 1, true, baseID, 1);
	}
	
	int navyEnemyPlayer = getNavalTargetPlayer();
	int enemyNavySize = kbUnitCount(navyEnemyPlayer, cUnitTypeAbstractWarShip, cUnitStateAlive);
	if ( (gCaravelMaintain < 0) && (gNavyMode == cNavyModeActive) ) // Need to init plans
	{  
		if (civIsNative() == true)
		{
			gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 20, false, baseID, 1);
			gGalleonMaintain = createSimpleMaintainPlan(gGalleonUnit, 10, false, baseID, 1);
		}
		else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
		{
			gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 5, false, baseID, 1);
			gGalleonMaintain = createSimpleMaintainPlan(gGalleonUnit, 2, false, baseID, 1);
			gMonitorMaintain = createSimpleMaintainPlan(cUnitTypeMonitor, 2, false, baseID, 1);
		}
		else
		{
			gCaravelMaintain = createSimpleMaintainPlan(gCaravelUnit, 5, false, baseID, 1);
			gGalleonMaintain = createSimpleMaintainPlan(gGalleonUnit, 3, false, baseID, 1);
			gFrigateMaintain = createSimpleMaintainPlan(gFrigateUnit, 3, false, baseID, 1);
			gMonitorMaintain = createSimpleMaintainPlan(cUnitTypeMonitor, 2, false, baseID, 1);
		}
		//aiEcho("**** ACTIVATING NAVAL TRAIN PLANS ****");
	}
	//aiEcho("Navy enemy player is "+navyEnemyPlayer+", enemy navy size is "+enemyNavySize);
	
	//updatedOn 2019/04/13 By ageekhere    
	
	if(kbResourceGet(cResourceGold) > 2000 && kbResourceGet(cResourceWood) > 2000 && enemyNavySize > 0)
	{ //go and build max navy if the ai has excess resources
		enemyNavySize = 7;
	} 
	else if (enemyNavySize < 0)
	{
		enemyNavySize = 0;
	}
	else if (enemyNavySize > 6)
	{
		enemyNavySize = 6;
	}  
	if(aiTreatyActive() == true)enemyNavySize = -1;
	if(sendNavyForLanding == true) enemyNavySize = 7;
	switch(enemyNavySize)   // Set our maintain plans to a size just larger than the enemy's known force.
	{
		case -1:
		{  // One ship minimum (two canoes for natives)
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			break;
		}
		case 0:
		{  // One ship minimum (two canoes for natives)
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			break;
		}
		case 1:
		{  // One more than enemy
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 4);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 1);
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			break;
		}
		case 2:
		{  // Two more than enemy
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 4);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 2);
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 4);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 0);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 1);
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, 1);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			break;
		}
		case 3:
		{
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 5);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 3);
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 4);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 1);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 2);
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, 1);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			break;
		}
		case 4:
		{
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 6);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 4);
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 5);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 1);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 2);
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, 1);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			break;
		}
		case 5:
		{
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 6);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 6);
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 5);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 2);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 2);
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, 2);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 0);
			}
			break;
		}
		case 6:
		{
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 8);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 8);
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 5);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 2);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 1);
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, 2);
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, 3);
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, 1);
			}
			break;
		}
		case 7:  
		{  // Go to the max (this should never happen)
			if (civIsNative() == true)
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, gCaravelUnit));
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, gGalleonUnit));
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese))
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, gCaravelUnit));
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, gGalleonUnit));
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, cUnitTypeMonitor));
			}
			else
			{
				aiPlanSetVariableInt(gCaravelMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, gCaravelUnit));
				aiPlanSetVariableInt(gGalleonMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, gGalleonUnit));
				aiPlanSetVariableInt(gFrigateMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, gFrigateUnit));  
				aiPlanSetVariableInt(gMonitorMaintain, cTrainPlanNumberToMaintain, 0, kbGetBuildLimit(cMyID, cUnitTypeMonitor));
			}
			break;
		}
	}
}

//==============================================================================
// rule age2Monitor
/*
	Watch for us reaching age 2.
*/
//==============================================================================
rule age2Monitor
inactive
group tcComplete
minInterval 5
{
	if (kbGetAge() >= cAge2)   // We're in age 2
	{
		xsDisableSelf();
		xsEnableRule("age3Monitor");
		if (xsIsRuleEnabled("militaryManager") == false)
		{
			xsEnableRule("militaryManager");
			//aiEcho("Enabling the military manager.");
			militaryManager();   // runImmediately doesn't work.
		}
		if (xsIsRuleEnabled("navyManager") == false)
		{
			xsEnableRule("navyManager");
			//aiEcho("Enabling the navy manager.");
		}
		
		//xsEnableRule("stageCoachMonitor");
		xsEnableRule("healerMonitor");
		
		//Enable Mill Upgrades
		xsEnableRule("MillUpgradeMonitor");
		xsEnableRule("MarketUpgradeMonitor");
		
		//Enable Hanami Upgrade for japanese to improve gathering strawberries
		xsEnableRule("MarketBerryDogsUpgradeMonitor");
		xsEnableRule("MarketBerryTrapsUpgradeMonitor");
		
		// Enable settler hitpoint and attack upgrades (research to be started about 3 minutes later)
		xsEnableRule("settlerUpgradeMonitor");
		
		//xsEnableRule("AICheats");
		
		findEnemyBase();  // Create a one-off explore plan to probe the likely enemy base location.
		updateForecasts();
		updateGatherers();
		updateSettlerCounts();
		
		//      kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 150.0);
		
		updateEscrows();
		
		kbEscrowAllocateCurrentResources();
		
		setUnitPickerPreference(gLandUnitPicker);
		
		gLastAttackMissionTime = xsGetTime() - 180000;     // Pretend they all fired 3 minutes ago, even if that's a negative number.
		gLastDefendMissionTime = xsGetTime() - 300000;     // Actually, start defense ratings at 100% charge, i.e. 5 minutes since last one.
		gLastClaimMissionTime = xsGetTime() - 180000;
		
		//aiEcho("*** We're in age 2.");
	}
}

//==============================================================================
// rule age3Monitor
/*
	Watch for us reaching age 3.
*/
//==============================================================================
rule age3Monitor
inactive
minInterval 10
{
	if (kbGetAge() >= cAge3)
	{
		//aiEcho("*** We're in age 3.");
		
		
		// Bump up settler train plan
		updateSettlerCounts();
		
		xsDisableSelf();
		xsEnableRule("age4Monitor");
		
		//      kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 150.0);
		
		// Increase number of towers to be built (even rushers start building now)
		if (civIsAsian() == false)
		{
			gNumTowers = gNumTowers + 3;
			if (gNumTowers > 7)
            gNumTowers = 7;
		}
		else
		{
			gNumTowers = gNumTowers + 2;
			if (gNumTowers > 5)
            gNumTowers = 5;
		}
		
		// Ottoman explorer to build an additional TC
		if ((cMyCiv == cCivOttomans) && (cvOkToBuild == true))
		{
			createSimpleBuildPlan(gTownCenter, 1, 90, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting build plan for an additional Ottoman town center");
		}
		
		//Enable Rice Paddy and Farm Upgrades  
		xsEnableRule("RicePaddyUpgradeMonitor");
		
		xsEnableRule("FarmUpgradeMonitor");
		
		// Enable basic church upgrades
		xsEnableRule("churchUpgradeMonitor");
		xsEnableRule("churchUpgradeAsianMonitor");
		
		// Enable unique church upgrades
		xsEnableRule("royalDecreeMonitor");
		
		// Enable consulate and monastery
		xsEnableRule("consulateMonitor");
		xsEnableRule("monasteryMonitor");
		
		// Enable arsenal upgrades
		xsEnableRule("arsenalUpgradeMonitor");
		xsEnableRule("arsenalUpgradeAsianMonitor");
		
		// Enable unit upgrade rules
		xsEnableRule("veteranUpgradeMonitor");
		xsEnableRule("eliteUpgradeMonitor");
		xsEnableRule("disciplinedUpgradeMonitor");
		xsEnableRule("warriorSocietyUpgradeMonitor");
		xsEnableRule("minorAsianDisciplinedUpgradeMonitor");
		
		// Enable minor tribe techs
		xsEnableRule("minorTribeTechMonitor");
		xsEnableRule("minorAsianTribeTechMonitor");
		
		// Enable navy upgrades
		xsEnableRule("navyUpgradeMonitor");
		
		// Enable agra fort upgrades for Indians
		if (kbGetCiv() == cCivIndians)
        xsEnableRule("agraFortUpgradeMonitor");
		
		// Enable summer palace tactic monitor for Chinese
		if (kbGetCiv() == cCivChinese)
        xsEnableRule("summerPalaceTacticMonitor");
		
		// Enable dojo tactic monitor for Japanese
		if (cMyCiv == cCivJapanese)
		xsEnableRule("dojoTacticMonitor");
		
		updateEscrows();
		
	}
}

//==============================================================================
// rule age4Monitor
/*
	Watch for us reaching age 4.
*/
//==============================================================================
rule age4Monitor
inactive
minInterval 10
{
	if (kbGetAge() >= cAge4)
	{
		//aiEcho("*** We're in age 4.");
		
		
		// Bump up settler train plan
		updateSettlerCounts();
		xsDisableSelf();
		
		//xsEnableRule("ironHorseMonitor");
		
		xsEnableRule("balloonMonitor");
		
		//xsEnableRule("morebanks");
		
		// Enable advanced arsenal upgrades
		xsEnableRule("advancedArsenalUpgradeMonitor");
		
		// Enable 'New Way' upgrades for Iroquois
		if (cMyCiv == cCivXPIroquois)
		xsEnableRule("newWayIroquoisMonitor");
		
		// Enable 'New Way' upgrades for Sioux
		if (cMyCiv == cCivXPSioux)
		xsEnableRule("newWaySiouxMonitor");
		
		// Enable sacred field handling for Indians
		if (cMyCiv == cCivIndians)
		xsEnableRule("sacredFieldMonitor");
		
		// Enable mansabdar maintain plans for Indians
		if (cMyCiv == cCivIndians)
		xsEnableRule("mansabdarMonitor");
		
		// Enable golden pavillion upgrades for Japanese
		if (cMyCiv == cCivJapanese)
		xsEnableRule("goldenPavillionUpgradeMonitor");
		
		// Enable shrine upgrade for Japanese
		if (cMyCiv == cCivJapanese)
		xsEnableRule("shrineUpgradeMonitor");
		
		// Enable dojo upgrade for Japanese
		if (cMyCiv == cCivJapanese)
		xsEnableRule("dojoUpgradeMonitor");
		
		// Enable unit upgrade rules
		xsEnableRule("guardUpgradeMonitor");
		xsEnableRule("royalGuardUpgradeMonitor");
		xsEnableRule("championUpgradeMonitor");
		xsEnableRule("honoredUpgradeMonitor");
		xsEnableRule("artilleryUpgradeMonitor");
		xsEnableRule("minorNativeChampionUpgradeMonitor");
		xsEnableRule("minorAsianHonoredUpgradeMonitor");
		
		// Enable fort upgrade
		xsEnableRule("fortUpgradeMonitor");
		
		//xsEnableRule("AICheatsAge4");
		
		// Enable factory upgrades and production configuration
		xsEnableRule("factoryUpgradeMonitor");
		xsEnableRule("factoryTacticMonitor");
		
		xsEnableRule("age5Monitor");
		
		//      kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 150.0);
		
		// Increase number of towers to be built (even rushers build as many as possible late in the game)
		if (civIsAsian() == false)
		{
			gNumTowers = gNumTowers + 4;
			if (gNumTowers > 7)
            gNumTowers = 7;
		}
		else
		{
			gNumTowers = gNumTowers + 3;
			if (gNumTowers > 5)
            gNumTowers = 5;
		}
		
		updateEscrows();
		
	}
}

//==============================================================================
// rule age5Monitor
/*
	Watch for us reaching age 5.
*/
//==============================================================================
rule age5Monitor
inactive
minInterval 10
{
	if (kbGetAge() >= cAge5)
	{
		//aiEcho("*** We're in age 5.");
		// Bump up settler train plan
		updateSettlerCounts();
		
		// Enable brigade technologies at the consulate
		if (civIsAsian() == true)
		xsEnableRule("brigadeMonitor");
		
		//xsEnableRule("upgradetocivilization");
		//xsEnableRule("upgradetocivilizationnative");
		// xsEnableRule("upgradetocivilizationchinese");
		// xsEnableRule("upgradetoconfederacy");
		
		xsDisableSelf();
		
		updateEscrows();
		
	}
}

//==============================================================================
// rule startFishing
//==============================================================================
rule startFishing
inactive
group tcComplete
mininterval 15
{
	//if (gFishingPlan != -1)return;
	bool givenFishingBoats = false;
	if ( (kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive) > 0) && (gWaterExploreMaintain < 0) && (gFishingPlan < 0) )
	givenFishingBoats = true;  // I have fishing boats, but no fishing or water scout plans, so they must have been given to me.
	
	if (givenFishingBoats == false)  // Skip these early-outs if we were granted free boats.
	{
		if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 1) )
		return;  // Don't burn wood before we have a bank
		if ( (kbGetCiv() == cCivOttomans) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1) )
		return;  // Don't burn wood before we have a mosque.
	}
	
	gNumFishBoats = ((btRushBoom * -1.0) + 0.7) * 5.0; // At max boom, that's 8.  At balance, it's 3.  
	if (gNumFishBoats < 2)
	{
		gNumFishBoats = 0;   // Rushers generally shouldn't fish.
	}
	if ( (cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "ceylon") || (cRandomMapName == "borneo") || (cRandomMapName == "honshu") )
	{
		if (gNumFishBoats < 3)
		gNumFishBoats = 3;   // Always fish on those maps.
	}
	
	//updatedOn 2019/04/13 By ageekhere    
	//if(kbResourceGet(cResourceWood) > 1000)
	//{ //if ai has extra resources then build max fishing boats
		gNumFishBoats = 15;
		/*
			if (civIsNative() == true)
			{
			gNumFishBoats = 20;		
			}
			else if ((kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivJapanese))
			{
			gNumFishBoats = 0;	
			}
			else if(kbGetCiv() == cCivIndians)
			{
			gNumFishBoats = 5;
			}
			else
			{
			gNumFishBoats = 15;	
			}
		*/
	//}
	
	if ( (givenFishingBoats == false) && (gNumFishBoats <= 0) )
	return;  //We weren't given any, and don't plan on making any, so quit.
	//aiEcho("StartFishing rule running.  gGoodFishingMap is "+gGoodFishingMap+", cvOkToFish is "+cvOkToFish);
	if ((cvOkToFish == true) && (gGoodFishingMap == true))
	{
		//  Check to see if we have spotted a fish reasonably close to our water spawn flag.  
		int flag = getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID);
		if (flag >= 0)
		{
			static int fishQuery = -1;
			int fish = -1;
			int fishAreaGroup = -1;
			int flagAreaGroup = -1;
			
			flagAreaGroup = kbAreaGroupGetIDByPosition(kbUnitGetPosition(flag));
			
			if (fishQuery < 0)
			{
				fishQuery=kbUnitQueryCreate("fish query");
				kbUnitQuerySetIgnoreKnockedOutUnits(fishQuery, true);
				kbUnitQuerySetPlayerID(fishQuery, 0);
				kbUnitQuerySetUnitType(fishQuery, cUnitTypeAbstractFish);
				kbUnitQuerySetState(fishQuery, cUnitStateAny);
				kbUnitQuerySetPosition(fishQuery, kbUnitGetPosition(flag));
				kbUnitQuerySetMaximumDistance(fishQuery, 100.0);
				kbUnitQuerySetAscendingSort(fishQuery, true);
			}
			kbUnitQueryResetResults(fishQuery);
			if (kbUnitQueryExecute(fishQuery) > 0)
            fish = kbUnitQueryGetResult(fishQuery, 0);   // Get the nearest fish.
			if (fish >= 0)
            fishAreaGroup = kbAreaGroupGetIDByPosition(kbUnitGetPosition(fish));
			if ( (fish >= 0) && (fishAreaGroup == flagAreaGroup) )
            aiEcho("Found fish # "+fish+" at "+kbUnitGetPosition(fish));
			else
			{
				//aiEcho("No fish found near "+kbUnitGetPosition(flag));
				return;  // No fish near enough, keep looking
			}
		}  // else, no flag, so just go ahead.
		
		if (fish < 0)
		getUnit(cUnitTypeAbstractFish, 0, cUnitStateAny);  // need to have one fish visible
		
		if (fish < 0)
		return;
		
		//aiEcho("*** Starting fishing plan. ***");
		
		if(gFishingPlan == -1) gFishingPlan = aiPlanCreate("Fishing plan", cPlanFish); 
		aiPlanSetDesiredPriority(gFishingPlan, 20);     // Very low
		aiPlanAddUnitType(gFishingPlan, gFishingUnit, 1, 10, 200); 
		aiPlanSetEscrowID(gFishingPlan, cEconomyEscrowID); 
		aiPlanSetBaseID(gFishingPlan, kbBaseGetMainID(cMyID)); 
		aiPlanSetVariableVector(gFishingPlan, cFishPlanLandPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); 
		if ( flag >= 0 )
		{
			//aiEcho("Setting fishing plan water point to "+kbUnitGetPosition(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID)) );
			aiPlanSetVariableVector(gFishingPlan, cFishPlanWaterPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID)) );
		}
		//else
		//aiEcho("Couldn't find a water spawn flag.");
		
		aiPlanSetVariableBool(gFishingPlan, cFishPlanBuildDock, 0, false);    //BHG - the ai doesn't like to fish if this is set to true
		
		aiPlanSetActive(gFishingPlan); 
		
		
		//aiEcho("*** Creating maintain plan for fishing boats.");
		if(gFishingBoatMaintainPlan == -1) gFishingBoatMaintainPlan = createSimpleMaintainPlan(gFishingUnit, gNumFishBoats, true, kbBaseGetMainID(cMyID), 1);
		
		if(gWaterExplorePlan < 0)
		{
			vector location = kbUnitGetPosition(fish);
			gWaterExplorePlan=aiPlanCreate("Water Explore", cPlanExplore);
			aiPlanSetVariableBool(gWaterExplorePlan, cExplorePlanReExploreAreas, 0, false);
			aiPlanSetInitialPosition(gWaterExplorePlan, location);
			aiPlanSetDesiredPriority(gWaterExplorePlan, 45);   // Low, so that transport plans can steal it as needed, but just above fishing plans.
			aiPlanAddUnitType(gWaterExplorePlan, gFishingUnit, 1, 1, 1);
			aiPlanSetEscrowID(gWaterExplorePlan, cEconomyEscrowID);
			aiPlanSetVariableBool(gWaterExplorePlan, cExplorePlanDoLoops, 0, false);
			aiPlanSetActive(gWaterExplorePlan);
		}
	}
	
	//	if (cvOkToFish == true)
	//	xsDisableSelf();  // Normally, disable if we get here because we're done.  
	// But if okToFish is false, keep rule active in case it gets turned true later.
}

//==============================================================================
// initEcon
/*
	Called when the initial units have disembarked.  Sets up initial economy.
*/
//==============================================================================

//==============================================================================
/* initEcon
	updatedOn 2019/11/06 By ageekhere 
*/
//==============================================================================
void initEcon(void)
{
	if ( civIsNative() == true )
	{
		gCaravelUnit = cUnitTypeCanoe;
		gGalleonUnit = cUnitTypexpWarCanoe;
		gEconUnit = cUnitTypeSettlerNative;
		gFarmUnit = cUnitTypeFarm;
		gTowerUnit = cUnitTypeWarHut;
		gBarracksUnit = cUnitTypeWarHut;
		gStableUnit = cUnitTypeCorral;
		cvOkToBuildForts = false;
	}
	
	else if ( civIsAsian() == true )
	{
		gEconUnit = cUnitTypeypSettlerAsian;
		gTowerUnit = cUnitTypeYPOutpostAsian;//cUnitTypeypCastle;
		gFarmUnit = cUnitTypeypRicePaddy;
		gPlantationUnit = cUnitTypeypRicePaddy;
		gMarketUnit = cUnitTypeypTradeMarketAsian;
		gDockUnit = cUnitTypeYPDockAsian;
		gFishingUnit = cUnitTypeypFishingBoatAsian;
		gArtilleryDepotUnit = cUnitTypeypCastle;
		cvOkToBuildForts = false;
	}
	else
	{
		gHouseUnit = cUnitTypeHouse;
		gLivestockPenUnit = cUnitTypeHouse;
	}
	
	if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) )
	{
		gHouseUnit = cUnitTypeypVillage;
		gLivestockPenUnit = cUnitTypeypVillage;
		gSpecialUnit = cUnitTypeypOldHanArmy;
		gCaravelUnit = cUnitTypeypWarJunk;
		gGalleonUnit = cUnitTypeypFuchuan;
		gBarracksUnit = cUnitTypeypWarAcademy;
		gStableUnit = cUnitTypeypWarAcademy;
	}
	
	if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) )
	{
		gEconUnit = cUnitTypeypSettlerJapanese;
		gHouseUnit = cUnitTypeypShrineJapanese;
		gLivestockPenUnit = cUnitTypeypShrineJapanese;
		gSpecialUnit = cUnitTypeypAshigaru;
		gCaravelUnit = cUnitTypeypFune;
		gGalleonUnit = cUnitTypeypAtakabune;
		gFrigateUnit = cUnitTypeypTekkousen;
		gBarracksUnit = cUnitTypeypBarracksJapanese;
		gStableUnit = cUnitTypeypStableJapanese;
	}
	
	if ( (kbGetCiv() == cCivIndians) || (kbGetCiv() == cCivSPCIndians) )
	{
		gEconUnit = cUnitTypeypSettlerIndian;
		gHouseUnit = cUnitTypeypHouseIndian;
		gLivestockPenUnit = cUnitTypeypSacredField;
		gSpecialUnit = cUnitTypeypSepoy;
		gCaravelUnit = cUnitTypeypWokouJunkI;
		gBarracksUnit = cUnitTypeYPBarracksIndian;
		gStableUnit = cUnitTypeypCaravanserai;
	}
	
	//if ( (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivXPSPC) || (kbGetCiv() == cCivSPCAct3) )
	if ( (kbGetCiv() == cCivBritish) || (kbGetCiv() == cCivXPSPC))
	{
		gHouseUnit = cUnitTypeManor;
		gLivestockPenUnit = cUnitTypeManor;
	}
	
	if ( (kbGetCiv() == cCivFrench)|| (kbGetCiv() == cCivDutch) )
	{
		gHouseUnit = cUnitTypeHouse;
		gLivestockPenUnit = cUnitTypeHouse;
	}
	
	if ( (kbGetCiv() == cCivGermans) || (kbGetCiv() == cCivTheCircle) || (kbGetCiv() == cCivRussians) )
	{
		gHouseUnit = cUnitTypeHouseEast;
		gLivestockPenUnit = cUnitTypeHouseEast;
	}
	
	if ( (kbGetCiv() == cCivSpanish) || (kbGetCiv() == cCivPortuguese) || (kbGetCiv() == cCivOttomans) || (kbGetCiv() == cCivMaltese) || (kbGetCiv() == cCivColombians) )
	{
		gHouseUnit = cUnitTypeHouseMed;
		gLivestockPenUnit = cUnitTypeHouseMed;
	}
	
	
	if ( kbGetCiv() == cCivXPIroquois )
	{
		gHouseUnit = cUnitTypeLonghouse;
		gSpecialUnit = cUnitTypexpTomahawk;
	}
	
	if ( kbGetCiv() == cCivXPAztec )
	{
		gHouseUnit = cUnitTypeHouseAztec;
		gSpecialUnit = cUnitTypexpMacehualtin;
		gFrigateUnit = cUnitTypexpTlalocCanoe;
		gLivestockPenUnit = gFarmUnit;
		gStableUnit = cUnitTypeNoblesHut;
		gArtilleryDepotUnit = cUnitTypeNoblesHut;
	}
	
	if ( kbGetCiv() == cCivXPSioux )
	{
		gHouseUnit = cUnitTypeTeepee;
		gSpecialUnit = cUnitTypexpWarBow;
	}
	
	if (kbGetCiv() == cCivFrench)
	{
		gEconUnit = cUnitTypeCoureur;
		gSpecialUnit = cUnitTypeSkirmisher;
	}
	
	if (kbGetCiv() == cCivRussians)
	{
		gTowerUnit = cUnitTypeBlockhouse;
		gSpecialUnit = cUnitTypeStrelet;
		gBarracksUnit = cUnitTypeBlockhouse;
	}
	
	if (kbGetCiv() == cCivOttomans)
	{
		gCaravelUnit = cUnitTypeGalley;
		gSpecialUnit = cUnitTypeJanissary;
	}
	
	if (kbGetCiv() == cCivDutch)
	{
		gGalleonUnit = cUnitTypeFluyt;
		gSpecialUnit = cUnitTypeSchutze;
	}
	
	if (kbGetCiv() == cCivSwedish)
	{
		gHouseUnit = cUnitTypeHouseTorp;
		gLivestockPenUnit = cUnitTypeHouseTorp;
		gEconUnit = cUnitTypeSettlerSwedish;
		gSpecialUnit = cUnitTypeSharpshooterS;
	}
	
	if (kbGetCiv() == cCivItalians)
	{
		gHouseUnit = cUnitTypeHouseVilla;
		gLivestockPenUnit = cUnitTypeHouseVilla;
		gSpecialUnit = cUnitTypeCrossbowman;
	}
	
	if (kbGetCiv() == cCivPortuguese)
	{
		gSpecialUnit = cUnitTypeCacadore;
	}
	
	if (kbGetCiv() == cCivUSA)
	{
		gSpecialUnit = cUnitTypeMarine;
		gGalleonUnit = cUnitTypeSteamShip;
	}

	if (kbGetCiv() == cCivColombians)
	{
		gGalleonUnit = cUnitTypeSteamShip;
	}
	
    
	
	// Escrow initialization is now delayed until the TC is built, as
	// any escrow allocation prevents the AI from affording a TC.
	// For now, though, override the default and set econ/mil to 0
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, 0.0);
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, 0.0);   
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, 0.0);
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceFame, 0.0);
	
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, 0.0);
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, 0.0);  
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, 0.0);
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFame, 0.0);
	
	kbEscrowAllocateCurrentResources();
	aiSetEconomyPercentage(1.0);
	aiSetMilitaryPercentage(1.0);    // Priority balance neutral  
	xsEnableRuleGroup("startup");
	econMaster(); //Lastly, force an update on the economy...call the function directly.
}

//==============================================================================
//
// updatePrices
// 
// This function compares actual supply vs. forecast, updates AICost 
// values (internal resource prices), and buys/sells at the market as appropriate
//==============================================================================
void updatePrices()
{
	// check for valid forecasts, exit if not ready
	if ( (xsArrayGetFloat(gForecasts,0) + xsArrayGetFloat(gForecasts,1) + xsArrayGetFloat(gForecasts,2) ) < 100 )
	return; 
	
	float scaleFactor = 3.0;      // Higher values make prices more volatile
	// Commentary on scale factor.  A factor of 1.0 compares inventory of resources against the full 3-minute forecast.  A scale of 10.0
	// compares inventory to 1/10th of the forecast.  A large scale makes prices more volatile, encourages faster and more frequent trading at lower threshholds, etc.
	float goldStatus = 0.0;
	float woodStatus = 0.0;
	float foodStatus = 0.0;
	float minForecast = 200.0 * (1+kbGetAge());	// 200, 400, 600, 800 in ages 1-4, prevents small amount from looking large if forecast is very low
	if (xsArrayGetFloat(gForecasts,cResourceGold) > minForecast)
	goldStatus = scaleFactor * kbResourceGet(cResourceGold)/xsArrayGetFloat(gForecasts,cResourceGold);
	else
	goldStatus = scaleFactor * kbResourceGet(cResourceGold)/minForecast;
	if (xsArrayGetFloat(gForecasts,cResourceFood) > minForecast)
	foodStatus = scaleFactor * kbResourceGet(cResourceFood)/xsArrayGetFloat(gForecasts,cResourceFood);
	else
	foodStatus = scaleFactor * kbResourceGet(cResourceFood)/minForecast;
	if (xsArrayGetFloat(gForecasts,cResourceWood) > minForecast)
	woodStatus = scaleFactor * kbResourceGet(cResourceWood)/xsArrayGetFloat(gForecasts,cResourceWood);
	else
	woodStatus = scaleFactor * kbResourceGet(cResourceWood)/minForecast;
	
	// Status now equals inventory/forecast
	// Calculate value rate of wood:gold and food:gold.  1.0 means they're of the same status, 2.0 means 
	// that the resource is one forecast more scarce, 0.5 means one forecast more plentiful, i.e. lower value.
	float woodRate = (1.0 + goldStatus)/(1.0 + woodStatus);
	woodRate = woodRate * 1.2; // Because wood is more expensive to gather
	float foodRate = (1.0 + goldStatus)/(1.0 + foodStatus);
	
	// The rates are now the instantaneous price for each resource.  Set the long-term prices by averaging this in
	// at a 5% weight.
	float cost = 0.0;
	
	// wood
	cost = kbGetAICostWeight(cResourceWood);
	cost = (cost * 0.95) + (woodRate * .05);
	kbSetAICostWeight(cResourceWood, cost);
	
	// food
	cost = kbGetAICostWeight(cResourceFood);
	cost = (cost * 0.95) + (foodRate * .05);
	kbSetAICostWeight(cResourceFood, cost);
	
	// Gold
	kbSetAICostWeight(cResourceGold, 1.00);	// gold always 1.0, others relative to gold
}

//==============================================================================
// spewForecasts
//==============================================================================
void spewForecasts()
{  // Debug aid, dump forecast contents
	int gold = xsArrayGetFloat(gForecasts, cResourceGold);
	int wood = xsArrayGetFloat(gForecasts, cResourceWood);
	int food = xsArrayGetFloat(gForecasts, cResourceFood);
	
	//aiEcho("Forecast Gold: "+gold+", Wood: "+wood+", Food: "+food);
	//aiEcho("Prices   Gold: "+kbGetAICostWeight(cResourceGold)+", Wood: "+kbGetAICostWeight(cResourceWood)+", Food: "+kbGetAICostWeight(cResourceFood));
}



//==============================================================================
// addTechToForecasts
//==============================================================================
void addTechToForecasts(int techID = -1)
{
	// Add cost of this tech to the global forecast arrays
	if (techID < 0)
	return;
	int i=0;
	for (i=0; <3)  // Step through first three resources
	{
		xsArraySetFloat(gForecasts, i, xsArrayGetFloat(gForecasts, i) + kbTechCostPerResource(techID, i));
	}  
	//aiEcho("    "+kbGetTechName(techID));
	//spewForecasts();
}

//==============================================================================
// clearForecasts
//==============================================================================
void clearForecasts()
{
	// Clear the global forecast arrays
	int i=0;
	for(i=0; <3)
	{
		xsArraySetFloat(gForecasts, i, 0.0);
	}
	//aiEcho("******** Clearing forecasts");
}

//==============================================================================
// updateForecasts
/*
	Create 3-minute forecast of resource needs for food, wood and gold
*/
//==============================================================================
void updateForecasts()
{
	int i=0;
	int militaryUnit = -1;
	int milQty = -1;
	int popSlots = -1;
	
	int effectiveAge = kbGetAge();
	if ( agingUp() == true )
	effectiveAge = effectiveAge + 1;
	
	int numUnits = 0; // Temp var used to track how many of each item will be needed
	
	clearForecasts(); // Reset all to zero
	//aiEcho("Starting forecast.  Items included:");
	
	int millsNeeded = 1 + ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive)*0.5) / cMaxSettlersPerMill);        // Enough for 50% of population, rough value for forecast
	int plantsNeeded = 1 + ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive)*0.4) / cMaxSettlersPerPlantation); // Enough for 40% of population, rough value for forecast
	int paddiesNeeded = 1 + ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive)*0.9) / cMaxSettlersPerMill);      // Enough for 90% of population for both food and coin, rough value for forecast
	
	if (civIsAsian() == false)
	{
		millsNeeded = millsNeeded - kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ);
		if ( (gTimeToFarm == true) && (millsNeeded > 0) )
		addItemToForecasts(gFarmUnit, millsNeeded);
		
		plantsNeeded = plantsNeeded - kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ);
		if ( (plantsNeeded > 0) && (effectiveAge > cAge2) && (gTimeForPlantations == true) )
		addItemToForecasts(gPlantationUnit, plantsNeeded);
	}
	else
	{
		if ( (gTimeToFarm == true) && (effectiveAge > cAge2) && (gTimeForPlantations == true) )  // Paddies needed for both food and coin 
		{
			paddiesNeeded = paddiesNeeded - kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ);
			if (paddiesNeeded > 0)
            addItemToForecasts(gFarmUnit, paddiesNeeded);
		}
		else if ( (gTimeToFarm == true) && ((effectiveAge < cAge3) || (gTimeForPlantations == false)) )  // Paddies needed for food only
		{
			millsNeeded = millsNeeded - kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ);
			if (millsNeeded > 0)
            addItemToForecasts(gFarmUnit, millsNeeded);
		}
		else if ( (gTimeToFarm == false) && (effectiveAge > cAge2) && (gTimeForPlantations == true) )  // Paddies needed for coin only
		{
			plantsNeeded = plantsNeeded - kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ);
			if (plantsNeeded > 0)
            addItemToForecasts(gPlantationUnit, plantsNeeded);
		}
	}
	
	
	int fishBoats = 0;
	if (gFishingBoatMaintainPlan >= 0)
	{
		fishBoats = aiPlanGetVariableInt(gFishingBoatMaintainPlan, cTrainPlanNumberToMaintain, 0) - kbUnitCount(cMyID, gFishingUnit, cUnitStateABQ);
		if (kbUnitCount(cMyID, gDockUnit, cUnitStateABQ) < 1)
		addItemToForecasts(gDockUnit, 1);
	}
	if (fishBoats > 3)
	fishBoats = 3;
	
	if (fishBoats > 0)
	addItemToForecasts(gFishingUnit, fishBoats);
	
	
	
	
	switch(kbGetAge())
	{
		case cAge1:
		{
			// Settlers
			if (cMyCiv != cCivOttomans)   // Ottomans get them free
			{
				numUnits = xsArrayGetInt(gTargetSettlerCounts, effectiveAge) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
				if (numUnits < 5) 
				numUnits = 5;  // We'll need some next age, anyway.
				if (numUnits > 10)
				numUnits = 10;
				addItemToForecasts(gEconUnit, numUnits);
			}
			
			// Age upgrade
			if ( agingUp() != true )
			{
				if (civIsAsian() == false)
				{
					addTechToForecasts(aiGetPoliticianListByIndex(cAge2, 0));
					addTechToForecasts(aiGetPoliticianListByIndex(cAge2, 0));   // Add it again to make the age 3 upgrade more reliable.
				}
				else
				{
					addItemToForecasts(getPreferredWonderToBuild(cAge2), 1);
					addItemToForecasts(getPreferredWonderToBuild(cAge2), 1);   // Add it again to make the age 3 upgrade more reliable.
				}
			}
			
			// 3 houses, to overweight them and force early wood gathering
			if (cMyCiv != cCivXPSioux)
            addItemToForecasts(gHouseUnit, 3);
			
			// Ottoman - mosque and tech
			if (cMyCiv == cCivOttomans)
			{
				if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeChurch, 1);
				if ( (kbTechGetStatus(cTechChurchMilletSystem) == cTechStatusObtainable) || (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) == 0) )
				{
					addTechToForecasts(cTechChurchMilletSystem);
				}
				if ( (kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusObtainable) || (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) == 0) )
				{
					addTechToForecasts(cTechChurchGalataTowerDistrict);
				}
			}
			
			// Dutch - one bank
			if (cMyCiv == cCivDutch)
			{
				if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeBank, 1 - kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ));
			}
			
			if (gBuildWalls == true)   // Add 500 wood if we're making walls
            xsArraySetInt(gForecasts, cResourceWood, 500 + xsArrayGetInt(gForecasts, cResourceWood));
			
			// Check towers
			if ( (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) > 9) )
			{
				if (cMyCiv != cCivXPAztec)
				addItemToForecasts(gTowerUnit, gNumTowers - kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ)); 
			}
			
			break;
		}
		case cAge2:
		{
			// Add a baseline just to make sure we don't get any near-zero resource amounts
			xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 300.0);
			xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 300.0);
			xsArraySetFloat(gForecasts, cResourceGold, xsArrayGetFloat(gForecasts, cResourceGold) + 300.0);
			
			// Settlers
			if (cMyCiv != cCivOttomans)   // Ottomans get them free
			{
				numUnits = xsArrayGetInt(gTargetSettlerCounts, effectiveAge) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
				if (numUnits < 5) 
				numUnits = 5;  // We'll need some next age, anyway.
				if (numUnits > 12)
				numUnits = 12;
				addItemToForecasts(gEconUnit, numUnits);
			}
			
			// Age upgrade
			if (agingUp() != true )  
			{
				if (civIsAsian() == false)
				{
					addTechToForecasts(aiGetPoliticianListByIndex(cAge3, 0));
					if (gSPC == false)
					addTechToForecasts(aiGetPoliticianListByIndex(cAge3, 0));   // Add it again to make the age 3 upgrade more reliable.
				}
				else 
				{
					addItemToForecasts(getPreferredWonderToBuild(cAge3), 1);
					if (gSPC == false)
					addItemToForecasts(getPreferredWonderToBuild(cAge3), 1);   // Add it again to make the age 3 upgrade more reliable.
				}
			}
			// 3 houses, to overweight them and force early wood gathering
			if (cMyCiv != cCivXPSioux)
            addItemToForecasts(gHouseUnit, 5);
			
			// Ottoman - mosque and techs
			if (cMyCiv == cCivOttomans)
			{
				if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeChurch, 1);
				if (kbTechGetStatus(cTechChurchKopruluViziers) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchKopruluViziers);
				}
				if (kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchGalataTowerDistrict);
				}
			}
			
			// Ships for water maps
			if (gNavyMode == cNavyModeActive)
			{
				if (civIsNative() == false)
				{
					if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < 2)
					addItemToForecasts(gCaravelUnit, 2 - kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive));
					if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < 1)
					addItemToForecasts(gGalleonUnit, 1 - kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive));
				}
				else
				{
					if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < 4)
					addItemToForecasts(gCaravelUnit, 2 - kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive));
				}
			}
			
			// Chinese - first village upgrade
			if (cMyCiv == cCivChinese)
			{
				if (kbTechGetStatus(cTechypVillagePopCapIncrease) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypVillagePopCapIncrease);
				}
			}
			
			// Dutch - two banks
			if (cMyCiv == cCivDutch)
			{
				if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 2)
				addItemToForecasts(cUnitTypeBank, 2 - kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ));
			}
			
			// Natives - one fire pit
			if (civIsNative() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeFirePit, 1);
			}
			
			// 1 barracks, blockhouse or war hut
			
			if ( (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) + 
			kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ) ) < 2)
            addItemToForecasts(cUnitTypeBarracks, 2);
			
			// One stable or corral (not for Chinese)
			if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
			{
				if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
					kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
					kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 1)
				addItemToForecasts(cUnitTypeStable, 1);
			}
			
			// One market
			if (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1)
            addItemToForecasts(gMarketUnit, 1);
			
			// One town center
			if (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1)
            addItemToForecasts(gTownCenter, 1);
			
			// Europeans - one saloon
			if ((civIsNative() == false) && (civIsAsian() == false))
			{
				if (kbUnitCount(cMyID, cUnitTypeSPCFortCenter, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeSPCFortCenter, 1);
			}
			
			// Natives - embassy
			if (civIsNative() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeNativeEmbassy, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeNativeEmbassy, 1);
			}
			
			// Add 15 pop slots of primary military unit
			//aiEcho("And the primary military unit is: "+kbUnitPickGetResult( gLandUnitPicker, 0));
			if (gLandUnitPicker >= 0)
            militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 0);
			
			if (militaryUnit >= 0)
			{
				//aiEcho("And the unit we're forcasting is: "+kbGetProtoUnitName(militaryUnit));
				popSlots = kbGetPopSlots(cMyID, militaryUnit);
				if (popSlots < 1)
				popSlots = 1;
				milQty = 15 / popSlots; 
				addItemToForecasts(militaryUnit, milQty);
			}            
			else
			{
				xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 1000.0);
				xsArraySetInt(gForecasts, cResourceFood, xsArrayGetInt(gForecasts, cResourceFood) + 1000.0);
			}
			
			// Natives and Asians - add 500 gold for allies (enough for one Age 2 shipment, used as reserve if none are available)
			if ((civIsNative() == true) || (civIsAsian() == true))
			{
				xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 500.0);
			}
			
			// And a bit extra wood, since running out is so painful...
			xsArraySetInt(gForecasts, cResourceWood, 800 + xsArrayGetInt(gForecasts, cResourceWood));
			
			// Check towers
			if (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers)
			{
				if (cMyCiv != cCivXPAztec)
				addItemToForecasts(gTowerUnit, gNumTowers - kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ)); 
			}
			
			// While aging up, add wood for additional Ottoman town center in Age 3
			if ((cMyCiv == cCivOttomans) && (agingUp() == true))
			{            
				addItemToForecasts(gTownCenter, 1);
			}
			
			break;
		}
		case cAge3:
		{
			// Add a baseline just to make sure we don't get any near-zero resource amounts
			xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 300.0);
			xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 300.0);
			xsArraySetFloat(gForecasts, cResourceGold, xsArrayGetFloat(gForecasts, cResourceGold) + 300.0);
			
			// Settlers
			if (cMyCiv != cCivOttomans)   // Ottomans get them free
			{
				numUnits = xsArrayGetInt(gTargetSettlerCounts, effectiveAge) - kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
				if (numUnits > 10)
				numUnits = 10;
				addItemToForecasts(gEconUnit, numUnits);
			}
			
			// Age upgrade
			if (agingUp() != true )     
			{
				if (civIsAsian() == false)
				{
					addTechToForecasts(aiGetPoliticianListByIndex(cAge4, 0));
				}
				else
				{
					addItemToForecasts(getPreferredWonderToBuild(cAge4), 1);
				}
			}
			
			// 3 houses
			if (cMyCiv != cCivXPSioux)
            addItemToForecasts(gHouseUnit, 5);
			
			// Ships and navy techs for water maps
			if (gNavyMode == cNavyModeActive)
			{
				if(civIsNative() == false)
				{
					if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < 3)
					addItemToForecasts(gCaravelUnit, 3 - kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive));
					if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < 1)
					addItemToForecasts(gGalleonUnit, 1 - kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive));
					if ((kbGetCiv() != cCivChinese) && (kbGetCiv() != cCivSPCChinese))
					{
						if (kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive) < 1)
						addItemToForecasts(gFrigateUnit, 1 - kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive));
					}
					if (kbTechGetStatus(cTechCarronade) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechCarronade);
					}
					if (kbTechGetStatus(cTechArmorPlating) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechArmorPlating);
					}
				}
				else
				{
					if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < 4)
					addItemToForecasts(gCaravelUnit, 3 - kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive));
					if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < 2)
					addItemToForecasts(gGalleonUnit, 1 - kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive));
				}
			}
			
			// Ottoman - mosque and techs
			if (cMyCiv == cCivOttomans)
			{
				if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeChurch, 1);
				if (kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchAbbassidMarket);
				}
				if (kbTechGetStatus(cTechChurchTopkapi) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchTopkapi);
				}
				if (kbTechGetStatus(cTechChurchTanzimat) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchTanzimat);
				}
			}
			else if ((civIsNative() == false) && (civIsAsian() == false))  // Other non-native/non-Asian civs - just the church
			{
				if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeChurch, 1);   
			}
			
			// Asians - one monastery
			if ((civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeypMonastery, 1);
			
			// Basic church upgrades (not for natives or Asians)
			if ((civIsNative() == false) && (civIsAsian() == false))  
			{
				if (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchGasLighting);
				}
				if (kbTechGetStatus(cTechChurchTownWatch) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchTownWatch);
				}
			}
			
			// Unique church upgrades and troops
			switch(kbGetCiv())
			{
				case cCivBritish:
				{
					if (kbTechGetStatus(cTechChurchBlackWatch) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchBlackWatch);
					}
					break;
				}
				case cCivDutch:
				{
					if (kbTechGetStatus(cTechChurchWaardgelders) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchWaardgelders);
					}
					break;
				}
				case cCivFrench:
				{
					if (kbTechGetStatus(cTechChurchGardeImperial1) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchGardeImperial1);
					}
					if (kbTechGetStatus(cTechChurchGardeImperial2) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchGardeImperial2);
					}
					break;
				}
				case cCivGermans:
				{
					break; // no tech researched in Age 3
				}
				case cCivOttomans:
				{
					if (kbTechGetStatus(cTechChurchTufanciCorps) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchTufanciCorps);
					}
					break;
				}
				case cCivPortuguese:
				{
					if (kbTechGetStatus(cTechChurchBestieros) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchBestieros);
					}
					break;
				}
				case cCivRussians:
				{
					if (kbTechGetStatus(cTechChurchWesternization) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchWesternization);
					}
					if (kbTechGetStatus(cTechChurchKalmucks) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchKalmucks);
					}
					break;
				}
				case cCivSpanish:
				{
					if (kbTechGetStatus(cTechChurchQuatrefage) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchQuatrefage);
					}
					break;
				}
			}
			
			// Tower upgrades (provided there are enough around)
			if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) >= 3)
			{
				if ((civIsNative() == false) && (civIsAsian() == false) && (cMyCiv != cCivRussians))
				{
					if (kbTechGetStatus(cTechFrontierOutpost) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechFrontierOutpost);
					}
				}
				else if (cMyCiv == cCivRussians)
				{
					if (kbTechGetStatus(cTechFrontierBlockhouse) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechFrontierBlockhouse);
					}
				}
				else if (civIsAsian() == true)
				{
					if (kbTechGetStatus(cTechypFrontierCastle) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechypFrontierCastle);
					}
				}
				else if (cMyCiv == cCivXPIroquois)
				{
					if (kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechStrongWarHut);
					}
				}
				else if (cMyCiv == cCivXPAztec)
				{
					if (kbTechGetStatus(cTechStrongNoblesHut) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechStrongNoblesHut);
					}
				}
			}
			
			// Aztec warhut upgrades (provided there are enough around)
			if ((cMyCiv == cCivXPAztec) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 3))
			{
				if (kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechStrongWarHut);
				}
			}
			
			// Age 3 agra fort upgrade (provided there is one)
			if ((kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0) ||
				(kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0) ||
				(kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0) ||
			(kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0))
			{
				if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypFrontierAgra);
				}
			}
			
			// Chinese - second village upgrade
			if (cMyCiv == cCivChinese)
			{
				if (kbTechGetStatus(cTechypVillagePopCapIncrease2) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypVillagePopCapIncrease2);
				}
			}
			
			// Dutch - 3 banks
			if (cMyCiv == cCivDutch)
			{
				if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 3)
				addItemToForecasts(cUnitTypeBank, 3 - kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ));
			}
			
			// Natives - one fire pit
			if (civIsNative() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeFirePit, 1);
			}
			
			// Asians - one consulate
			if (civIsAsian() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeypConsulate, 1);
			}
			
			// 1 barracks, blockhouse or war hut
			if ( (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) + 
			kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ) ) < 3)
            addItemToForecasts(cUnitTypeBarracks, 3);
			
			// One stable, corral or caravanserai (not for Chinese)
			if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
			{
				if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
					kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
					kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 2)
				addItemToForecasts(cUnitTypeStable, 2);
			}
			
			// 1 artillery depot (not for Aztecs, Sioux or Asians)
			if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
			{
				if (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 2)
				addItemToForecasts(cUnitTypeArtilleryDepot, 2);  
			}
			
			// One castle for Asians
			if (civIsAsian() == true) 
			{
				if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ) < 2)
				addItemToForecasts(cUnitTypeypCastle, 2);  
			}
			
			// One market
			if (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1)
            addItemToForecasts(gMarketUnit, 1);
			
			// Europeans - one saloon
			if ((civIsNative() == false) && (civIsAsian() == false))
			{
				if (kbUnitCount(cMyID, cUnitTypeSPCFortCenter, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeSPCFortCenter, 1);
			}
			
			// Natives - embassy
			if (civIsNative() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeNativeEmbassy, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeNativeEmbassy, 1);
			}
			
			// One town center
			if (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1)
            addItemToForecasts(gTownCenter, 1);
			
			// Add 20 pop slots of primary military unit
			if (gLandUnitPicker >= 0)
			{
				militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 0);
				if (militaryUnit >= 0)
				{
					popSlots = kbGetPopSlots(cMyID, militaryUnit);
					if (popSlots < 1)
					popSlots = 1;
					milQty = 20 / popSlots; 
					addItemToForecasts(militaryUnit, milQty);
				}          
				else
				{
					xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 1500.0);
					xsArraySetInt(gForecasts, cResourceFood, xsArrayGetInt(gForecasts, cResourceFood) + 1500.0);
				}
				
				// Add 10 pop slots of secondary military unit
				if (kbUnitPickGetNumberResults(gLandUnitPicker) > 1)
				{
					militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 1);
					if (militaryUnit >= 0)
					{
						popSlots = kbGetPopSlots(cMyID, militaryUnit);
						if (popSlots < 1)
						popSlots = 1;
						milQty = 10 / popSlots; 
						addItemToForecasts(militaryUnit, milQty);
					} 
				}
			}
			
			// Add enough gold and wood for a veteran/elite/disciplined unit upgrade
			if ((civIsNative() == false) && (civIsAsian() == false)) // veteran upgrade
			{
				xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 200.0);
				xsArraySetInt(gForecasts, cResourceWood, xsArrayGetInt(gForecasts, cResourceWood) + 200.0);
			}
			else // elite or disciplined upgrade
			{
				xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 100.0);
				xsArraySetInt(gForecasts, cResourceWood, xsArrayGetInt(gForecasts, cResourceWood) + 200.0);
			}
			
			// Add 1000 gold for mercenaries/allies/support (enough for one Age 3 or two Age 2 shipments, used as reserve if none are available)
			xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 1000.0);
			
			// Check towers
			if (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers)
            addItemToForecasts(gTowerUnit, gNumTowers - kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ)); 
			
			break;
		}
		case cAge4:
		{
			// Add a baseline just to make sure we don't get any near-zero resource amounts
			xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 400.0);
			xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 400.0);
			xsArraySetFloat(gForecasts, cResourceGold, xsArrayGetFloat(gForecasts, cResourceGold) + 400.0);
			
			// Settlers
			if (cMyCiv != cCivOttomans)   // Ottomans get them free
			{
				numUnits = 10;
				addItemToForecasts(gEconUnit, numUnits);
			}
			
			// Age upgrade
			//if ( getSettlerShortfall() < 10 )   // Nearing age-up point.
			if (agingUp() != true )    
			{            
				if (civIsAsian() == false) 
				{
					addTechToForecasts(aiGetPoliticianListByIndex(cAge5, 0));
				}
				else 
				{
					addItemToForecasts(getPreferredWonderToBuild(cAge5), 1);
				}
			}
			
			// 3 houses
			if (cMyCiv != cCivXPSioux)
            addItemToForecasts(gHouseUnit, 5);
			
			// Ships and navy techs for water maps
			if (gNavyMode == cNavyModeActive)
			{
				if(civIsNative() == false)
				{
					if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < 4)
					addItemToForecasts(gCaravelUnit, 4 - kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive));
					if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < 1)
					addItemToForecasts(gGalleonUnit, 1 - kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive));
					if ((kbGetCiv() != cCivChinese) && (kbGetCiv() != cCivSPCChinese))
					{
						if (kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive) < 1)
						addItemToForecasts(gFrigateUnit, 1 - kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive));
					}
					if (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) < 1)
					addItemToForecasts(cUnitTypeMonitor, 1 - kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive));
					if (kbTechGetStatus(cTechShipHowitzers) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechShipHowitzers);
					}
				}
				else
				{
					if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < 6)
					addItemToForecasts(gCaravelUnit, 3 - kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive));
					if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < 6)
					addItemToForecasts(gGalleonUnit, 1 - kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive));
				}
			}
			
			// Mosque or church (not for natives or Asians)
			if ((civIsNative() == false) && (civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeChurch, 1);   
			
			// Asians - one monastery
			if ((civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeypMonastery, 1);
			
			// Basic church upgrades (not for natives or Asians)
			if ((civIsNative() == false) && (civIsAsian() == false))
			{
				if (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchStandingArmy);
				}
				if (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechChurchMassCavalry);
				}
			}
			
			// Unique church upgrades and troops
			switch(kbGetCiv())
			{
				case cCivBritish:
				{
					if (kbTechGetStatus(cTechChurchRogersRangers) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchRogersRangers);
					}
					break;
				}
				case cCivDutch:
				{
					if (kbTechGetStatus(cTechChurchStadholders) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchStadholders);
					}
					break;
				}
				case cCivFrench:
				{
					if (kbTechGetStatus(cTechChurchGardeImperial3) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchGardeImperial3);
					}
					break;
				}
				case cCivGermans:
				{
					if (kbTechGetStatus(cTechChurchZweihander) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchZweihander);
					}
					break;
				}
				case cCivOttomans:
				{
					if (kbTechGetStatus(cTechChurchTopcuCorps) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchTopcuCorps);
					}
					break;
				}
				case cCivPortuguese:
				{
					if (kbTechGetStatus(cTechChurchTowerAndSword) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchTowerAndSword);
					}
					break;
				}
				case cCivRussians:
				{
					if (kbTechGetStatus(cTechChurchPetrineReforms) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchPetrineReforms);
					}
					if (kbTechGetStatus(cTechChurchBashkirPonies) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchBashkirPonies);
					}
					break;
				}
				case cCivSpanish:
				{
					if (kbTechGetStatus(cTechChurchWildGeeseSpanish) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechChurchWildGeeseSpanish);
					}
					break;
				}
			}
			
			// Factory upgrades (provided there is at least one)
			if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0)  
			{
				if (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechFactoryMassProduction);
				}
			}
			if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 1)  
			{
				if (kbTechGetStatus(cTechFactorySteamPower) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechFactorySteamPower);
				}
			}
			
			// Fort upgrades (provided there is one)
			if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) > 0)  
			{
				if (kbTechGetStatus(cTechRevetment) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechRevetment);
				}
				if (kbTechGetStatus(cTechStarFort) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechStarFort);
				}
			}
			
			// Tower upgrades (provided there are enough around)
			if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) >= 3)
			{
				if ((civIsNative() == false) && (civIsAsian() == false) && (cMyCiv != cCivRussians))
				{
					if (kbTechGetStatus(cTechFrontierOutpost) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechFrontierOutpost);
					}
				}
				else if (cMyCiv == cCivRussians)
				{
					if (kbTechGetStatus(cTechFrontierBlockhouse) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechFrontierBlockhouse);
					}
				}
				else if (civIsAsian() == true)
				{
					if (kbTechGetStatus(cTechypFrontierCastle) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechypFrontierCastle);
					}
				}
				else if (cMyCiv == cCivXPIroquois)
				{
					if (kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechStrongWarHut);
					}
				}
				else if (cMyCiv == cCivXPAztec)
				{
					if (kbTechGetStatus(cTechStrongNoblesHut) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechStrongNoblesHut);
					}
				}
			}
			if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) >= 5)
			{
				if ((civIsNative() == false) && (civIsAsian() == false) && (cMyCiv != cCivRussians))
				{
					if (kbTechGetStatus(cTechFortifiedOutpost) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechFortifiedOutpost);
					}
				}
				else if (cMyCiv == cCivRussians)
				{
					if (kbTechGetStatus(cTechFortifiedBlockhouse) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechFortifiedBlockhouse);
					}
				}
				else if (civIsAsian() == true)
				{
					if (kbTechGetStatus(cTechypFortifiedCastle) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechypFortifiedCastle);
					}
				}
				else if (cMyCiv == cCivXPIroquois)
				{
					if (kbTechGetStatus(cTechMightyWarHut) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechMightyWarHut);
					}
				}
				else if (cMyCiv == cCivXPAztec)
				{
					if (kbTechGetStatus(cTechMightyNoblesHut) == cTechStatusObtainable)
					{
						addTechToForecasts(cTechMightyNoblesHut);
					}
				}
			}
			
			// Aztec warhut upgrades (provided there are enough around)
			if ((cMyCiv == cCivXPAztec) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 3))
			{
				if (kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechStrongWarHut);
				}
			}
			if ((cMyCiv == cCivXPAztec) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) >= 5))
			{
				if (kbTechGetStatus(cTechMightyWarHut) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechMightyWarHut);
				}
			}
			
			// Agra fort upgrades (provided there is one)
			if ((kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0) ||
				(kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0) ||
				(kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0) ||
			(kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0))
			{
				if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypFrontierAgra);
				}
				if (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypFortifiedAgra);
				}
			}
			
			// Japanese - dojo upgrade (provided there is one)
			if ((cMyCiv == cCivJapanese) && (kbUnitCount(cMyID, cUnitTypeypDojo, cUnitStateAlive) > 0))
			{
				if (kbTechGetStatus(cTechypDojoUpgrade1) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypDojoUpgrade1);
				}
			}
			
			// Japanese - shrine upgrade (provided there are enough around)
			if (cMyCiv == cCivJapanese)
			{
				if ((kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine2, cUnitStateAlive) > 0) ||
					(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine3, cUnitStateAlive) > 0) ||
					(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine4, cUnitStateAlive) > 0) ||
				(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine5, cUnitStateAlive) > 0))
				{
					if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) >= 10) &&
					(kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable))
					{
						addTechToForecasts(cTechypShrineFortressUpgrade);
					}
				}
				else if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) >= 16) &&
				(kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable))
				{
					addTechToForecasts(cTechypShrineFortressUpgrade);
				}
			}
			
			// Indians - sacred field upgrade (provided there is one)
			if ((cMyCiv == cCivIndians) && (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive) > 0))
			{
				if (kbTechGetStatus(cTechypLivestockHoliness) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypLivestockHoliness);
				}
			}
			
			// Chinese - third village upgrade
			if (cMyCiv == cCivChinese)
			{
				if (kbTechGetStatus(cTechypVillagePopCapIncrease3) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypVillagePopCapIncrease3);
				}
			}
			
			// Dutch - 6 banks (including those made available by the coffee trade tech)
			if (cMyCiv == cCivDutch)
			{
				if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 6)
				addItemToForecasts(cUnitTypeBank, 6 - kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ));
			} 
			
			// Natives - one fire pit
			if (civIsNative() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeFirePit, 1);
			}
			
			// Asians - one consulate
			if (civIsAsian() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeypConsulate, 1);
			}
			
			// 2 barracks, blockhouses or war huts
			if ( (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) + 
			kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ) ) < 4)
            addItemToForecasts(cUnitTypeBarracks, 4 - kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ));
			
			// 1 additional war hut for Aztecs (3 in total)
			if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 3)
            addItemToForecasts(cUnitTypeWarHut, 3);
			
			// 2 stables, corrals or caravanserais(not for Chinese)
			if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
			{
				if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
					kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
					kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 3)
				addItemToForecasts(cUnitTypeStable, 3 - kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ));
			}
			
			// 1 artillery depot (not for Aztecs, Sioux or Asians)
			if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
			{
				if (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 2)
				addItemToForecasts(cUnitTypeArtilleryDepot, 2);  
			}
			
			// One castle for Asians
			if (civIsAsian() == true) 
			{
				if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ) < 2)
				addItemToForecasts(cUnitTypeypCastle, 2);  
			}
			
			// One market
			if (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1)
            addItemToForecasts(gMarketUnit, 1);
			
			// Europeans - one saloon
			if ((civIsNative() == false) && (civIsAsian() == false))
			{
				if (kbUnitCount(cMyID, cUnitTypeSPCFortCenter, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeSPCFortCenter, 1);
			}
			
			// Natives - embassy
			if (civIsNative() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeNativeEmbassy, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeNativeEmbassy, 1);
			}
			
			// One town center
			if (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1)
            addItemToForecasts(gTownCenter, 1);
			
			if (gLandUnitPicker >= 0)
			{
				// Add 25 pop slots of primary military unit
				militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 0);
				if (militaryUnit >= 0)
				{
					popSlots = kbGetPopSlots(cMyID, militaryUnit);
					if (popSlots < 1)
					popSlots = 1;
					milQty = 25 / popSlots; 
					addItemToForecasts(militaryUnit, milQty);
				}         
				else
				{
					xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 2000.0);
					xsArraySetInt(gForecasts, cResourceFood, xsArrayGetInt(gForecasts, cResourceFood) + 2000.0);
				} 
				
				// Add 15 pop slots of secondary military unit
				if (kbUnitPickGetNumberResults(gLandUnitPicker) > 1)
				{
					militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 1);
					if (militaryUnit >= 0)
					{
						popSlots = kbGetPopSlots(cMyID, militaryUnit);
						if (popSlots < 1)
						popSlots = 1;
						milQty = 15 / popSlots; 
						addItemToForecasts(militaryUnit, milQty);
					} 
				}
			}
			
			// Add enough gold and wood for a guard/champion/honored unit upgrade
			if (civIsNative() == false) // guard or honored upgrade
			{
				xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 600.0);
				xsArraySetInt(gForecasts, cResourceWood, xsArrayGetInt(gForecasts, cResourceWood) + 600.0);
			}
			else // champion upgrade
			{
				xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 200.0);
				xsArraySetInt(gForecasts, cResourceWood, xsArrayGetInt(gForecasts, cResourceWood) + 400.0);
			}
			
			// Add 2000 gold for mercenaries/allies/support (enough for one Age 4 or two Age 3 shipments, used as reserve if none are available)
			xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 2000.0);
			
			// Check towers
			if (kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ) < gNumTowers)
            addItemToForecasts(gTowerUnit, gNumTowers - kbUnitCount(cMyID, gTowerUnit, cUnitStateABQ)); 
			
			break;
		}
		case cAge5:
		{
			// Add a baseline just to make sure we don't get any near-zero resource amounts
			xsArraySetFloat(gForecasts, cResourceFood, xsArrayGetFloat(gForecasts, cResourceFood) + 500.0);
			xsArraySetFloat(gForecasts, cResourceWood, xsArrayGetFloat(gForecasts, cResourceWood) + 500.0);
			xsArraySetFloat(gForecasts, cResourceGold, xsArrayGetFloat(gForecasts, cResourceGold) + 500.0);
			
			// Settlers
			if (cMyCiv != cCivOttomans)   // Ottomans get them free
			{
				numUnits = 10;
				addItemToForecasts(gEconUnit, numUnits);
			}
			
			// 3 houses
			addItemToForecasts(gHouseUnit, 5);   
			
			// Ships for water maps
			if (gNavyMode == cNavyModeActive)
			{
				if(civIsNative() == false)
				{
					if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < 4)
					addItemToForecasts(gCaravelUnit, 4 - kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive));
					if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < 1)
					addItemToForecasts(gGalleonUnit, 1 - kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive));
					if ((kbGetCiv() != cCivChinese) && (kbGetCiv() != cCivSPCChinese))
					{
						if (kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive) < 1)
						addItemToForecasts(gFrigateUnit, 1 - kbUnitCount(cMyID, gFrigateUnit, cUnitStateAlive));
					}
					if (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) < 1)
					addItemToForecasts(cUnitTypeMonitor, 1 - kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive));
				}
				else
				{
					if (kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive) < 6)
					addItemToForecasts(gCaravelUnit, 3 - kbUnitCount(cMyID, gCaravelUnit, cUnitStateAlive));
					if (kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive) < 6)
					addItemToForecasts(gGalleonUnit, 1 - kbUnitCount(cMyID, gGalleonUnit, cUnitStateAlive));
				}
			}
			
			// Mosque or church (not for natives or Asians)
			if ((civIsNative() == false) && (civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeChurch, 1);   
			
			// Asians - one monastery
			if ((civIsAsian() == false) && (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1))
            addItemToForecasts(cUnitTypeypMonastery, 1);
			
			// Natives - one fire pit
			if (civIsNative() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeFirePit, 1);
			}
			
			// Asians - one consulate
			if (civIsAsian() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeypConsulate, 1);
			}
			
			// Factory upgrades (provided there is at least one)
			if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0)  
			{
				if (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechFactoryMassProduction);
				}
			}
			if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 1)  
			{
				if (kbTechGetStatus(cTechFactorySteamPower) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechFactorySteamPower);
				}
			}
			
			// Fort upgrades (provided there is one)
			if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) > 0)  
			{
				if (kbTechGetStatus(cTechRevetment) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechRevetment);
				}
				if (kbTechGetStatus(cTechStarFort) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechStarFort);
				}
			}
			
			// Agra fort upgrades (provided there is one)
			if ((kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0) ||
				(kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0) ||
				(kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0) ||
			(kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0))
			{
				if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypFrontierAgra);
				}
				if (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypFortifiedAgra);
				}
			}
			
			// Japanese - shrine upgrade (provided there are enough around)
			if (cMyCiv == cCivJapanese)
			{
				if ((kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine2, cUnitStateAlive) > 0) ||
					(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine3, cUnitStateAlive) > 0) ||
					(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine4, cUnitStateAlive) > 0) ||
				(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine5, cUnitStateAlive) > 0))
				{
					if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) >= 10) &&
					(kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable))
					{
						addTechToForecasts(cTechypShrineFortressUpgrade);
					}
				}
				else if ((kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) >= 16) &&
				(kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable))
				{
					addTechToForecasts(cTechypShrineFortressUpgrade);
				}
			}
			
			// Chinese - fourth village upgrade
			if (cMyCiv == cCivChinese)
			{
				if (kbTechGetStatus(cTechypVillagePopCapIncrease4) == cTechStatusObtainable)
				{
					addTechToForecasts(cTechypVillagePopCapIncrease4);
				}
			}
			
			// Dutch - 6 banks (including those made available by the coffee trade tech)
			if (cMyCiv == cCivDutch)
			{
				if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 6)
				addItemToForecasts(cUnitTypeBank, 6 - kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ));
			} 
			
			// 2 barracks, blockhouses or war huts
			if ( (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) + 
			kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ) ) < 4)
            addItemToForecasts(cUnitTypeBarracks, 4 - kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateABQ));
			
			// 1 additional war hut for Aztecs (up to 5 in total)
			if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 5)
            addItemToForecasts(cUnitTypeWarHut, 3);
			
			// 2 stables, corrals or caravanserais (not for Chinese)
			if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
			{
				if ( (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) + 
					kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) + 
					kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) + 
				kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ) ) < 4)
				addItemToForecasts(cUnitTypeStable, 4 - kbUnitCount(cMyID, cUnitTypeStable, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateABQ) - kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateABQ));
			}
			
			// 2 artillery depots (not for Aztecs, Sioux or Asians)
			if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
			{
				if (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 3)
				addItemToForecasts(cUnitTypeArtilleryDepot, 3 - kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ));  
			}
			
			// Two castles for Asians
			if (civIsAsian() == true) 
			{
				if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ) < 4)
				addItemToForecasts(cUnitTypeypCastle, 3 - kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ));  
			}
			
			// One market
			if (kbUnitCount(cMyID, gMarketUnit, cUnitStateABQ) < 1)
            addItemToForecasts(gMarketUnit, 1);
			
			// Europeans - one saloon
			if ((civIsNative() == false) && (civIsAsian() == false))
			{
				if (kbUnitCount(cMyID, cUnitTypeSPCFortCenter, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeSPCFortCenter, 1);
			}
			
			// Natives - embassy
			if (civIsNative() == true)
			{
				if (kbUnitCount(cMyID, cUnitTypeNativeEmbassy, cUnitStateABQ) < 1)
				addItemToForecasts(cUnitTypeNativeEmbassy, 1);
			}
			
			// One town center
			if (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1)
            addItemToForecasts(gTownCenter, 1);
			
			if (gLandUnitPicker >= 0)
			{
				// Add 30 pop slots of primary military unit
				militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 0);
				if (militaryUnit >= 0)
				{
					popSlots = kbGetPopSlots(cMyID, militaryUnit);
					if (popSlots < 1)
					popSlots = 1;
					milQty = 30 / popSlots; 
					addItemToForecasts(militaryUnit, milQty);
				} 
				
				// Add 20 pop slots of secondary military unit
				if (kbUnitPickGetNumberResults(gLandUnitPicker) > 1)
				{
					militaryUnit = kbUnitPickGetResult( gLandUnitPicker, 1);
					if (militaryUnit >= 0)
					{
						popSlots = kbGetPopSlots(cMyID, militaryUnit);
						if (popSlots < 1)
						popSlots = 1;
						milQty = 20 / popSlots; 
						addItemToForecasts(militaryUnit, milQty);
					} 
				}   
			}
			
			// Add enough gold and wood for an imperial/legendary unit upgrade
			xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 1500.0);
			xsArraySetInt(gForecasts, cResourceWood, xsArrayGetInt(gForecasts, cResourceWood) + 1500.0);
			
			// Add 2000 gold for mercenaries/allies/support (enough for one Age 4 or two Age 3 shipments, used as reserve if none are available)
			xsArraySetInt(gForecasts, cResourceGold, xsArrayGetInt(gForecasts, cResourceGold) + 2000.0);
			
			break;
		}
	}
	spewForecasts();
	updatePrices();   // Set the aicost weights, buy/sell resources as needed.
}


void updateResources()
{
	const int cMinResourcePerGatherer = 200;   // When our supply gets below this level, start farming/plantations.
	int mainBaseID = kbBaseGetMainID(cMyID);
	if (mainBaseID < 0)
	return;
	vector loc = kbBaseGetLocation(cMyID, mainBaseID);
	if (xsGetTime() > 5000)
	{
		int foodAmount = kbGetAmountValidResources( mainBaseID, cResourceFood , cAIResourceSubTypeEasy, 60.0  );
		if ( (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) {
			foodAmount = foodAmount + kbGetAmountValidResources( mainBaseID, cResourceFood , cAIResourceSubTypeHunt, 60.0  );
		}
		if ( (kbGetCiv() != cCivIndians) && (kbGetCiv() != cCivSPCIndians) && (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) {
			foodAmount = foodAmount + kbGetAmountValidResources( mainBaseID, cResourceFood , cAIResourceSubTypeHerdable, 60.0  );
		}
		// Subtract mills at 999 each.
		foodAmount = foodAmount - (getUnitCountByLocation(gFarmUnit, cMyID, cUnitStateAlive, loc, 60.0) * 999);
		float percentOnFood = aiGetResourceGathererPercentage( cResourceFood, cRGPActual );
		int numFoodGatherers =  percentOnFood * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
		if (numFoodGatherers < 1)
		numFoodGatherers = 1;
		int foodPerGatherer = foodAmount / numFoodGatherers;
		
		int woodAmount = kbGetAmountValidResources( mainBaseID, cResourceWood , cAIResourceSubTypeEasy, 60.0  );
		float percentOnWood = aiGetResourceGathererPercentage( cResourceWood, cRGPActual );
		int numWoodGatherers =  percentOnWood * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
		if (numWoodGatherers < 1)
		numWoodGatherers = 1;
		int woodPerGatherer = woodAmount / numWoodGatherers;
		
		int goldAmount = kbGetAmountValidResources( mainBaseID, cResourceGold , cAIResourceSubTypeEasy, 60.0  );
		// Subtract plantations at 999 each.
		goldAmount = goldAmount - (getUnitCountByLocation(gPlantationUnit, cMyID, cUnitStateAlive, loc, 60.0) * 999);
		float percentOnGold = aiGetResourceGathererPercentage( cResourceGold, cRGPActual );
		int numGoldGatherers =  percentOnGold * kbUnitCount(cMyID, gEconUnit, cUnitStateAlive);
		if (numGoldGatherers < 1)
		numGoldGatherers = 1;
		int goldPerGatherer = goldAmount / numGoldGatherers;
		
		//aiEcho("       Resources:   Food "+foodAmount+", Wood "+woodAmount+", Gold "+goldAmount);
		//aiEcho("    Per gatherer:   Food "+foodPerGatherer+", Wood "+woodPerGatherer+", Gold "+goldPerGatherer);
		
	if ((gTimeToFarm == false) && (foodPerGatherer < cMinResourcePerGatherer) )
		{
			//aiEcho("        **** It's time to start farming!");
			gTimeToFarm = true;
		}

		
		if ( (gTimeForPlantations == false) && (goldPerGatherer < cMinResourcePerGatherer) )
		{
			//aiEcho("        **** It's time to start using plantations!");
			gTimeForPlantations = true;
		}
	}
	if(xsGetTime() > 1200000 || kbGetAge() > cAge3)
	{
		gTimeToFarm = true;
		gTimeForPlantations = true;
	}
}

//==============================================================================
/*
	econMaster(int mode, int value)
	
	Performs top-level economic analysis and direction.   Generally called
	by the econMasterRule, it can be called directly for special-event processing.
	EconMasterRule calls it with default parameters, directing it to do a full
	reanalysis.  
*/
//==============================================================================
void econMaster(int mode=-1, int value=-1)
{
	// Monitor main base supply of food and gold, activate farming and plantations when resources run low
	updateResources();
	
	
	
	// Update forecasts for economic and military expenses.  Set resource
	// exchange rates.
	updateForecasts();      
	
	
	// Set desired gatherer ratios.  Spread them out per base, set per-base 
	// resource breakdowns.
	updateGatherers();
	
	// Update our settler maintain targets, based on age, personality.
	updateSettlerCounts();
	
	// Maintain escrow balance based on age, personality, actual vs. desired settler pop.
	updateEscrows();
	
}

//==============================================================================
// rule econMasterRule
/*
	This rule calls the econMaster() function on a regular basis.  The 
	function is separate so that it may be called with a parameter for 
	unscheduled processing based on unexpected events.  
*/
//==============================================================================
rule econMasterRule
inactive
group startup
minInterval 30
{
	econMaster();
}

//==============================================================================
// Military
//==============================================================================
//updatedOn 2019/04/15 By ageekhere  
//---------------------------
void buildNewTC()
{ //check if the ai can build a another tc
	if(kbGetAge() < cAge3)return;
	if (kbResourceGet(cResourceWood) > 600 && kbUnitCount(cMyID, gTownCenter) < kbGetBuildLimit(cMyID, gTownCenter) )
	{
		createSimpleBuildPlan(gTownCenter, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);	
	}
}
/*
extern int wallLocations = 0;
vector currentSearchLoc = cInvalidVector;
rule wallAreaFind
active
minInterval 1
{
	
	int mapSizeX = kbGetMapXSize(); //the map max X range
	int mapSizeZ = kbGetMapZSize(); //the map max Z range
	float mapRadiusDist =  kbGetMapXSize() / 2;

	
	if(currentSearchLoc == cInvalidVector)
	{ //set the start search location		
		currentSearchLoc = xsVectorSetX(currentSearchLoc, xsVectorGetX(currentSearchLoc) - mapSizeX);
		currentSearchLoc = xsVectorSetZ(currentSearchLoc, xsVectorGetZ(currentSearchLoc) - mapSizeZ);
	} //end if
	vector lookAtArea = cInvalidVector; //A location where a search is done to find land next to water
	int count = 0;
	int range = 20; //the search size		
	while (xsVectorGetZ(currentSearchLoc) < mapSizeZ)
	{ //Z search
		while (xsVectorGetX(currentSearchLoc) < mapSizeX)
		{ //X search
			lookAtArea = currentSearchLoc; //update the lookAtArea location with the current search block
			int areaType = kbAreaGetIDByPosition(currentSearchLoc); //get the current area type
			if( kbAreaGetType(areaType) == 2 || kbAreaGetType(areaType) == 3)
			{
				for(i = 0; < 8)
				{ //area search at lookAtArea
					if(i == 0) lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) - range); 
					else if(i == 1)lookAtArea = xsVectorSetZ(lookAtArea, xsVectorGetZ(lookAtArea) + range);
					else if(i == 2)lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) + range);
					else if(i == 3)lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) + range);
					else if(i == 4)lookAtArea = xsVectorSetZ(lookAtArea, xsVectorGetZ(lookAtArea) - range);
					else if(i == 5)lookAtArea = xsVectorSetZ(lookAtArea, xsVectorGetZ(lookAtArea) - range);
					else if(i == 6)lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) - range);
					else if(i == 7)lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) - range);		
					areaType = kbAreaGetIDByPosition(lookAtArea); //get area type 
					if(kbAreaGetType(areaType) == 2 || kbAreaGetType(areaType) == 3)
					{ //found land
						
						float dist = distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), lookAtArea);
						float distMapMiddle = distance(lookAtArea, kbGetMapCenter());
					
						//if(dist > 100) continue;
						if(distMapMiddle > mapRadiusDist)continue;
						aiChat(1,"kbAreaGetType(areaType " + kbAreaGetType(areaType) + " lookAtArea " + lookAtArea);
						xsArraySetVector(wallAreaArray, count ,lookAtArea); //record locaiton
						count++;
					}  //end if	
				}//end for i	
			} //end if
			currentSearchLoc = xsVectorSetX(currentSearchLoc, xsVectorGetX(currentSearchLoc) + range); //update currentSearchLoc with new X value
		} //end while						
		currentSearchLoc = xsVectorSetX(currentSearchLoc, xsVectorGetX(currentSearchLoc) - mapSizeX); //reset x location
		currentSearchLoc = xsVectorSetZ(currentSearchLoc, xsVectorGetZ(currentSearchLoc) + range); //move the z location
	} //end while				
	xsDisableSelf();
	aiChat(1,"found " + count);
	wallLocations = count;
	float dist1 = 0.0;
	float dist2 = 0.0;
    for(i = 0; < count)
    {
        for(j = i + 1; < count)
        { 
			dist1 = distance(xsArrayGetVector(wallAreaArray,0), xsArrayGetVector(wallAreaArray,i));
			dist2 = distance(xsArrayGetVector(wallAreaArray,0), xsArrayGetVector(wallAreaArray,j));
			if(dist1 > dist2)
            {
				xsArraySetVector(wallAreaArray, i ,xsArrayGetVector(wallAreaArray,j) );
				xsArraySetVector(wallAreaArray, j ,xsArrayGetVector(wallAreaArray,i) );
            }
        }
	}	
} //end areaFind

rule walltest
active
mininterval 10
{
aiChat(1,"wall test");
	vector lastP = cInvalidVector;
	float dist = 0.0;
	vector startAt = cInvalidVector;
	static int startAtI = 0;
	vector endAt = cInvalidVector;
	//static int lastEnd = 0;
	aiChat(1,"startAtI " + startAtI);
	for(i = startAtI; < xsArrayGetSize(wallAreaArray) )
	{
		if(xsArrayGetVector(wallAreaArray,i) == cInvalidVector)continue;
		dist = distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), xsArrayGetVector(wallAreaArray,i));
		//if(dist > 80)continue;
		if(startAt == cInvalidVector) 
		{
			startAt = xsArrayGetVector(wallAreaArray,i);
			startAtI++;
		if(startAtI == xsArrayGetSize(wallAreaArray) -1) startAtI = 0;
			//xsArraySetVector(wallAreaArray, i ,cInvalidVector);
			//lastEnd ++;
			continue;
		}
		//endAt = xsArrayGetVector(wallAreaArray,wallLocations - i);
		endAt = xsArrayGetVector(wallAreaArray,i + 1);
		if(endAt == cInvalidVector)return;
		
		//aiChat(1,"start " + distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), startAt) + " end " + distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), endAt));
		if(distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), startAt) > 100 )
		{
			//continue;
		}
		
		if(distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), endAt) > 100 )
		{
			//continue;
		}
	
		//if(distance(startAt, endAt) < 50 )
		//{
		//	continue;
	//	}
		xsArraySetVector(wallAreaArray, i ,cInvalidVector);
		
		aiChat(1,"startAt " + startAt + " endAt " + endAt );
		
		int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
		aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeStraight);
		aiPlanAddUnitType(wallPlanID, gEconUnit, 0, 2, 2);

		aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallStart, 0, startAt);
		aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallEnd, 0, endAt );
		aiPlanSetVariableInt(wallPlanID, cBuildWallPlanEdgeOfMapBuffer, 0, 1 );
		//aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, wallPosition); //wallPosition
		//aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, wallSize);
		//aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 10);
		//aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
		aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
		aiPlanSetDesiredPriority(wallPlanID, 100);
		aiPlanSetActive(wallPlanID, true);
		aiChat(1,"make");
		return;
		
	}
	 //xsDisableSelf();
}
*/


//---------------------------
//updatedOn 2019/03/25 By ageekhere 
//rule delayWalls
//active   
//minInterval 60
void delayWalls()
{
	if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)return;

	if ((aiGetGameType() == cGameTypeCampaign) || (aiGetGameType() == cGameTypeScenario)) return;
	if(baseRelocateEver == true || kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) == 0) return;
	//if(kbGetAge() < cAge4) return;
	if(xsGetTime() < 1200000) return; //under 20 mins
	
	float wallLastDist = -1;
	float wallCurrentDist = 0;
	
	float wallMidCurrentDist = 0;
	float wallLastMisDist = 0;
	
	bool wallHuman = false;
	int wallOuterWallPlyaer = 0;
	
	if(kbResourceGet(cResourceWood) < 500)
	return; //check if ai has enough wood
	
	if(activateWallUpgrade == false)
	{ //activee wall upgrade once per ai
		//xsEnableRule("BastionUpgradeMonitor");
		gBuildWalls = true;
		activateWallUpgrade = true;
	} //end if
	
	for (x = 0; < cNumberPlayers)
	{ //loop through players
		if(kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(x))
		{ //That are on my team
			wallCurrentDist = xsVectorLength(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) - kbBaseGetLocation(x, kbBaseGetMainID(x))); //get a distance from current ai to x ai
			if(wallCurrentDist > 0 && (wallLastDist > wallCurrentDist || wallLastDist == -1))
			{ //find the smallest distance between two team ai players
				wallLastDist = wallCurrentDist; //This is now the smallest distance
			} //end if  
			
			for(j = 0; < cNumberPlayers)
			{ 
				if(kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(j))
				{
					if(kbIsPlayerHuman(j) == false && wallOuterWallPlyaer == 0) wallOuterWallPlyaer = j;
					wallMidCurrentDist = xsVectorLength(kbBaseGetLocation(x, kbBaseGetMainID(x)) - kbBaseGetLocation(j, kbBaseGetMainID(j))); //get a distance
					if(wallLastMisDist < wallMidCurrentDist)
					{//get the greatest distance
						//get the position between the two players
						wallMidPosition = xsVectorSet((xsVectorGetX(kbBaseGetLocation(x, kbBaseGetMainID(x))) + xsVectorGetX(kbBaseGetLocation(j, kbBaseGetMainID(j))))*0.5,0,(xsVectorGetZ(kbBaseGetLocation(x, kbBaseGetMainID(x))) + xsVectorGetZ(kbBaseGetLocation(j, kbBaseGetMainID(j))))*0.5);
						wallLastMisDist = wallMidCurrentDist;
					} //end if
				} //end if
			} //end for j
		} //end if
	} //end for
	
	
	switch (cMyID)
	{ //the ai wall layer current size
		case 1:{wallPlanNumber = wallPlanNumberP1; break;}
		case 2:{wallPlanNumber = wallPlanNumberP2; break;}
		case 3:{wallPlanNumber = wallPlanNumberP3; break;}
		case 4:{wallPlanNumber = wallPlanNumberP4; break;}
		case 5:{wallPlanNumber = wallPlanNumberP5; break;}
		case 6:{wallPlanNumber = wallPlanNumberP6; break;}
		case 7:{wallPlanNumber = wallPlanNumberP7; break;}
		case 8:{wallPlanNumber = wallPlanNumberP8; break;}
	} //end switch
	if(wallPlanNumber < 3) 
	{ //only build 2 layer wall
		wallSize = wallLastDist * 0.46; //gets the wall size (min spacing 23)
		if(wallSize > 80) wallSize = 80; //max wall size
		
		if(wallPlanNumber > 1 && ourTeamSizeMain > 2 && wallLastMisDist < 200 && kbGetAge() > cAge4)
		{ //going to build layer 2 of wall
			wallSize = wallLastMisDist * 0.65;//0.46; //the layer 2 wall size is calculated by the two featherest team players
			wallPosition = wallMidPosition; //sets the build location to the middle of the team 
		}// end if
		else if(wallSize < 40 && ourTeamSizeMain != 1)
		{ //ai too near
			switch (cMyID)
			{ //jump to layer 2 wall
				case 1:{wallPlanNumberP1++; break;}
				case 2:{wallPlanNumberP2++; break;}
				case 3:{wallPlanNumberP3++; break;}
				case 4:{wallPlanNumberP4++; break;}
				case 5:{wallPlanNumberP5++; break;}
				case 6:{wallPlanNumberP6++; break;}
				case 7:{wallPlanNumberP7++; break;}
				case 8:{wallPlanNumberP8++; break;}
			}//end switch
			return;
		}//else
		else
		{ //normal wall position
			wallPosition = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)); 
		}//end else
		
		if(ourTeamSizeMain == 1)
		{ //when only 1 ai
			wallSize = 60;
		} //end if
		
		if(wallPlanNumber > 1 && (getTeamPosition(cMyID) != wallOuterWallPlyaer || ourTeamSizeMain < 3))
		{
			//xsDisableSelf();
			return;
		} //end if
		int wallPlanID=aiPlanCreate("WallInBase", cPlanBuildWall);
		if (wallPlanID != -1)
		{
			aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
			aiPlanAddUnitType(wallPlanID, gEconUnit, 0, 2, 2);
			aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, wallPosition); //wallPosition
			aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, wallSize);
			aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 10);
			aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
			aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
			aiPlanSetDesiredPriority(wallPlanID, 40);
			aiPlanSetActive(wallPlanID, true);
			sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIWallIn);
			//Enable our wall gap rule, too.
			xsEnableRule("fillInWallGaps");
			//aiEcho("Enabling Wall Plan for Base ID: "+kbBaseGetMainID(cMyID));
			
			switch (cMyID)
			{ //up wall layer if on wall level 1
				case 1:{if(wallPlanNumberP1 == 1)wallPlanNumberP1++; break;}
				case 2:{if(wallPlanNumberP1 == 1)wallPlanNumberP2++; break;}
				case 3:{if(wallPlanNumberP1 == 1)wallPlanNumberP3++; break;}
				case 4:{if(wallPlanNumberP1 == 1)wallPlanNumberP4++; break;}
				case 5:{if(wallPlanNumberP1 == 1)wallPlanNumberP5++; break;}
				case 6:{if(wallPlanNumberP1 == 1)wallPlanNumberP6++; break;}
				case 7:{if(wallPlanNumberP1 == 1)wallPlanNumberP7++; break;}
				case 8:{if(wallPlanNumberP1 == 1)wallPlanNumberP8++; break;}
			}//end switch	
		} //end if   
	}//end if
} //end
/*
	rule BastionUpgradeMonitor
	inactive
	minInterval 90
	{
	int upgradePlanID = -1;
	
	// Disable rule for native or Asian civs
	//if ((civIsNative() == true) || (civIsAsian() == true))
	//{
	//xsDisableSelf();
	//return;
	//}
	
	if ((kbTechGetStatus(cTechBastion) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractWall, cUnitStateAlive) >= 20))
	{
	upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBastion);
	if (upgradePlanID >= 0)
	aiPlanDestroy(upgradePlanID);
	createSimpleResearchPlan(cTechBastion, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
	return;
	}
	}
*/

rule turtleUp
inactive
group tcComplete
minInterval 15
{
	// Number of towers ranges from 2 at 0.0 up to 7 at -1.0
	// Numbers below 0 also encourage shipping towers from the home city
	if ((kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateAlive)) < 10)
	return;
	
	if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 1) )
	return;
	
	//float odds = btOffenseDefense * -1.0;  
	//odds = odds + 0.5;   // Range -0.5 to +1.5
	//int needToRoll = 100.0 * odds;  // Range -50 to +150
	//if ( (aiRandInt(100) < needToRoll) && (cvOkToBuildWalls == true) )
	//{
		//aiEcho("Decided to do walls.");
		//gBuildWalls = true;
		//xsEnableRule("delayWalls");   // Start walls once we have housing room
		//xsEnableRule("BastionUpgradeMonitor");
	//}
	
	if (gNumTowers < 0)
	{  // If it hasn't been defined elsewhere, set defaults
		if (civIsAsian() == false)
		{
			gNumTowers = ( (btOffenseDefense * -1.0) + 0.5 ) * 5.25; // 7 for extreme turtler, 2 for balanced.
			if (gNumTowers < 0)
            gNumTowers = 0.0;
			if (kbGetCivForPlayer(cMyID) == cCivXPAztec)
            gNumTowers = gNumTowers / 2;
		}
		else
		{
			gNumTowers = ( (btOffenseDefense * -1.0) + 0.7 ) * 3.0; // 5 for extreme turtler, 2 for balanced.
			if (gNumTowers < 0)
            gNumTowers = 0.0;
		}
	}
	if (cvOkToFortify == false)
	gNumTowers = 0.0;
	
	//aiEcho(" ");
	//aiEcho("Planning on making "+gNumTowers+" towers.");
	//aiEcho(" ");
	
	xsEnableRule("towerManager");
	xsEnableRule("aztecWarhutUpgradeMonitor");
	
	xsDisableSelf();
}

/* setUnitPickerPreference()
	
	Updates the unit picker biases, arbitrates between the potentially conflicting sources.  
	
	Priority order is:
	
	1)  If control is from a trigger, that wins.  The unit line specified in gCommandUnitLine gets a +.8, all others +.2
	2)  If control is ally command, ditto.  (Can only be one unit due to UI limits.
	3)  If we're not under command, but cvPrimaryArmyUnit (and optionally cvSecondaryArmyUnit, cvTertiaryArmy Unit) are set, they rule.
	If just primary, it gets 0.8, with 0.2 for other classes.  
	If primary and secondary, they get 1.0 and 0.5, others get 0.0.
	If primary, secondary and tertiary, they get 0.8, 0.4 and 0.2, others get 0.0.
	4)  If enough enemy units have been spotted, bias towards appropriate counters
	5)  If not under command, no cv's are set, and no units have been spotted, we go with the btBiasCav, btBiasInf and btBiasArt line settings.  
	
*/

void set_avoided_unit_pref(bool reset=false)
{
	// No matter what, ALWAYS avoid putting the following units in preference:
	if (reset)
	kbUnitPickResetAll(gLandUnitPicker);
	
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpWarrior, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpDogSoldier, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpMedicineManAztec, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSkullKnight, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpRam, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpPetard, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMortar, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypexpSpy, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeGoldMiner, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeNativeScout, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeEnvoy, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMongolScout, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeMercenary, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSowarMansabdar, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypRajputMansabdar, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatMercGurkhaJemadar, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypZamburakMansabdar, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMercFlailiphantMansabdar, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypHowdahMansabdar, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMahoutMansabdar, 0.0);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypSiegeElephantMansabdar, 0.0);
}

void clear_unit_pref(bool reset=false)
{
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 0.5);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 0.2);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 0.5);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.2);
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeCoureur, 0.0);
	if (cMyCiv==cCivXPAztec)
	kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 0.5);
}

void setUnitPickerPreference(int upID = -1)
{ 
	if(islandLanded == true) 
	{
		return;
	}
	
	// Add the main unit lines
	if (upID < 0)
	return;
	
	// First of all, AND IT'S REALLY IMPORTANT, check if a human ally told us to focus on a certain unit type only:
	if ((gUnitPickSource == cOpportunitySourceTrigger) || (gUnitPickSource == cOpportunitySourceAllyRequest))
	{
		// Yes, someone told us to focus on a certain unit type only.
		
		// So, first of all, clear all preferences:
		kbUnitPickResetAll(gLandUnitPicker);
		
		clear_unit_pref();
		set_avoided_unit_pref();
		
		// Now, let's focus on the unit type we are told to focus on:
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 0.85);
		
		return;
	}
	
	// IF we have not received any request from ally/trigger, then check for pre-assigned types in aiLoaderStandard.xs:
	if (cvPrimaryArmyUnit>=0)
	{
		kbUnitPickResetAll(gLandUnitPicker);
		
		if (cvSecondaryArmyUnit==-1)
		{
			clear_unit_pref();
			set_avoided_unit_pref();
			
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 0.85);
		}
		else if (cvTertiaryArmyUnit==-1)
		{
			clear_unit_pref();
			set_avoided_unit_pref();
			
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 0.8);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvSecondaryArmyUnit, 0.2);  
		}
		else
		{
			clear_unit_pref();
			set_avoided_unit_pref();
			
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvPrimaryArmyUnit, 0.6);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvSecondaryArmyUnit, 0.3);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cvTertiaryArmyUnit, 0.1);
		}
		
		return;
	}
	
	
	// IF there are no pre-assigned types in aiLoaderStandard.xs, then go with normal preferences:
	
	// But first of all, check for units to counter:
	static bool counterUnitMode=false;
	
	float enemyToCounter=aiGetMostHatedPlayerID();
	float heavyInfantryCount=kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyInfantry, cUnitStateAlive);
	float lightInfantryCount=kbUnitCount(enemyToCounter, cUnitTypeAbstractInfantry, cUnitStateAlive) - heavyInfantryCount;
	float lightCavalryCount=kbUnitCount(enemyToCounter, cUnitTypeAbstractLightCavalry, cUnitStateAlive);
	lightCavalryCount=lightCavalryCount+kbUnitCount(enemyToCounter, cUnitTypexpEagleKnight, cUnitStateAlive); // Aztec eagle knights count as light cavalry
	float heavyCavalryCount=kbUnitCount(enemyToCounter, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive);
	heavyCavalryCount=heavyCavalryCount+kbUnitCount(enemyToCounter, cUnitTypexpCoyoteMan, cUnitStateAlive); // Aztec coyote runners count as heavy cavalry
	float artilleryCount = kbUnitCount(enemyToCounter, cUnitTypeAbstractArtillery, cUnitStateAlive);
	float totalEnemyCount = lightInfantryCount + heavyInfantryCount + lightCavalryCount + heavyCavalryCount + artilleryCount;
	
	if (totalEnemyCount>=1000)
	{
		counterUnitMode = true;
		
		// Calculate enemy's basic unit ratio and favor appropriate counters
		float lightInfantryFactor = lightInfantryCount / totalEnemyCount;
		float heavyInfantryFactor = heavyInfantryCount / totalEnemyCount;
		float lightCavalryFactor = lightCavalryCount / totalEnemyCount;
		float heavyCavalryFactor = heavyCavalryCount / totalEnemyCount;
		float artilleryFactor = artilleryCount / totalEnemyCount;
		
		kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeSkirmisher, lightInfantryFactor); // Skirmisher representing light infantry
		kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeMusketeer, heavyInfantryFactor); // Musketeer representing heavy infantry
		kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeDragoon, lightCavalryFactor); // Dragoon representing light cavalry
		kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeHussar, heavyCavalryFactor); // Hussar representing heavy cavalry
		kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeFalconet, artilleryFactor); // Falconet representing artillery
		
		return;
	}
	
	// If we're not in counter mode, then go with normal preferences
	if (counterUnitMode == false)
	{
		kbUnitPickResetAll(gLandUnitPicker);
		
		clear_unit_pref();
		set_avoided_unit_pref();
		
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 0.5 + (btBiasInf / 2.0));   // Range 0.0 to 1.0
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 0.5 + (btBiasArt / 2.0));
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 0.5 + (btBiasCav / 2.0));
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractNativeWarrior, 0.5 + (btBiasNative / 2.0));
		
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypNatConquistador, 0.0);
		
		if (cMyCiv == cCivXPAztec)
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractLightInfantry, 0.5 + (btBiasCav / 2.0));
		
		if (cMyCiv == cCivBritish)
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeHalberdier, 0.1);
		
		if (cMyCiv == cCivFrench)
		kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeFlatbowman, 0.1);
		
		set_avoided_unit_pref();
		
		if ( (kbGetCiv() == cCivChinese) || (kbGetCiv() == cCivSPCChinese) ) 
		{
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractInfantry, 0.0);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractCavalry, 0.0);
			
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypStandardArmy, 0.4);   // Range 0.0 to 1.0
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMingArmy, 0.4);   // Range 0.0 to 1.0
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypImperialArmy, 0.4);   // Range 0.0 to 1.0
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypTerritorialArmy, 0.6);   // Range 0.0 to 1.0
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypOldHanArmy, 0.5);   // Range 0.0 to 1.0
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypForbiddenArmy, 0.6);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypBlackFlagArmy, 0.3);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeypMongolianArmy, 0.3);
			
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractArtillery, 0.4);
		}
		
		if (civIsAsian() == true)
		{ 
			// Set preferences for consulate units
			setConsulateArmyPreference();
		}
		
		if (civIsAsian() == false)
		{ 
			// Set preferences for capitol units
			setCapitolArmyPreference();
		}
		
		if (civIsNative() == true)
		{ 
			// Natives and Europeans need to stop trying to build consulate and monastery units
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateSiegeFortress, 0.0);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateSiegeIndustrial, 0.0);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnit, 0.0);
			kbUnitPickSetPreferenceFactor(gLandUnitPicker, cUnitTypeAbstractConsulateUnitColonial, 0.0);
		}
	}
}

//==============================================================================
// initUnitPicker
//==============================================================================
int initUnitPicker(string name="BUG", int numberTypes=1, int minUnits=10,
	int maxUnits=20, int minPop=-1, int maxPop=-1, int numberBuildings=1,
bool guessEnemyUnitType=false)
{   
	//Create it.
	int upID=kbUnitPickCreate(name);
	if (upID < 0)
	return(-1);
	
	//Default init.
	kbUnitPickResetAll(upID);
	
	kbUnitPickSetPreferenceWeight(upID, 1.0);
	if (gSPC == false)
	kbUnitPickSetCombatEfficiencyWeight(upID, 2.0);    // Changed from 1.0 to dilute the power of the preference weight.
	else
	kbUnitPickSetCombatEfficiencyWeight(upID, 1.0);    // Leave it at 1.0 to avoid messing up SPC balance
	
	kbUnitPickSetCostWeight(upID, 0.0);
	//Desired number units types, buildings.
	kbUnitPickSetDesiredNumberUnitTypes(upID, numberTypes, numberBuildings, true);
	//Min/Max units and Min/Max pop.
	kbUnitPickSetMinimumNumberUnits(upID, minUnits);   // Sets "need" level on attack plans
	kbUnitPickSetMaximumNumberUnits(upID, maxUnits);   // Sets "max" level on attack plans, sets "numberToMaintain" on train plans for primary unit,
	// half that for secondary, 1/4 for tertiary, etc.
	kbUnitPickSetMinimumPop(upID, minPop); // Not sure what this does...
	kbUnitPickSetMaximumPop(upID, maxPop); // If set, overrides maxNumberUnits for how many of the primary unit to maintain.
	
	//Default to land units.
	kbUnitPickSetEnemyPlayerID(upID, aiGetMostHatedPlayerID());
	kbUnitPickSetAttackUnitType(upID, cUnitTypeLogicalTypeLandMilitary);
	kbUnitPickSetGoalCombatEfficiencyType(upID, cUnitTypeLogicalTypeLandMilitary);
	
	// Set the default target types and weights, for use until we've seen enough actual units.
	//   kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeLogicalTypeLandMilitary, 1.0);
	
	
	kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeSettler, 0.2);   // We need to build units that can kill settlers efficiently.
	kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeHussar, 0.2);    // Major component
	kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeMusketeer, 0.4); // Bigger component  
	kbUnitPickAddCombatEfficiencyType(upID, cUnitTypePikeman, 0.1);   // Minor component
	kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeCrossbowman, 0.1);   // Minor component
	kbUnitPickAddCombatEfficiencyType(upID, cUnitTypeGoldMiner, 0.0);   // Minor component
	
	
	setUnitPickerPreference(upID);  // Set generic preferences for this civ
	
	
	//Done.
	return(upID);
}

//==============================================================================
/*
	moveDefenseReflex(vector, radius, baseID)
	
	Move the defend and reserve plans to the specified location
	Sets the gLandDefendPlan0 to a high pop count, so it steals units from the reserve plan,
	which will signal the AI to not start new attacks as no reserves are available.
*/
//==============================================================================
void moveDefenseReflex(vector location=cInvalidVector, float radius=-1.0, int baseID=-1)
{
	if (radius < 0.0)
	radius = cvDefenseReflexRadiusActive;
	if (location != cInvalidVector)
	{
		aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, location);
		aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, radius);  
		aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, radius - 10.0);
		aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);
		
		aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, location);
		aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, radius);    
		aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, radius - 10.0);
		aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1);
		
		gDefenseReflex = true;
		gDefenseReflexBaseID = baseID;
		gDefenseReflexLocation = location;
		gDefenseReflexStartTime = xsGetTime();
		gDefenseReflexPaused = false;
	}
	//aiEcho("******** Defense reflex moved to base "+baseID+" with radius "+radius+" and location "+location);
}

//==============================================================================
/*
	pauseDefenseReflex()
	
	The base (gDefenseReflexBaseID) is still under attack, but we don't have enough
	forces to engage.  Retreat to main base, set a small radius, and wait until we 
	have enough troops to re-engage through a moveDefenseReflex() call.
	Sets gLandDefendPlan0 to high troop count to keep reserve plan empty.
	Leaves the base ID and location untouched, even though units will gather at home.
*/
//==============================================================================
void pauseDefenseReflex(void)
{
	vector loc = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));
	if ( gForwardBaseState != cForwardBaseStateNone )
	loc = gForwardBaseLocation;
	
	aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, loc);  
	aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusPassive);   
	aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusPassive - 10.0);
	
	aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, loc);
	aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusPassive);    
	aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusPassive - 10.0);   
	
	aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);
	aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1);
	
	
	gDefenseReflexPaused = true;
	
	//aiEcho("******** Defense reflex paused.");
}

//==============================================================================
/*
	endDefenseReflex()
	
	Move the defend and reserve plans to their default positions
*/
//==============================================================================
void endDefenseReflex(void)
{
	//return();
	vector resLoc = kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID));
	vector defLoc = kbBaseGetLocation(cMyID,kbBaseGetMainID(cMyID));
	if ( gForwardBaseState != cForwardBaseStateNone )
	{
		resLoc = gForwardBaseLocation;
		defLoc = gForwardBaseLocation;
	}
	aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, defLoc);  // Main base or forward base (if forward base exists)
	aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
	aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusActive - 10.0);
	aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary, 0, 0, 1);     // Defend plan will use 1 unit to defend against stray snipers, etc.
	
	aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, resLoc);  
	aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusPassive);   // Small radius
	aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusPassive - 10.0);
	aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary, 0, 0, 200);   // All unused troops
	
	//aiEcho("******** Defense reflex terminated for base "+gDefenseReflexBaseID+" at location "+gDefenseReflexLocation);
	//aiEcho("******** Returning to "+resLoc);
	//aiEcho(" Forward base ID is "+gForwardBaseID+", location is "+gForwardBaseLocation);
	
	gDefenseReflex = false;
	gDefenseReflexPaused = false;
	gDefenseReflexBaseID = -1;
	gDefenseReflexLocation = cInvalidVector;
	gDefenseReflexStartTime = -1;
}

rule endDefenseReflexDelay    // Use this instead of calling endDefenseReflex in the createMainBase function, so that the new BaseID will be available.
inactive
minInterval 1
{
	xsDisableSelf();
	endDefenseReflex();
}

int baseBuildingCount(int baseID = -1)
{
	int retVal = -1;
	
	if (baseID >= 0)  // Check for buildings in the base, regardless of player ID (only baseOwner can have buildings there)
	retVal = kbBaseGetNumberUnits(kbBaseGetOwner(baseID), baseID, cPlayerRelationAny, cUnitTypeBuilding);
	
	
	return(retVal);
}

//==============================================================================
// useLevy
//==============================================================================
rule useLevy
inactive
//group tcComplete
minInterval 10
{
	// Disable rule for native or Asian civs
	if ((civIsNative() == true) || (civIsAsian() == true))
	{
		xsDisableSelf();
		return;
	}
	
	// Check to see if town is being overrun.  If so, generate a plan
	// to 'research' levy.  If plan is active but enemies disappear, 
	// kill it.  Once research is complete, end this rule.
	
	static int levyPlan = -1;
	vector mainBaseVec = cInvalidVector;
	
	mainBaseVec =  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	
	int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, mainBaseVec, 40.0);
	int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, mainBaseVec, 40.0);
	
	
	/*
		if (kbTechGetStatus(cTechLevy) != cTechStatusActive) // this check does not work!
		{  // We're done, we've used levy
		aiEcho("   ** We've used levy, disabling useLevy rule.");
		xsDisableSelf();
		return;
		}  
	*/
	
	if (levyPlan < 0) // No plan, see if we need one.
	{
		if (enemyCount >= (allyCount+6)) // We're behind by 6 or more
		{
			//aiEcho("***** Starting a levy plan, there are "+enemyCount+" enemy units in my base against "+allyCount+" friendlies.");
			levyPlan = createSimpleResearchPlan(cTechLevy, getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
		}
	}
	else  // Plan exists, make sure it's still needed
	{
		if (enemyCount > (allyCount+2))
		{  // Do nothing
			aiEcho("   ** Still waiting for Levy.");
		}
		else
		{
			//aiEcho("   ** Cancelling levy.");
			aiPlanDestroy(levyPlan);
			levyPlan = -1;
		}
	}
}

//==============================================================================
/* mostHatedEnemy
	updatedOn 2020/01/24 By ageekhere  
*/
//==============================================================================
void mostHatedEnemy()
{ //find the ai's most hated enemy
	//Check if there is an enemy army near your main base, if so that player becomes the most hated
	int currentCount = -1;
	int lastCount = -1;
	int playerToCounter = -1;
	
	int currentScore = -1;
	int lastScore = -1;
	
	for (x = 1; < cNumberPlayers - 1)
	{ //loop through players
		if (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(x) && (x != cMyID) && kbHasPlayerLost(x) == false)
		{ //that are not on my team and is not me and are not dead
			currentCount = getUnitCountByLocation(cUnitTypeMilitary, x, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 150.0); //count the number of units
			if(currentCount > lastCount)
			{ //check army size to get largest army
				playerToCounter = x;
				lastCount = currentCount;
			}//end if
		}//end if
	} //end for
	
	
	if(lastCount > 6)
	{ //has to have a min of 6 units before changing most hated player
		aiSetMostHatedPlayerID(playerToCounter); //set the new most hated player and which ai to counter
		return; 
	} //end if
	
	for (x = 1; < cNumberPlayers - 1)
	{ //loop through players
		if (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(x) && (x != cMyID) && kbHasPlayerLost(x) == false && kbIsPlayerHuman(x) == true)
		{ //that are not on my team and is not me and are not dead
			currentScore = aiGetScore(x);
			if(lastScore < currentScore)
			{ //check army size to get largest army
				playerToCounter = x;
				lastScore = currentScore;
			}//end if
		}//end if
	} //end for
	if(playerToCounter != -1)
	{
		aiSetMostHatedPlayerID(playerToCounter);
	}
	
	
	
	//-- use old method if under 6 
	if ( (cvPlayerToAttack > 0) && (kbHasPlayerLost(cvPlayerToAttack) == false) )
	{
		//aiEcho("****  Changing most hated enemy from "+aiGetMostHatedPlayerID()+" to "+cvPlayerToAttack);
		aiSetMostHatedPlayerID(cvPlayerToAttack);
		return;
	}
	// For now, find your position in your team (i.e. 2nd of 3) and
	// target the corresponding player on the other team.  If the other
	// team is smaller, count through again.  (I.e. in a 5v2, player 5 on
	// one team will attack the 1st player on the other.)
	
	int ourTeamSize = 0;
	int theirTeamSize = 0;
	int myPosition = 0;
	int i=0;
	
	for (i=1; <cNumberPlayers)
	{
		if (kbHasPlayerLost(i) == false)
		{
			if ( kbGetPlayerTeam(i) == kbGetPlayerTeam(cMyID) )
			{  // Self or ally 
				ourTeamSize = ourTeamSize + 1;
				if ( i == cMyID )
				myPosition = ourTeamSize;   
			}
			else
			{
				theirTeamSize = theirTeamSize + 1;
			}
		}
	}
	//updatedOn 2019/03/29 By ageekhere  
	//---------------------------
	ourTeamSizeMain = ourTeamSize;
	//---------------------------
	int targetPlayerPosition = 0;
	
	if (myPosition > theirTeamSize)
	{
		targetPlayerPosition = myPosition - (theirTeamSize * (myPosition/theirTeamSize));      // myPosition modulo theirTeamSize
		if (targetPlayerPosition == 0)
		targetPlayerPosition = theirTeamSize;  // Need to be in range 1...teamsize, not 0...(teamSize-1).
	}
	else
	targetPlayerPosition = myPosition;
	
	int playerCount = 0;
	// Find the corresponding enemy player
	for (i=1; <cNumberPlayers)
	{
		if ( (kbHasPlayerLost(i) == false) && (kbGetPlayerTeam(i) != kbGetPlayerTeam(cMyID) ) )
		{
			playerCount = playerCount + 1;
			if (playerCount == targetPlayerPosition)
			{ 
				if (aiGetMostHatedPlayerID() != i)
				aiEcho("****  Changing most hated enemy from "+aiGetMostHatedPlayerID()+" to "+i);
				aiSetMostHatedPlayerID(i);
				if (gLandUnitPicker >= 0)
				kbUnitPickSetEnemyPlayerID(gLandUnitPicker, i); // Update the unit picker
			}
		}
	}   
}

//==============================================================================
// initMil
//==============================================================================
void initMil(void)
{
	aiSetAttackResponseDistance(70.0);
	
	// Choose a most-hated player
	xsEnableRule("mostHatedEnemy");
	
	// Call it immediately
	mostHatedEnemy();   
	
	//Auto gather our military units.
	aiSetAutoGatherMilitaryUnits(true);
}

//==============================================================================
/* Defend0
	
	Create a defend plan, protect the main base.
*/
//==============================================================================
rule defend0
inactive
group startup
minInterval 13
{  
	if (gLandDefendPlan0 < 0)
	{
		gLandDefendPlan0 = aiPlanCreate("Primary Land Defend", cPlanDefend);
		aiPlanAddUnitType(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary , 0, 0, 1);    // Small, until defense reflex
		
		aiPlanSetVariableVector(gLandDefendPlan0, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
		aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
		aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusActive - 10.0);
		aiPlanSetVariableBool(gLandDefendPlan0, cDefendPlanPatrol, 0, false);
		aiPlanSetVariableFloat(gLandDefendPlan0, cDefendPlanGatherDistance, 0, 20.0);
		aiPlanSetInitialPosition(gLandDefendPlan0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
		aiPlanSetUnitStance(gLandDefendPlan0, cUnitStanceDefensive);
		aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanRefreshFrequency, 0, 5);
		aiPlanSetVariableInt(gLandDefendPlan0, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
		aiPlanSetDesiredPriority(gLandDefendPlan0, 10);    // Very low priority, don't steal from attack plans
		aiPlanSetActive(gLandDefendPlan0); 
		//aiEcho("Creating primary land defend plan");
		
		gLandReservePlan = aiPlanCreate("Land Reserve Units", cPlanDefend);
		aiPlanAddUnitType(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary , 0, 5, 200);    // All mil units, high MAX value to suck up all excess
		
		aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
		if(kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)) == cInvalidVector)
		if (getUnit(cUnitTypeAIStart, cMyID) >= 0)   // If no mil gather point, but there is a start block, use it.
		aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, kbUnitGetPosition(getUnit(cUnitTypeAIStart, cMyID)));
		if (aiPlanGetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0) == cInvalidVector) // If all else failed, use main base location.
		aiPlanSetVariableVector(gLandReservePlan, cDefendPlanDefendPoint, 0, kbBaseGetLocation(kbBaseGetMainID(cMyID)));
		aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanEngageRange, 0, 60.0);    // Loose
		aiPlanSetVariableBool(gLandReservePlan, cDefendPlanPatrol, 0, false);
		aiPlanSetVariableFloat(gLandReservePlan, cDefendPlanGatherDistance, 0, 20.0);
		aiPlanSetInitialPosition(gLandReservePlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
		aiPlanSetUnitStance(gLandReservePlan, cUnitStanceDefensive);
		aiPlanSetVariableInt(gLandReservePlan, cDefendPlanRefreshFrequency, 0, 5);
		aiPlanSetVariableInt(gLandReservePlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
		aiPlanSetDesiredPriority(gLandReservePlan, 5);    // Very very low priority, gather unused units.
		aiPlanSetActive(gLandReservePlan); 
		if (gMainAttackGoal >= 0)
		aiPlanSetVariableInt(gMainAttackGoal, cGoalPlanReservePlanID, 0, gLandReservePlan);
		//aiEcho("Creating reserve plan");
		xsEnableRule("endDefenseReflexDelay"); // Reset to relaxed stances after plans have a second to be created.
	}
}

//==============================================================================
// General strategy (spans econ/mil)
//==============================================================================

//==============================================================================
/* getActiveMissionCount(int missionType)
	
	Returns the number of active missions that match the optional type.  If no types
	is given, returns the total number of missions.
*/
//==============================================================================
/*int getActiveMissionCount(int missionType=-1)
	{
	int retVal = 0;
	
	int missionCount = 0;
	int missionIndex = 0;
	int missionID = -1;
	
	for (missionIndex = 0; < aiPlanGetNumber(cPlanMission, -1, true))    // Step through all mission plans.  -1 means any state is OK.
	{
	missionID = aiPlanGetIDByIndex(cPlanMission, -1, true, missionIndex);
	if ( (missionType == -1) || (aiPlanGetVariableInt(missionID, cMissionPlanType, 0) == missionType) )   // No type specified, or type matches
	retVal = retVal + 1;
	}      
	
	return(retVal);
}*/


void setMilPopLimit(int age1=10, int age2=40, int age3=80, int age4=120, int age5=140)
{
	int limit = 10;
	int age = kbGetAge();
	if (age == cvMaxAge)
	age = cAge5;   // If we're at the highest allowed age, go for our full mil pop.
	// This overrides the normal settings, so an SPC AI capped at age 3 can use his full
	// military pop.
	switch(age)
	{
		case cAge1:
		{
			limit = age1;
			break;
		}
		case cAge2:
		{
			limit = age2;
			break;
		}
		case cAge3:
		{
			limit = age3;
			break;
		}
		case cAge4:
		{
			limit = age4;
			break;
		}
		case cAge5:
		{
			limit = age5;
			break;
		}
	}
	if ( (cvMaxArmyPop >= 0) && (cvMaxNavyPop >= 0) && (limit > (cvMaxArmyPop + cvMaxNavyPop)) )
	limit = cvMaxArmyPop+cvMaxNavyPop;     // Manual pop limits have been set
	
	if ( (cvMaxNavyPop <= 0) && (cvMaxArmyPop < limit) && (cvMaxArmyPop >= 0) )  // Only army pop set?
	limit = cvMaxArmyPop;
	
	aiSetMilitaryPop(limit);
}

//==============================================================================
/* townCenterComplete
	
	Wait until the town center is complete, then build other stuff next to it.
	In a start with a TC, this will fire very quickly.
	In a scenario with no TC, we do the best we can.
	
*/
//==============================================================================

rule townCenterComplete
active
minInterval 10
{
	// First, create a query if needed, then use it to look for a completed town center
	static int townCenterQuery = -1;
	if (townCenterQuery < 0)
	{
		townCenterQuery=kbUnitQueryCreate("Completed Town Center Query");
		kbUnitQuerySetIgnoreKnockedOutUnits(townCenterQuery, true);
		if (townCenterQuery < 0)
		aiEcho("****  Query create failed in townCenterComplete.");
		//Define the query
		if (townCenterQuery != -1)
		{
			kbUnitQuerySetPlayerID(townCenterQuery, cMyID);
			kbUnitQuerySetUnitType(townCenterQuery, gTownCenter);
			kbUnitQuerySetState(townCenterQuery, cUnitStateAlive);
		}
	}
	
	// Run the query
	kbUnitQueryResetResults(townCenterQuery);
	int count = kbUnitQueryExecute(townCenterQuery);
	
	//-- If our startmode is one without a TC, wait until a TC is found.
	if ((count < 1) && (gStartMode != cStartModeScenarioNoTC) )
	return;
	int tcID = kbUnitQueryGetResult(townCenterQuery, 0);
	//aiEcho("New TC is "+tcID+" at "+kbUnitGetPosition(tcID));
	
	
	if (tcID >= 0)
	{
		int tcBase = kbUnitGetBaseID(tcID);
		gMainBase = kbBaseGetMainID(cMyID);
		//aiEcho(" TC base is "+tcBase+", main base is "+gMainBase);
		// We have a TC.  Make sure that the main base exists, and it includes the TC
		if ( gMainBase < 0 )
		{  // We have no main base, create one
			gMainBase = createMainBase(kbUnitGetPosition(tcID));
			//aiEcho(" We had no main base, so we created one: "+gMainBase);
		}
		tcBase = kbUnitGetBaseID(tcID);  // in case base ID just changed
		
		if ( tcBase != gMainBase ) 
		{
			//aiEcho(" TC "+tcID+" is not in the main base ("+gMainBase+".");
			//aiEcho(" Setting base "+gMainBase+" to non-main, setting base "+tcBase+" to main.");
			kbBaseSetMain(cMyID, gMainBase, false);
			aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeEasy, gMainBase);
			aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHunt, gMainBase);
			aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeHerdable, gMainBase);
			aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFish, gMainBase);
			aiRemoveResourceBreakdown(cResourceFood, cAIResourceSubTypeFarm, gMainBase);
			aiRemoveResourceBreakdown(cResourceWood, cAIResourceSubTypeEasy, gMainBase);
			aiRemoveResourceBreakdown(cResourceGold, cAIResourceSubTypeEasy, gMainBase);
			kbBaseSetMain(cMyID, tcBase, true);
			gMainBase = tcBase;
		}
	}
	else
	{
		aiEcho("No TC, leaving main base as it is.");
		
	}
	
	kbBaseSetMaximumResourceDistance(cMyID, kbBaseGetMainID(cMyID), 150.0);
	
	
	// Set up the escrows
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceFood, .70);
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceWood, .50);   
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceGold, .30);
	kbEscrowSetPercentage(cEconomyEscrowID, cResourceShips, 0.0);
	kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 200);
	kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 200);
	if (kbGetCiv() == cCivDutch)
	{
		kbEscrowSetCap(cEconomyEscrowID, cResourceFood, 350); // Needed for banks
		kbEscrowSetCap(cEconomyEscrowID, cResourceWood, 350);
	}
	kbEscrowSetCap(cEconomyEscrowID, cResourceGold, 200);
	
	
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceFood, .0);
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceWood, .0);  
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceGold, .0);
	kbEscrowSetPercentage(cMilitaryEscrowID, cResourceShips, 0.0);
	kbEscrowSetCap(cMilitaryEscrowID, cResourceFood, 300);
	kbEscrowSetCap(cMilitaryEscrowID, cResourceWood, 300);
	kbEscrowSetCap(cMilitaryEscrowID, cResourceGold, 300);
	
	kbEscrowAllocateCurrentResources();
	
	
	
	// Town center found, start building the other buildings
	xsDisableSelf();
	xsEnableRuleGroup("tcComplete");
	
	if (kbGetCiv() == cCivOttomans)
	xsEnableRule("ottomanMonitor");
	
	gSettlerMaintainPlan = createSimpleMaintainPlan(gEconUnit, kbGetBuildLimit(cMyID, gEconUnit), true, kbBaseGetMainID(cMyID), 1); 
	if (kbGetCiv() == cCivOttomans)
	aiPlanSetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0, 0); // To not throw off resource planning
	
	if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)
	gWaterTransportUnitMaintainPlan = createSimpleMaintainPlan(gCaravelUnit, 1, true, kbBaseGetMainID(cMyID), 1);
	
	if (aiGetGameMode() == cGameModeDeathmatch)
	deathMatchSetup();   // Add a bunch of custom stuff for a DM jump-start.
	
	if (kbUnitCount(cMyID, cUnitTypeypDaimyoRegicide, cUnitStateAlive) > 0)   
	xsEnableRule("regicideMonitor");
	
	if (cRandomMapName=="honshu" || cRandomMapName=="regicidehonshu")
	{
		createSimpleBuildPlan(gDockUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		xsEnableRule("navyManager");
	}
	if (cRandomMapName=="ceylon")
	xsEnableRule("navyManager");
	
}

//==============================================================================
// useFactoryWagons
// updatedOn 2020/03/09 By ageekhere
//==============================================================================
//rule useFactoryWagons
//inactive
//minInterval 5
extern int factoryWagonId = -1;
void useFactoryWagons()
{
	int wagon = getUnit(cUnitTypeFactoryWagon, cMyID, cUnitStateAlive);																													
	if ( (wagon >= 0) && (factoryWagonId != wagon) )
	{
		factoryWagonId = wagon;
		int planID = createLocationBuildPlan(cUnitTypeFactory, 1, 100, false, cRootEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1); //build in base
		aiPlanAddUnitType(planID, cUnitTypeFactoryWagon, 1, 1, 1); //Add unit to plan
	}	
}

//==============================================================================
// useBankWagons
// updatedOn 2020/03/15 By ageekhere
//==============================================================================
void useBankWagons()
{
	if(kbGetAge() < cAge2 || kbGetCiv() != cCivDutch) return;
	int sendBank = -1;
	sendBank = kbUnitQueryCreate("sendBank");
	kbUnitQuerySetPlayerID(sendBank, cMyID, false);
	kbUnitQuerySetUnitType(sendBank, cUnitTypeBankWagon);
	kbUnitQuerySetState(sendBank, cUnitStateAlive);
	kbUnitQuerySetActionType(sendBank,7);
	
	int sendBank2 = -1;
	sendBank2 = kbUnitQueryCreate("sendBank2");
	kbUnitQuerySetPlayerID(sendBank2, cMyID, false);
	kbUnitQuerySetUnitType(sendBank2, cUnitTypeypBankWagon);
	kbUnitQuerySetState(sendBank2, cUnitStateAlive);
	kbUnitQuerySetActionType(sendBank2,7);
	
	int banktype1 = kbUnitQueryExecute(sendBank);
	int banktype2 = kbUnitQueryExecute(sendBank2);
	int totalWagons = banktype1 + banktype2;
	int buildLimit = kbGetBuildLimit(cMyID, cUnitTypeBank);
	
	int total = 0;
	if(kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) == buildLimit)return;
	
	if(totalWagons > buildLimit)total = buildLimit;
	if(totalWagons <= buildLimit)total = totalWagons;
	
	if (total > 0)
	{
		createLocationBuildPlan(cUnitTypeBank, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1); //build in base
	}	
	
}


//==============================================================================
// useCoveredWagons
// updatedOn 2020/03/09 By ageekhere
//==============================================================================
extern int coveredWagonId = -1;
void useCoveredWagons()
{ // Handle nomad start, extra covered wagons.
	int coveredWagon = getUnit(gCoveredWagonUnit, cMyID, cUnitStateAlive);
	if(kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) == 0) return;
	if (coveredWagon == -1)return;
	//if ( (coveredWagon >= 0) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gTownCenter) < 0) )// Check if we have a covered wagon, but no TC build plan....
	if ( (coveredWagon >= 0) && (coveredWagonId != coveredWagon) )
	{
		coveredWagonId = coveredWagon;
		// We need to figure out where to put the new TC.  Start with the current main base as an anchor.
		// From that, check all gold mines within 100 meters and on the same area group.  For each, see if there
		// is a TC nearby, if not, do it.  
		// If all gold mines fail, use the main base location and let it sort it out in the build plan, i.e. TCs repel, gold attracts, etc.
		static int mineQuery = -1;
		if (mineQuery < 0)
		{
			mineQuery = kbUnitQueryCreate("Mine query for TC placement");
			kbUnitQuerySetPlayerID(mineQuery, 0);
			kbUnitQuerySetUnitType(mineQuery, cUnitTypeMine);
			kbUnitQuerySetMaximumDistance(mineQuery, 100.0);
			kbUnitQuerySetAscendingSort(mineQuery, true);   // Ascending distance from initial location
		}
		kbUnitQuerySetPosition(mineQuery, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
		kbUnitQueryResetResults(mineQuery);
		int mineCount = kbUnitQueryExecute(mineQuery);
		int i = 0;
		int mineID = -1;
		vector loc = cInvalidVector;
		int mineAreaGroup = -1;
		int mainAreaGroup = kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
		bool found = false;
		for (i=0; < mineCount)
		{  // Check each mine for a nearby TC, i.e. w/in 30 meters.
			mineID = kbUnitQueryGetResult(mineQuery, i);
			loc = kbUnitGetPosition(mineID);
			mineAreaGroup = kbAreaGroupGetIDByPosition(loc);
			if ( (getUnitByLocation(gTownCenter, cPlayerRelationAny, cUnitStateABQ, loc, 30.0) < 0) && (mineAreaGroup == mainAreaGroup) )
			{
				found = true;
				break;
			}
		}
		// If we found a mine without a nearby TC, use that mine's location.  If not, use the main base.
		if (found == false) loc = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
		if(loc == cInvalidVector) loc = kbUnitGetPosition(coveredWagon);
		gTCSearchVector = loc;		
		aiTaskUnitMove(coveredWagon, gTCSearchVector);
		startTCBuildPlan(gTCSearchVector);  
	}
}

//==============================================================================
/* House monitor
	
	Make sure we have a house build plan active, regardless of the number of houses.
*/
//==============================================================================
rule houseMonitor
inactive
group tcComplete
minInterval 5
{ 
	if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 1) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) >= 1))
	return;  // Dutch need bank before getting extra houses
	
	if (kbGetBuildLimit(cMyID, gHouseUnit) <= kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive))
	return;     // Don't build if we're at limit.
	
	int houseBuildPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit);
	
	//updatedOn 2019/05/06 By ageekhere  
	//---------------------------
	if(houseBuildPlanID < 0 && kbGetCiv() != cCivBritish && (kbGetPopCap()-kbGetPop()) < 7)
	{
		createLocationBuildPlan(gHouseUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
		//createSimpleBuildPlan(gHouseUnit, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	}   
	//else if ( (houseBuildPlanID < 0) && ( (kbGetPopCap()-kbGetPop()) < (15 + (10*kbGetAge())) ) && (kbGetCiv() == cCivBritish || kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 1))   // None in progress, and pop headroom < 15 in cAge1, etc.  
	else if (houseBuildPlanID < 0 && kbGetCiv() == cCivBritish)   // None in progress, and pop headroom < 15 in cAge1, etc.  
	{  // Start a new one  	
		createLocationBuildPlan(gHouseUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
		//createSimpleBuildPlan(gHouseUnit, 1, 95, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		//aiEcho("Starting a new house build plan.");
	}
	
	if(kbGetAge() >= cAge4)
	{
		createLocationBuildPlan(gHouseUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
	}
	//---------------------------
}

//==============================================================================
/* Monastery monitor
	
	Make sure we have a Monastery around, and research healing upgrades for 
	Indians and Japanese. (All other upgrades are useless for the AI.)
	
*/
//==============================================================================
rule monasteryMonitor
inactive
minInterval 60
{
	int upgradePlanID = -1;
	
	// Disable rule for non-Asian civs
	if (civIsAsian() == false)
	{
		xsDisableSelf();
		return;
	}
	
	// Build a monastery if there is none
	if ( (kbUnitCount(cMyID, cUnitTypeypMonastery, cUnitStateABQ) < 1) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypMonastery) < 0) ) 
	{
		createSimpleBuildPlan(cUnitTypeypMonastery, 1, 80, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		//aiEcho("Starting a new monastery build plan.");
	}
	
	// Research monk healing upgrades for Indians and Japanese
	if (kbTechGetStatus(cTechypMonasteryImprovedHealing) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryImprovedHealing);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypMonasteryImprovedHealing, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechypMonasteryJapaneseHealing) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMonasteryJapaneseHealing);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypMonasteryJapaneseHealing, getUnit(cUnitTypeypMonastery), cMilitaryEscrowID, 50);
		return;
	}
}

//==============================================================================
/* BHG Consulate monitor
	
	Make sure we have a Consulate around.
	Research Consulate Techs as appropriate.
	
*/
//==============================================================================
rule consulateMonitor
inactive
minInterval 45
{
	// Disable rule for non-Asian civilizations
	if (civIsAsian() == false) 
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if consulate is not allowed and not already built
	if ((cvOkToBuildConsulate == false) && (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) == 0)) 
	{
		return;
	}
	
	// Build a consulate if there is none
	if ((kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateABQ) < 1) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypConsulate) < 0))
	{
		createSimpleBuildPlan(cUnitTypeypConsulate, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		//aiEcho("Starting a new consulate build plan.");
	}
	
	// If no option has been chosen already, choose one now
	if ((kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) > 0) && (gFlagChosen == false))
	{
		chooseConsulateFlag();
	}
	
	// Maximize export generation in Age 4 and above
	if (kbGetAge() >= cAge4)
	{
		int consulateQueryID = -1;
		
		consulateQueryID = kbUnitQueryCreate("consulateGetUnitQuery");
		kbUnitQuerySetIgnoreKnockedOutUnits(consulateQueryID, true);
		
		//Define a query to get consulate
		if (consulateQueryID != -1)
		{
			kbUnitQuerySetPlayerRelation(consulateQueryID, -1);
			kbUnitQuerySetPlayerID(consulateQueryID, cMyID);
			kbUnitQuerySetUnitType(consulateQueryID, cUnitTypeypConsulate);
			kbUnitQuerySetState(consulateQueryID, cUnitStateAlive);
			kbUnitQueryResetResults(consulateQueryID);
			int numberFound = kbUnitQueryExecute(consulateQueryID);
			
			// Set export gathering rate to +60 %
			if (numberFound > 0)
			{
				aiUnitSetTactic(kbUnitQueryGetResult(consulateQueryID, 0), cTacticTax10);
			}
		}
	}
	
	// Research consulate technologies one at a time
	// Unavailable techs are simply ignored
	int upgradePlanID = -1;
	
	// British technologies
	// (none)
	
	// Dutch technologies
	// (bank wagon, arsenal wagon, church wagon)
	if (kbTechGetStatus(cTechypConsulateDutchSaloonWagon) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchSaloonWagon);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateDutchSaloonWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechypConsulateDutchArsenalWagon) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchArsenalWagon);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateDutchArsenalWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechypConsulateDutchChurchWagon) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateDutchChurchWagon);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateDutchChurchWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
		return;
	}
	
	// French technologies
	// (none)
	
	// German technologies
	// (none)
	
	// Japanese isolation technologies
	// (Clan offerings)
	if ((kbTechGetStatus(cTechypConsulateJapaneseKoujou) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) >= 5))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateJapaneseKoujou);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateJapaneseKoujou, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// Ottoman technologies
	// (Great bombards)
	if (kbTechGetStatus(cTechypConsulateOttomansGunpowderSiege) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansGunpowderSiege);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateOttomansGunpowderSiege, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// Portuguese technologies
	// (Ironclad)
	if ((kbTechGetStatus(cTechypConsulatePortugueseExpeditionaryFleet) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag, cUnitStateAlive) > 0))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseExpeditionaryFleet);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulatePortugueseExpeditionaryFleet, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// Russian technologies
	// (fort wagon, factory wagon, blockhouse wagon)
	if (kbTechGetStatus(cTechypConsulateRussianFortWagon) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianFortWagon);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateRussianFortWagon, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechypConsulateRussianFactoryWagon) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianFactoryWagon);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateRussianFactoryWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechypConsulateRussianOutpostWagon) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianOutpostWagon);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypConsulateRussianOutpostWagon, getUnit(cUnitTypeypConsulate), cEconomyEscrowID, 50);
		return;
	}
	
	// Spanish technologies
	// (none)
}

//==============================================================================
/* BHG Rickshaw monitor
	
	If theres a rickshaw, try to use it
	
*/
//==============================================================================
rule rickshawMonitor
inactive
group tcComplete
minInterval 30
{ 
	if (civIsAsian() == false) { //don't need to be here unless we're Asian
		xsDisableSelf();
		return;
	}
	
	if (kbUnitCount(cMyID, cUnitTypeYPMilitaryRickshaw, cUnitStateAlive) > 0)
    createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
    
	if (kbUnitCount(cMyID, cUnitTypeYPDojoWagon, cUnitStateAlive) > 0)
    createSimpleBuildPlan(cUnitTypeypDojo, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
}

//==============================================================================
/* BHG regicide monitor
	
	Pop the regent in the castle
	
*/
//==============================================================================
rule regicideMonitor
inactive
minInterval 10
{ 
	//if the castle is up, put the guy in it
	
	if (kbUnitCount(cMyID, cUnitTypeypCastleRegicide, cUnitStateAlive) > 0) {
		//gotta find the castle
		static int castleQueryID=-1;
		//If we don't have the query yet, create one.
		if (castleQueryID < 0)
		{
			castleQueryID=kbUnitQueryCreate("castleGetUnitQuery");
			kbUnitQuerySetIgnoreKnockedOutUnits(castleQueryID, true);
		}
		//Define a query to get all matching units
		if (castleQueryID != -1) {
			kbUnitQuerySetPlayerRelation(castleQueryID, -1);
			kbUnitQuerySetPlayerID(castleQueryID, cMyID);
			kbUnitQuerySetUnitType(castleQueryID, cUnitTypeypCastleRegicide);
			kbUnitQuerySetState(castleQueryID, cUnitStateAlive);
		}
		else {
			return;
		}
		
		//gotta find the regent
		static int regentQueryID=-1;
		//If we don't have the query yet, create one.
		if (regentQueryID < 0)
		{
			regentQueryID=kbUnitQueryCreate("regentGetUnitQuery");
			kbUnitQuerySetIgnoreKnockedOutUnits(regentQueryID, true);
		}
		//Define a query to get all matching units
		if (regentQueryID != -1) {
			kbUnitQuerySetPlayerRelation(regentQueryID, -1);
			kbUnitQuerySetPlayerID(regentQueryID, cMyID);
			kbUnitQuerySetUnitType(regentQueryID, cUnitTypeypDaimyoRegicide);
			kbUnitQuerySetState(regentQueryID, cUnitStateAlive);
		}
		else {
			return;
		}
		
		
		kbUnitQueryResetResults(castleQueryID);
		kbUnitQueryResetResults(regentQueryID);
		
		kbUnitQueryExecute(castleQueryID);
		kbUnitQueryExecute(regentQueryID);
		
		int index = 0;
		
		aiTaskUnitWork(kbUnitQueryGetResult(regentQueryID, index), kbUnitQueryGetResult(castleQueryID, index));
	}
	else {
		xsDisableSelf();
	}
}

//==============================================================================
/* BHG orchard monitor
	
	If we have a wagon, build an orchard immediately.
	
*/
//==============================================================================
rule orchardMonitor
inactive
group tcComplete
minInterval 5
{ 
	if (kbUnitCount(cMyID, cUnitTypeYPBerryWagon1, cUnitStateAlive) > 0) {
		createSimpleBuildPlan(cUnitTypeypBerryBuilding, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	}
}

//==============================================================================
/* Building monitor
	
	Make sure we have the right number of buildings, or at least a build plan,
	for each required building type.
	
*/
//==============================================================================
rule buildingMonitor
inactive
group tcComplete
minInterval 5
{
	int planID = -1;
	static bool buildPlan = false;
	if (cvOkToBuild == false)
	return;
	
	if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
	return;  
	
	// if Dutch, add banks to the build limit.
	if (kbGetCiv() == cCivDutch)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBank);
		if(buildPlan == true)
		{
			if(getUnit(cUnitTypeBankWagon, cMyID, cUnitStateAlive) != -1 || getUnit(cUnitTypeypBankWagon, cMyID, cUnitStateAlive) != -1)  
			{
				buildPlan = false;
				aiPlanDestroy(planID);
			}
		}		
		
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeBank)) && buildPlan == false)  // If I'm not building one and I could be, do it.
		{     // Start a new one
			if ( kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) < ((kbGetAge()*2) + 1) )
			{  // Less than 1 bank in age 1 (0*2+1), less than 3 in age 2, etc.
				
				if(getUnit(cUnitTypeBankWagon, cMyID, cUnitStateAlive) == -1 && getUnit(cUnitTypeypBankWagon, cMyID, cUnitStateAlive) == -1) 
				{	
					createLocationBuildPlan(cUnitTypeBank, 1, 93, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
					buildPlan = true;
				}
				//createSimpleBuildPlan(cUnitTypeBank, 1, 93, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1); // Very high pri, just below houses
				//aiEcho("Starting a new bank build plan.");
			}
		}     
	}
	
	if ( (kbGetCiv() == cCivDutch) && (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ) < 1) )
	return;
	
	// Mosque construction for Ottomans is handled in ottomanMonitor rule, do not build mosques here
	// Construction of monastery and consulate for Asians is handled in monasteryMonitor and consulateMonitor rules
	
	
   	//updatedOn 2019/05/03 By ageekhere  
	//--------------------------- 
	// At least one market
	planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gMarketUnit);
	if ( (planID < 0) && (kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) < 1) )
	{// Start a new one
		createSimpleBuildPlan(gMarketUnit, 1, 96, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);  // Just higher than house
		//aiEcho("Starting a new market build plan.");
	}   
	//--------------------------- 
	
	// That's it for age 1
	if (kbGetAge() < cAge2) 
	return;
	// ***************************************************
	
	
	// If native, at least one fire pit   
	planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFirePit);
	
	if ( civIsNative() == true ) 
	{
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateAlive) < 1) && (kbUnitCount(cMyID, gHouseUnit, cUnitStateAlive) > 0) )
		{     // Start a new one if we have at least one house.
			createSimpleBuildPlan(cUnitTypeFirePit, 1, 92, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1); 
			//aiEcho("Starting a new firepit build plan.");
		}   
		if (cMyCiv == cCivXPSioux)
		{
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateAlive) < 1) )
			{     // Start a new one even without house.
				createSimpleBuildPlan(cUnitTypeFirePit, 1, 92, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1); 
				//aiEcho("Starting a new firepit build plan.");
			}   
		}
	}
	
	/*
		// At least one market
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gMarketUnit);
		if ( (kbGetPopCap()-kbGetPop()) > 20 ) // If we're OK on houses...
		{
		if ( (planID < 0) && (kbUnitCount(cMyID, gMarketUnit, cUnitStateAlive) < 1) )
		{     // Start a new one
		createSimpleBuildPlan(gMarketUnit, 1, 96, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);  // Just higher than house
		aiEcho("Starting a new market build plan.");
		}   
		}
	*/ 
	
	
	// At least one stable, corral or caravanserai
	if ( (civIsNative() == true) )
	{  // Natives, at least 1 corral
		if (cMyCiv != cCivXPAztec)
		{
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCorral);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateAlive) < 1) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeCorral, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new corral build plan.");
			}  
		}
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypStableJapanese);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateAlive) < 1) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new dojo build plan.");
			}
		}
		else if ( (cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCaravanserai);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateAlive) < 1) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new Caravanserai build plan.");
			}
		}
	}
	else 
	{      
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeStable);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateAlive) < 1) && (civIsNative() == false) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeStable, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new stable build plan.");
		}
	}
	
	// If Russian, at least 1 block house
	if (kbGetCiv() == cCivRussians)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBlockhouse);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateAlive) < 2) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeBlockhouse, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new blockhouse build plan.");
		}   
	}
	else if ( civIsNative() == true )
	{  // Natives, at least 1 war hut
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) < 2) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeWarHut, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new war hut build plan.");
		}  
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBarracksJapanese);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateAlive) < 2) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new bansho build plan.");
			}
		}
		else if ( (cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypWarAcademy);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateAlive) < 2) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new war academy build plan.");
			}
		}
		else {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPBarracksIndian);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateAlive) < 2) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new indian barracks build plan.");
			}
		}
	}
	else // every other civ gets a barracks.
	{
		// At least 1 barracks
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBarracks);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateAlive) < 2) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeBarracks, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new barracks build plan.");
		}
	}
	// Mill construction is handled in updateFoodBreakdown, do not build mills here
	
	// Livestock pen if we own critters (Europeans and Indians only)
	int livestockMinimum = 6;
	if (kbGetCiv() == cCivIndians)
	livestockMinimum = 4;
	planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gLivestockPenUnit);
	if ( (planID < 0) && (kbUnitCount(cMyID, gLivestockPenUnit, cUnitStateAlive) < 1) && (kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive) >= livestockMinimum) )
	{     // Start a new one
		if ((cMyCiv == cCivXPAztec) || (cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPSioux) || (kbGetCiv() == cCivIndians))
		{
			createSimpleBuildPlan(gLivestockPenUnit, 1, 65, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new livestock pen build plan.");
		}
	}
    // At least one church (not for natives or Asians)
	
	if ((civIsNative() == false) && (civIsAsian() == false))
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeChurch, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new church build plan.");
		}
	}
	
	// That's it for age 2
	if (kbGetAge() < cAge3)
	return;
	// **********************************************************
	
	
  	if ((civIsNative() == false) && (civIsAsian() == false))
         {
            if (kbUnitCount(cMyID, cUnitTypeSPCFortCenter, cUnitStateABQ) < 1)
               addItemToForecasts(cUnitTypeSPCFortCenter, 1);
			   createSimpleBuildPlan(cUnitTypeSPCFortCenter, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         }
		 if (civIsNative() == true)
         {
            if (kbUnitCount(cMyID, cUnitTypeNativeEmbassy, cUnitStateABQ) < 1)
			   createSimpleBuildPlan(cUnitTypeNativeEmbassy, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
         }
	// If Russian, at least 2 blockhouses
	if (kbGetCiv() == cCivRussians)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBlockhouse);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateAlive) < 3) )
		{ 
			createSimpleBuildPlan(cUnitTypeBlockhouse, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new blockhouse build plan.");
		}   
	}
	else if ( civIsNative() == true ) // Natives, at least 2 war huts
	{  
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) < 3) )
		{
			createSimpleBuildPlan(cUnitTypeWarHut, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new war hut build plan.");
		}  
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBarracksJapanese);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateAlive) < 3) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new bansho build plan.");
			}
		}
		else if ( (cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypWarAcademy);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateAlive) < 3) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new war academy build plan.");
			}
		}
		else {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPBarracksIndian);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateAlive) < 3) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new indian barracks build plan.");
			}
		}
	}
	else // Every other civ, at least 2 barracks.
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBarracks);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateAlive) < 3) )
		{
			createSimpleBuildPlan(cUnitTypeBarracks, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new barracks build plan.");
		}
	}
	
	// At least two stables, corrals or caravanserais
	if ( (civIsNative() == true) )
	{  // Natives, at least 2 corrals
		if (cMyCiv != cCivXPAztec)
		{
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCorral);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateAlive) < 2) )
			{
				createSimpleBuildPlan(cUnitTypeCorral, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new corral build plan.");
			}  
		}
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypStableJapanese);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateAlive) < 2) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new dojo build plan.");
			}
		}
		else if ( (cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCaravanserai);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateAlive) < 2) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new Caravanserai build plan.");
			}
		}
	}
	else 
	{      
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeStable);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateAlive) < 2) )
		{
			createSimpleBuildPlan(cUnitTypeStable, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new stable build plan.");
		}
	}
	/* //moved to age 4
		// At least one arsenal (not for natives or Asians)
		if ((civIsNative() == false) && (civIsAsian() == false))
		{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArsenal);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateAlive) < 1) )
		{     // Start a new one
		createSimpleBuildPlan(cUnitTypeArsenal, 1, 60, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
		//aiEcho("Starting a new arsenal build plan.");
		}
		}
	*/
	
	
	// At least one basilica for Italians
	if (cMyCiv == cCivItalians)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBasilicaIt);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBasilicaIt, cUnitStateAlive) < 1) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeBasilicaIt, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new basilica build plan.");
		}
	}
	
	// At least one native embassy (natives only)
	if (civIsNative() == true) {
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNativeEmbassy);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeNativeEmbassy, cUnitStateAlive) < 1) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeNativeEmbassy, 1, 60, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new native embassy build plan.");
		}
	}
	
	// At least two nobles huts for Aztecs
	if (cMyCiv == cCivXPAztec)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNoblesHut);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateAlive) < 2) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new nobles hut build plan.");
		}   
	}
	
	// At least one livestock pen (natives only)
	if (civIsNative() == true) {
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeLivestockPen);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeLivestockPen, cUnitStateAlive) < 1) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeLivestockPen, 1, 60, false, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new livestock pen build plan.");
		}
	}
	
	// At least one treasury (natives only)
	if (civIsNative() == true) {
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeSPCIncaTemple);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeSPCIncaTemple, cUnitStateAlive) < 1) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeSPCIncaTemple, 1, 90, false, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new treasury build plan.");
		}
	}
	
	// At least one artillery depot (not for Aztecs, Sioux or Asians)
	if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArtilleryDepot);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateAlive) < 2) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 65, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new artillery depot build plan.");
		}   
	}
	
	// At least one castle (Asians only)
	if (civIsAsian() == true) {
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCastle);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) < 2) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeypCastle, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new siege workshop build plan.");
		}
	}
	
	// That's it for age 3
	if (kbGetAge() < cAge4)
	return;
	// **********************************************************
	
	if ((civIsNative() == false) && (civIsAsian() == false))
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArsenal);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateAlive) < 1) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeArsenal, 1, 60, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new arsenal build plan.");
		}
	}
	
	// If Russian, at least 2 blockhouses
	if (kbGetCiv() == cCivRussians)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBlockhouse);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBlockhouse, cUnitStateAlive) < 4) )
		{ 
			createSimpleBuildPlan(cUnitTypeBlockhouse, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new blockhouse build plan.");
		}   
	}
	else if ( civIsNative() == true ) // Natives, at least 2 war huts
	{  
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) < 4) )
		{
			createSimpleBuildPlan(cUnitTypeWarHut, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new war hut build plan.");
		}  
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBarracksJapanese);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypBarracksJapanese, cUnitStateAlive) < 4) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypBarracksJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new bansho build plan.");
			}
		}
		else if ( (cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypWarAcademy);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypWarAcademy, cUnitStateAlive) < 4) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypWarAcademy, 1, 98, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new war academy build plan.");
			}
		}
		else {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeYPBarracksIndian);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeYPBarracksIndian, cUnitStateAlive) < 4) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeYPBarracksIndian, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new indian barracks build plan.");
			}
		}
	}
	else // Every other civ, at least 2 barracks.
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBarracks);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateAlive) < 4) )
		{
			createSimpleBuildPlan(cUnitTypeBarracks, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new barracks build plan.");
		}
	}
	
	// At least two stables, corrals or caravanserais
	if ( (civIsNative() == true) )
	{  // Natives, at least 2 corrals
		if (cMyCiv != cCivXPAztec)
		{
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCorral);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateAlive) < 3) )
			{
				createSimpleBuildPlan(cUnitTypeCorral, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new corral build plan.");
			}  
		}
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypStableJapanese);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateAlive) < 3) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new dojo build plan.");
			}
		}
		else if ( (cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCaravanserai);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateAlive) < 3) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new Caravanserai build plan.");
			}
		}
	}
	else 
	{      
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeStable);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateAlive) < 3) )
		{
			createSimpleBuildPlan(cUnitTypeStable, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new stable build plan.");
		}
	}
	
	// At least two artillery depots (not for Aztecs, Sioux or Asians)
	if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArtilleryDepot);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateAlive) < 3) )
		{
			createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 65, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new artillery depot build plan.");
		}   
	}
	
	// One additional nobles hut for Aztecs, for a total of three
	if (cMyCiv == cCivXPAztec)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNoblesHut);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateAlive) < 3) )
		{
			createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new nobles hut build plan.");
		}   
	}
	
	// And how 'bout a capitol, as long as we're here (not for natives or Asians)
	if ( (civIsNative() == false) && (civIsAsian() == false) )
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCapitol);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeCapitol, cUnitStateAlive) < 1) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeCapitol, 1, 60, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new capitol build plan.");
		}
	}
	
	
	// That's it for age 4
	if (kbGetAge() < cAge5)
	return;
	// **********************************************************
	
	// At least two stables, corrals or caravanserais
	if ( (civIsNative() == true) )
	{  // Natives, at least 2 corrals
		if (cMyCiv != cCivXPAztec)
		{
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeCorral);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateAlive) < 4) )
			{
				createSimpleBuildPlan(cUnitTypeCorral, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new corral build plan.");
			}  
		}
	}
	else if (civIsAsian() == true) {
		if ( (cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypStableJapanese);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypStableJapanese, cUnitStateAlive) < 4) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypStableJapanese, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new dojo build plan.");
			}
		}
		else if ( (cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians) ) {
			planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCaravanserai);
			if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypCaravanserai, cUnitStateAlive) < 4) )
			{     // Start a new one
				createSimpleBuildPlan(cUnitTypeypCaravanserai, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
				//aiEcho("Starting a new Caravanserai build plan.");
			}
		}
	}
	else 
	{      
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeStable);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeStable, cUnitStateAlive) < 4) )
		{
			createSimpleBuildPlan(cUnitTypeStable, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new stable build plan.");
		}
	}
	
	// At least two artillery depots (not for Aztecs, Sioux or Asians)
	if ( (cMyCiv != cCivXPAztec) && (cMyCiv != cCivXPSioux) && (civIsAsian() == false) ) 
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeArtilleryDepot);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateAlive) < 4) )
		{
			createSimpleBuildPlan(cUnitTypeArtilleryDepot, 1, 65, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new artillery depot build plan.");
		}   
	}
	
	// At least two castles (Asians only)
	if (civIsAsian() == true) {
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypCastle);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) < 4) )
		{     // Start a new one
			createSimpleBuildPlan(cUnitTypeypCastle, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new siege workshop build plan.");
		}
	}
	
	// Two additional nobles huts for Aztecs, for a total of five
	if (cMyCiv == cCivXPAztec)
	{
		planID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNoblesHut);
		if ( (planID < 0) && (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateAlive) < 5) )
		{
			createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 70, false, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 1);
			//aiEcho("Starting a new nobles hut build plan.");
		}   
	}
	
}

//==============================================================================
/* xpBuilder monitor
	
	Use an idle xpBuilder to build as needed.
*/	
//==============================================================================
rule xpBuilderMonitor
inactive
group tcComplete
minInterval 10
{
	if (civIsNative() == false)
	{
		xsDisableSelf();
		return;
	}
	if(kbGetAge() < cAge2)return;
	
	static int activePlan = -1;
	
	if (activePlan != -1)   // We already have something active?
	{
		if ( (aiPlanGetState(activePlan) < 0) || (aiPlanGetState(activePlan) == cPlanStateNone) ) 
		{
			aiPlanDestroy(activePlan);
			activePlan = -1;  // Plan is bad, but didn't die.  It's dead now, so continue below.
		}
		else
		{
			return;  // Something is active, let it run.
		}
	}
	
	// If we get this far, there is no active plan.  See if we have a xpBuilder to use.
	int xpBuilderID = -1;
	int buildingToMake = -1;
	int buildertype = -1;
	if (kbUnitCount(cMyID, cUnitTypexpBuilderStart, cUnitStateAlive) > 0) {
		xpBuilderID = getUnit(cUnitTypexpBuilderStart);
		buildingToMake = gHouseUnit;  // If all else fails, make a house since we can't make warhuts.
		buildertype = cUnitTypexpBuilderStart;
	}
	else {
		xpBuilderID = getUnit(cUnitTypexpBuilder);
		buildingToMake = cUnitTypeWarHut;  // If all else fails, make a war hut.
		buildertype = cUnitTypexpBuilder;
	}
	if (xpBuilderID < 0)return;
	
	// We have a xpBuilder, and no plan to use it.  Find something to do with it.  
	// Simple logic.  Farm if less than 3.  War hut if less than 2.  Corral if < 2.
	// Plantations if less than 3 in Age 3 and above.   House if below build limit.
	// Siege Workshop if less than 2 in Age 3 and above.
	// One override....avoid farms in age 1, they're too slow.
	// Avoid war huts and corrals in Age 1 as starting travois cannot build them.
	//if ( (kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ) < 3) && (kbGetAge() > cAge1) )
	//buildingToMake = gFarmUnit;
	/*
		if ( (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) < 2) && (kbGetAge() > cAge1) )
		buildingToMake = cUnitTypeWarHut;
		else if ( (kbUnitCount(cMyID, cUnitTypeCorral, cUnitStateABQ) < 2) && (kbGetAge() > cAge1) )
		buildingToMake = cUnitTypeCorral;
		//else if ( (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateABQ) < 3) && (kbGetAge() > cAge2) )
		//buildingToMake = cUnitTypePlantation;
		//else if (kbUnitCount(cMyID, gHouseUnit, cUnitStateABQ) < kbGetBuildLimit(cMyID, gHouseUnit))
		//buildingToMake = gHouseUnit;
		else if ( (kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateABQ) < 2) && (kbGetAge() > cAge2) )
		buildingToMake = cUnitTypeArtilleryDepot;
	*/
	
	
	if(kbUnitCount(cMyID, gBarracksUnit, cUnitStateABQ) < kbGetBuildLimit(cMyID, gBarracksUnit))
	{
		buildingToMake = gBarracksUnit;
	}
	else if(kbUnitCount(cMyID, gStableUnit, cUnitStateABQ) < 3)
	{
		buildingToMake = cUnitTypeStable;
	}
	else if(kbUnitCount(cMyID, gArtilleryDepotUnit, cUnitStateABQ) < 3 && kbGetAge() > cAge3)
	{
		buildingToMake = gArtilleryDepotUnit;
	}
	else if(kbUnitCount(cMyID, gFarmUnit, cUnitStateABQ) >= kbUnitCount(cMyID, gPlantationUnit, cUnitStateABQ))
	{
		buildingToMake = gPlantationUnit;
	}
	else
	{
		buildingToMake = gFarmUnit;
	}
	
	if (buildingToMake >= 0)
	{
		activePlan = aiPlanCreate("Use an xpBuilder", cPlanBuild);
		// What to build
		aiPlanSetVariableInt(activePlan, cBuildPlanBuildingTypeID, 0, buildingToMake);
		
		// 8 meter separation for farms and plantations, 3 meter for everything else
		aiPlanSetVariableFloat(activePlan, cBuildPlanBuildingBufferSpace, 0, 3.0);
		if ((buildingToMake == gFarmUnit) || (buildingToMake == cUnitTypePlantation))
		aiPlanSetVariableFloat(activePlan, cBuildPlanBuildingBufferSpace, 0, 8.0);       
		
		//Priority.
		aiPlanSetDesiredPriority(activePlan, 95);
		//Mil vs. Econ.
		if ( (buildingToMake == cUnitTypeWarHut) || 
			(buildingToMake == cUnitTypeCorral) || 
		(buildingToMake == cUnitTypeArtilleryDepot) )
		
		{
			aiPlanSetMilitary(activePlan, true);
			aiPlanSetEconomy(activePlan, false);
		}
		else
		{
			aiPlanSetMilitary(activePlan, false);
			aiPlanSetEconomy(activePlan, true);
		}
		aiPlanSetEscrowID(activePlan, cEconomyEscrowID);
		
		aiPlanAddUnitType(activePlan, buildertype, 1, 1, 1);
		
		aiPlanSetBaseID(activePlan, kbBaseGetMainID(cMyID));
		
		//Go.
		aiPlanSetActive(activePlan);
	}
}

//==============================================================================
/* Native Dance Monitor
	
	Manage the number of natives dancing, and the 'tactic' they're dancing for.
	
	const int cTacticFertilityDance=12;   Faster training
	const int cTacticGiftDance=13;         Faster XP trickle
	const int cTacticCityDance=14;
	const int cTacticWaterDance=15;       Increases navy HP/attack
	const int cTacticAlarmDance=16;        Town defense...
	const int cTacticFounderDance=17;      xpBuilder units - Iroquois
	const int cTacticMorningWarsDance=18;
	const int cTacticEarthMotherDance=19;
	const int cTacticHealingDance=20;
	const int cTacticFireDance=21;
	const int cTacticWarDanceSong=22;
	const int cTacticGarlandWarDance=23;
	const int cTacticWarChiefDance=24;    new war chief (Iroquois)
	const int cTacticHolyDance=25;
	const int cTacticWarChiefDanceSioux=28;    new war chief (Sioux)
	const int cTacticWarChiefDanceAztec=29;    new war chief (Aztec)
	
*/
//==============================================================================
rule danceMonitor
inactive
group tcComplete
minInterval 20
{
	if(kbGetAge() < cAge3 )return;
	if (civIsNative() == false)
	{
		xsDisableSelf();
		return;
	}
	
	if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateAlive)==0)
	return;
	

	if (aiPlanGetState(gNativeDancePlan)==-1)
	{
		aiPlanDestroy(gNativeDancePlan);
		gNativeDancePlan=-1;
	}
	
	
	
	static int counter=0;
	
	static int lastTactic = -1;
	static int lastTacticTime = -1;
	static int lastWarChiefTime = -1;
	static int warChiefCount = 0;
	
	if (gNativeDancePlan < 0)
	{
		counter++;
		gNativeDancePlan = aiPlanCreate("NativeResearch"+counter, cPlanNativeResearch);
		int buildingID = getUnit(cUnitTypeFirePit);
		aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticNormal);
		aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanBuildingID, 0, buildingID);
		aiPlanSetDesiredPriority(gNativeDancePlan, 85);
		aiPlanAddUnitType(gNativeDancePlan, gEconUnit, 1, 1, 1);
		aiPlanSetActive(gNativeDancePlan);
		
		lastTactic = cTacticNormal;
		lastTacticTime = xsGetTime();
	}
	
	// Use all available warrior priests as dancers
	int numWarPriests = kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive);
	aiPlanAddUnitType(gNativeDancePlan, cUnitTypexpMedicineManAztec, numWarPriests, numWarPriests, numWarPriests);
	
	// Add a number of dancers equivalent to 1/5 of settler pop, rounded down
	// Make sure no more than 25 units are assigned in total
	int want = -1;
	want = kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) / 10;

	if(kbUnitGetNumberWorkers(buildingID) < 25)
	{
		if ((want*2 + numWarPriests) <= 25)
		{
			aiPlanAddUnitType(gNativeDancePlan, gEconUnit, want/2, want, want*2);
		}
		else
		{
			aiPlanAddUnitType(gNativeDancePlan, gEconUnit, want/2, want, (25-numWarPriests));
		}
	}
	
	// Select a tactic 
	
	// Alarm dance if base is under attack
	if ( gDefenseReflexBaseID == kbBaseGetMainID(cMyID) ) 
	{
		aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticAlarmDance);
		lastTactic = cTacticAlarmDance;
		lastTacticTime = xsGetTime();
		return;
	}
	
	// Recover war chief
	
	if (aiGetFallenExplorerID() >= 0)
	{
		if (cMyCiv == cCivXPIroquois)
		{
			aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarChiefDance);
			lastTactic = cTacticWarChiefDance;
		}
		else if (cMyCiv == cCivXPAztec)
		{
			aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarChiefDanceAztec);
			lastTactic = cTacticWarChiefDanceAztec;
		}
		else if (cMyCiv == cCivXPSioux)
		{
			aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarChiefDanceSioux);
			lastTactic = cTacticWarChiefDanceSioux;
		}
		lastTacticTime = xsGetTime();
		return;
	}
	
	// Train units faster
	if ((aiPlanGetVariableInt(gSettlerMaintainPlan, cTrainPlanNumberToMaintain, 0) > (kbUnitCount(cMyID, gEconUnit, cUnitStateABQ)+5)) && (kbGetPop() < kbGetPopCap()))
	{
		aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticFertilityDance);
		lastTactic = cTacticFertilityDance;
		lastTacticTime = xsGetTime();
		return;
	}
	
	// Travois if age 1 or 2 (Iroquois only)
	// To be used only if they still make sense, i.e. if there are buildings left to be erected 
	if ( (kbGetAge() < cAge3) && 
        (kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) < 2) && 
        (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) < kbGetBuildLimit(cMyID, cUnitTypeWarHut)) &&
	(cMyCiv == cCivXPIroquois) )
	{
		aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticFounderDance);
		lastTactic = cTacticFounderDance;
		lastTacticTime = xsGetTime();
		return;
	}
	
	// Spawn skull knights in age 4 or 5 (Aztecs only)
	if ( (kbGetAge() >= cAge4)  && (cMyCiv == cCivXPAztec) && (aiGetAvailableMilitaryPop() >= 10) )
	{
		aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticGarlandWarDance);
		lastTactic = cTacticGarlandWarDance;
		lastTacticTime = xsGetTime();
		return;
	}
	
	// Spawn dog soldiers in age 4 or 5 (Sioux only)
	if ( (kbGetAge() >= cAge4)  && (cMyCiv == cCivXPSioux) && (aiGetAvailableMilitaryPop() >= 10) )
	{
		aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticWarDanceSong);
		lastTactic = cTacticWarDanceSong;
		lastTacticTime = xsGetTime();
		return;
	}
	
	// Default: XP trickle
	aiPlanSetVariableInt(gNativeDancePlan, cNativeResearchPlanTacticID, 0, cTacticGiftDance);
	lastTactic = cTacticGiftDance;
	lastTacticTime = xsGetTime();  
	
	
}

//==============================================================================
/* Rice Paddy Monitor
	
	Switch from Food to Coin.
	
	cTacticPaddyFood
	cTacticPaddyCoin
	
*/
//==============================================================================
rule ricepaddyMonitor
inactive
group tcComplete
minInterval 60
{
	if (civIsAsian() == false)
	{
		xsDisableSelf();
		return;
	}
	
	//gotta get all of the paddies
	static int paddyQueryID=-1;
	
	//If we don't have the query yet, create one.
	if (paddyQueryID < 0)
	{
		paddyQueryID=kbUnitQueryCreate("paddyGetUnitQuery");
		kbUnitQuerySetIgnoreKnockedOutUnits(paddyQueryID, true);
	}
	
	//Define a query to get all matching units
	if (paddyQueryID != -1)
	{
		kbUnitQuerySetPlayerRelation(paddyQueryID, -1);
		kbUnitQuerySetPlayerID(paddyQueryID, cMyID);
		kbUnitQuerySetUnitType(paddyQueryID, cUnitTypeypRicePaddy);
		kbUnitQuerySetState(paddyQueryID, cUnitStateAlive);
	}
	else
   	return;
	
	kbUnitQueryResetResults(paddyQueryID);
	int numberFound=kbUnitQueryExecute(paddyQueryID);
	int index = 0;
	
	// Select a tactic
	static int lastricefood = 0;
	
	int foodriceNeeded = 1 + kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive)*0.5;
	float percentOnGold = aiGetResourceGathererPercentage( cResourceGold, cRGPActual );
	
	if (percentOnGold < 0.30) {
		foodriceNeeded--;
	}
	
	if ( foodriceNeeded != lastricefood ) {
		lastricefood = foodriceNeeded;
		for (index = 0; <foodriceNeeded) {
			//change the rice to food
			aiUnitSetTactic(kbUnitQueryGetResult(paddyQueryID, index), cTacticPaddyFood);
		}
		for (index = foodriceNeeded; < numberFound) {
			//change the rice to coin
			aiUnitSetTactic(kbUnitQueryGetResult(paddyQueryID, index), cTacticPaddyCoin);
		}
	}
}

//==============================================================================
/* Shrine Monitor
	
	Uses shrine wagons to build shrines. In Age 3 and above shrine production
	is cycled through the resource options once per minute.
	
*/
//==============================================================================
rule shrineMonitor
inactive
group tcComplete
minInterval 20
{
	// Disable for anybody but Japanese
	if (kbGetCiv() != cCivJapanese)
	{
		xsDisableSelf();
		return;
	}
	
	// Use shrine wagons
	if ((kbUnitCount(cMyID, cUnitTypeypShrineWagon, cUnitStateAlive) > 0) && (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypShrineJapanese) < 0))
	{
		createSimpleBuildPlan(cUnitTypeypShrineJapanese, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
	}
	
	// Cycle through resource generation options
	static int shrineTactic = -1;
	if (kbGetAge() >= cAge3)
	{
		// Define a query to get all matching units
		int shrineQueryID=-1;
		shrineQueryID=kbUnitQueryCreate("shrineGetUnitQuery");
		kbUnitQuerySetIgnoreKnockedOutUnits(shrineQueryID, true);
		if (shrineQueryID != -1)
		{
			kbUnitQuerySetPlayerRelation(shrineQueryID, -1);
			kbUnitQuerySetPlayerID(shrineQueryID, cMyID);
			kbUnitQuerySetUnitType(shrineQueryID, cUnitTypeypShrineJapanese);
			kbUnitQuerySetState(shrineQueryID, cUnitStateAlive);
			kbUnitQueryResetResults(shrineQueryID);
			int numberFound=kbUnitQueryExecute(shrineQueryID);
			if (numberFound > 0)
			{
				shrineTactic = shrineTactic + 1;
				if (shrineTactic > 8)
				shrineTactic = 0;
				switch(shrineTactic)
				{
					case 0:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(shrineQueryID, 0), cTacticShrineFood);
						break;
					}
					case 3:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(shrineQueryID, 0), cTacticShrineWood);
						break;
					}
					case 6:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(shrineQueryID, 0), cTacticShrineCoin);
						break;
					}
					default:
					{
						// stay with what we are at for one or two more cycles
						break;
					}
				}
			}
		}
	}
}

//==============================================================================
/* rule defenseReflex
	
	Monitor each VP site that we own, plus our main base.  Move and reconfigure 
	the defense and reserve plans as needed.
	
	At rest, the defend plan has only one unit, is centered on the main base, and
	is used to send one unit after trivial invasions, typically a scouting unit. 
	The reserve plan has a much larger MAX number, so it gets all the remaining units.
	It is centered on the military gather point with a conservative radius, to avoid
	engaging units far in front of the main base.
	
	When defending a base in a defense reflex, the defend plan gets a high MAX number
	so that it takes units from the reserve plan.  The low unit count in reserve 
	acts as a signal to not launch new attacks, as troops aren't available.  The 
	defend plan and reserve plan are relocated to the endangered base, with an aggressive
	engage radius.
	
	The search, active engage and passive engage radii are set by global 
	control variables, cvDefenseReflexRadiusActive, cvDefenseReflexRadiusPassive, and
	cvDefenseReflexSearchRadius.
	
	Once in a defense reflex, the AI stays in it until that base is cleared, unless
	it's defending a non-main base, and the main base requires defense.  In that case,
	the defense reflex moves back to the main base.
	
	pauseDefenseReflex() can only be used when already in a defense reflex.  So valid 
	state transitions are:
	
	none to defending       // start reflex with moveDefenseReflex(), sets all the base/location globals.
	defending to paused     // use pauseDefenseReflex(), takes no parms, uses vars set in prior moveDefenseReflex call.
	defending to end        // use endDefenseReflex(), clears global vars
	paused to end           // use endDefenseReflex(), clears global vars
	paused to defending     // use moveDefenseReflex(), set global vars again.
	
*/
//==============================================================================
// 

rule defenseReflex
inactive
minInterval 10
group startup
{
	int armySize = aiPlanGetNumberUnits(gLandDefendPlan0, cUnitTypeLogicalTypeLandMilitary) + aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
	int enemyArmySize = -1;
	static int lastHelpTime = -60000;
	static int lastHelpBaseID = -1;
	int i = 0;
	int unitID = -1;
	int protoUnitID = -1;
	bool panic = false;  // Indicates need for call for help
	
	static int enemyArmyQuery = -1;
	if (enemyArmyQuery < 0)
	{  // Initialize the queryID
		enemyArmyQuery = kbUnitQueryCreate("Enemy army query");
		kbUnitQuerySetIgnoreKnockedOutUnits(enemyArmyQuery, true);
		kbUnitQuerySetPlayerRelation(enemyArmyQuery, cPlayerRelationEnemyNotGaia);
		kbUnitQuerySetUnitType(enemyArmyQuery, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
		kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);   // Ignore units we think are under fog
	}
	
	// Check main base first
	kbUnitQuerySetPosition(enemyArmyQuery,  kbBaseGetLocation(cMyID,  kbBaseGetMainID(cMyID)));
	kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);   
	kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
	kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
	kbUnitQueryResetResults(enemyArmyQuery);
	enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
	if (enemyArmySize >= 2)
	{  // Main base is under attack
		//aiEcho("******** Main base ("+kbBaseGetMainID(cMyID)+") under attack.");
		//aiEcho("******** Enemy count "+enemyArmySize+", my army count "+armySize);
		if ( gDefenseReflexBaseID == kbBaseGetMainID(cMyID) )
		{  // We're already in a defense reflex for the main base
			if (  ((armySize * 3.0) < enemyArmySize)  && (enemyArmySize > 6.0) )  // Army at least 3x my size and more than 6 units total.
			{  // Too big to handle
				if (gDefenseReflexPaused == false)
				{  // We weren't paused, do it
					pauseDefenseReflex();
				}
				// Consider a call for help
				panic = true;
				if ( ((xsGetTime() - lastHelpTime) < 300000) && (lastHelpBaseID == gDefenseReflexBaseID) )  // We called for help in the last five minutes, and it was this base
				panic = false;
				if ( ((xsGetTime() - lastHelpTime) < 60000) && (lastHelpBaseID != gDefenseReflexBaseID) )  // We called for help anywhere in the last minute
				panic = false;
				
				if (panic == true)
				{
					sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
					//aiEcho("     I'm calling for help.");
					lastHelpTime = xsGetTime();
				}
			} 
			else
			{  // Size is OK to handle, shouldn't be in paused mode.
				if (gDefenseReflexPaused == true)   // Need to turn it active
				{
					moveDefenseReflex( kbBaseGetLocation(cMyID,  kbBaseGetMainID(cMyID)), cvDefenseReflexRadiusActive, kbBaseGetMainID(cMyID));
				}
			}
		}
		else  // Defense reflex wasn't set to main base.
		{  // Need to set the defense reflex to home base...doesn't matter if it was inactive or guarding another base, home base trumps all.
			moveDefenseReflex( kbBaseGetLocation(cMyID,  kbBaseGetMainID(cMyID)), cvDefenseReflexRadiusActive, kbBaseGetMainID(cMyID));
			// This is a new defense reflex in the main base.  Consider making a chat about it.
			int enemyPlayerID = kbUnitGetPlayerID(kbUnitQueryGetResult(enemyArmyQuery, 0));
			if ( (enemyPlayerID > 0) && (kbGetAge() > cAge1) ) 
			{  // Consider sending a chat as long as we're out of age 1.
				int enemyPlayerUnitCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, enemyPlayerID, cUnitStateAlive, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID), 50.0);
				if ( (enemyPlayerUnitCount > (2 * gGoodArmyPop)) && (enemyPlayerUnitCount > (3* armySize)) )
				{  // Enemy army is big, and we're badly outnumbered
					sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseOverrun, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
					//aiEcho("Sending OVERRUN prompt to player "+enemyPlayerID+", he has "+enemyPlayerUnitCount+" units.");
					//aiEcho("I have "+armySize+" units, and "+gGoodArmyPop+" is a good army size.");
					return;
				}
				if (enemyPlayerUnitCount > (2 * gGoodArmyPop))
				{  // Big army, but I'm still in the fight
					sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseLarge, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
					//aiEcho("Sending LARGE ARMY prompt to player "+enemyPlayerID+", he has "+enemyPlayerUnitCount+" units.");
					//aiEcho("I have "+armySize+" units, and "+gGoodArmyPop+" is a good army size.");
					return;
				}
				if (enemyPlayerUnitCount > gGoodArmyPop)
				{
					// Moderate size
					sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseMedium, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
					//aiEcho("Sending MEDIUM ARMY prompt to player "+enemyPlayerID+", he has "+enemyPlayerUnitCount+" units.");
					//aiEcho("I have "+armySize+" units, and "+gGoodArmyPop+" is a good army size.");
					return;
				}
				if ( (enemyPlayerUnitCount < gGoodArmyPop) && (enemyPlayerUnitCount < armySize) )
				{  // Small, and under control
					sendStatement(enemyPlayerID, cAICommPromptToEnemyISpotHisArmyMyBaseSmall, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
					//aiEcho("Sending SMALL ARMY prompt to player "+enemyPlayerID+", he has "+enemyPlayerUnitCount+" units.");
					//aiEcho("I have "+armySize+" units, and "+gGoodArmyPop+" is a good army size.");
					return;
				}
			}
		}
		return;  // Do not check other bases
	}
	
	// If we're this far, the main base is OK.  If we're in a defense reflex, see if we should stay in it, or change from passive to active.
	
	if (gDefenseReflex == true) // Currently in a defense mode, let's see if it should remain
	{
		kbUnitQuerySetPosition(enemyArmyQuery, gDefenseReflexLocation);
		kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius);  
		kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
		kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
		kbUnitQueryResetResults(enemyArmyQuery);
		enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
		//aiEcho("******** Defense reflex in base "+gDefenseReflexBaseID+" at "+gDefenseReflexLocation);
		//aiEcho("******** Enemy unit count: "+enemyArmySize+", my unit count (defend+reserve) = "+armySize);
		for (i=0; < enemyArmySize)
		{
			unitID = kbUnitQueryGetResult(enemyArmyQuery, i);
			protoUnitID = kbUnitGetProtoUnitID(unitID);
			if (i < 2)
            aiEcho("    "+unitID+" "+kbGetProtoUnitName(protoUnitID)+" "+kbUnitGetPosition(unitID));
		}
		
		if (enemyArmySize < 2)
		{  // Abort, no enemies, or just one scouting unit
			//aiEcho("******** Ending defense reflex, no enemies remain.");
			endDefenseReflex();
			return;
		}
		
		
		if (baseBuildingCount(gDefenseReflexBaseID) <= 0)
		{  // Abort, no buildings
			//aiEcho("******** Ending defense reflex, base "+gDefenseReflexBaseID+" has no buildings.");
			endDefenseReflex();
			return;
		}
		
		if ( kbBaseGetOwner(gDefenseReflexBaseID) <= 0)
		{  // Abort, base doesn't exist
			//aiEcho("******** Ending defense reflex, base "+gDefenseReflexBaseID+" doesn't exist.");
			endDefenseReflex();
			return;
		}
		
		// The defense reflex for this base should remain in effect.
		// Check whether to start/end paused mode.
		int unitsNeeded = gGoodArmyPop;        // At least a credible army to fight them
		if (unitsNeeded > (enemyArmySize/2))   // Or half their force, whichever is less.
		unitsNeeded = enemyArmySize/2;
		bool shouldPause = false;
		if ( (armySize < unitsNeeded) && ( (armySize * 3.0) < enemyArmySize) )
		shouldPause = true;  // We should pause if not paused, or stay paused if we are
		
		if (gDefenseReflexPaused == false)
		{  // Not currently paused, do it
			if (shouldPause == true)
			{
				pauseDefenseReflex();
				//aiEcho("******** Enemy count "+enemyArmySize+", my army count "+armySize);
			}
		}
		else
		{  // Currently paused...should we remain paused, or go active?
			if ( shouldPause == false )
			{
				moveDefenseReflex(gDefenseReflexLocation, cvDefenseReflexRadiusActive, gDefenseReflexBaseID);   // Activate it 
				//aiEcho("******** Enemy count "+enemyArmySize+", my army count "+armySize);
			}
		}
		if (shouldPause == true)
		{  // Consider a call for help
			panic = true;
			if ( ((xsGetTime() - lastHelpTime) < 300000) && (lastHelpBaseID == gDefenseReflexBaseID) )  // We called for help in the last five minutes, and it was this base
            panic = false;
			if ( ((xsGetTime() - lastHelpTime) < 60000) && (lastHelpBaseID != gDefenseReflexBaseID) )  // We called for help anywhere in the last minute
            panic = false;
			
			if (panic == true)
			{
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase, kbBaseGetLocation(cMyID,  gDefenseReflexBaseID));
				//aiEcho("     I'm calling for help.");
				lastHelpTime = xsGetTime();
			}         
		}
		return;  // Done...we're staying in defense mode for this base, and have paused or gone active as needed.
	}
	
	
	// Not in a defense reflex, see if one is needed
	
	// Check other bases
	int baseCount = -1;
	int baseIndex = -1;
	int baseID = -1;
	
	baseCount = kbBaseGetNumber(cMyID);
	unitsNeeded = gGoodArmyPop/2;
	if (baseCount > 0)
	{
		for(baseIndex=0; < baseCount) 
		{
			baseID = kbBaseGetIDByIndex(cMyID, baseIndex);
			if (baseID == kbBaseGetMainID(cMyID))
            continue;   // Already checked main at top of function
			
			if ( baseBuildingCount(baseID) <= 0)
			{
				//aiEcho("Base "+baseID+" has no buildings.");
				continue;   // Skip bases that have no buildings
			}
			
			// Check for overrun base
			kbUnitQuerySetPosition(enemyArmyQuery,  kbBaseGetLocation(cMyID,  baseID));
			kbUnitQuerySetMaximumDistance(enemyArmyQuery, cvDefenseReflexSearchRadius); 
			kbUnitQuerySetSeeableOnly(enemyArmyQuery, true);
			kbUnitQuerySetState(enemyArmyQuery, cUnitStateAlive);
			kbUnitQueryResetResults(enemyArmyQuery);
			enemyArmySize = kbUnitQueryExecute(enemyArmyQuery);
			// Do I need to call for help?
			
			if ( (enemyArmySize >= 2)  )
			{  // More than just a scout...set defense reflex for this base
				moveDefenseReflex(kbBaseGetLocation(cMyID, baseID), cvDefenseReflexRadiusActive, baseID);
				//aiEcho("******** Enemy count is "+enemyArmySize+", my army size is "+armySize);                  
				
				if ( (enemyArmySize > (armySize * 2.0)) && (enemyArmySize > 6))   // Double my size, get help...
				{
					panic = true;
					if ( ((xsGetTime() - lastHelpTime) < 300000) && (lastHelpBaseID == baseID) )  // We called for help in the last five minutes, and it was this base
					panic = false;
					if ( ((xsGetTime() - lastHelpTime) < 60000) && (lastHelpBaseID != baseID) )  // We called for help anywhere in the last minute
					panic = false;
					
					if (panic == true)
					{
						// Don't kill other missions, this isn't the main base.  Just call for help.
						sendStatement(cPlayerRelationAlly, cAICommPromptToAllyINeedHelpMyBase, kbBaseGetLocation(cMyID, baseID));
						//aiEcho("     I'm calling for help.");
						lastHelpTime = xsGetTime();
					}
					
				}
				return;     // If we're in trouble in any base, ignore the others.
			} 
		}  // For baseIndex...
	}
}

int getMapID(void)
{
	int mapIndex = 0;
	for (mapIndex = 0; < xsArrayGetSize(gMapNames))
	{
		if ( xsArrayGetString(gMapNames, mapIndex) == cRandomMapName )
		{
			return(mapIndex);
		}
	}
	return(-1);
}

//updatedOn 2019/05/15 By ageekhere  
//---------------------------
rule personalityChanger
active
minInterval 300
{
	switch(aiRandInt(5))
	{
		case 0:
		{
			btBiasCav = 1.0;
			btBiasInf = 0.2;
			btBiasArt = 0.0;
			break;
		}
		
		case 1:
		{
			btBiasCav = 0.2;
			btBiasInf = 1.0;
			btBiasArt = 0.0;
			break;
		}
		
		case 2:
		{
			btBiasCav = 0.4;
			btBiasInf = 0.2;
			btBiasArt = 1.0;
			break;
		}
		
		case 4:
		{
			btBiasCav = 0.5;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			break;
		}
		
	}
}
//---------------------------

//==============================================================================
/* initPersonality()
	
	A function to set defaults that need to be in place before the loader file's
	preInit() function is called.  
*/
//==============================================================================
void initPersonality(void)
{
	int civ = kbGetCiv();
	if (civ == cCivTheCircle) civ = cCivGermans;
	if (civ == cCivXPSPC) civ = cCivBritish;
	if (civ == cCivSPCAct3) civ = cCivBritish;
	// Set behavior traits
	//aiEcho("My civ is "+civ);
	switch(civ)
	{
		case cCivBritish:    // Elizabeth:  Infantry oriented boomer, favors natives
		{
			btRushBoom = 0.0;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivFrench:     // Napoleon:  Cav oriented, balanced, favors natives
		{
			btRushBoom = 0.0;
			btOffenseDefense = 0.5;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 1.0; //0.5;
			btBiasTrade = 1.0;//0.5;
			break;
		}
		case cCivSpanish:    // Isabella:  Rusher, disdains trading posts
		{
			btRushBoom = 1.0;
			btOffenseDefense = 1.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.0;
			btBiasTrade = 0.5;
			break;
		}
		case cCivRussians:   // Ivan:  Infantry oriented turtler
		{
			btRushBoom = 0.0;   // Slight boomer, he needs the econ in age 2 to keep settlers training.
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivGermans:    // Cavalry oriented rusher
		{
			btRushBoom = 1.0;
			btOffenseDefense = 0.5;
			btBiasCav = 0.3;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.0;
			btBiasTrade = 0.5;
			break;
		}
		case cCivDutch:      // Turtler, boomish, huge emphasis on trade
		{
			btRushBoom = 0.0;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivPortuguese: // Artillery oriented boomer, favors trade   
		{
			btRushBoom = 0.0;
			btOffenseDefense = 0.5;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivOttomans:   // Artillery oriented, balanced
		{
			btRushBoom = 0.5;
			btOffenseDefense = 0.5;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.1;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivXPSioux:   // Extreme rush, ignores trade routes
		{
			btRushBoom = 1.0;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;  
			btBiasNative = 0.0;
			btBiasTrade = 0.5;
			break;
		}
		case cCivXPIroquois:   // Balanced, trade and native bias.
		{
			btRushBoom = 0.0;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivXPAztec:   // Randomized, but usually light boom, defensive.
		{
			btRushBoom = 0.0;
			btOffenseDefense = 1.0;
			btBiasCav = 0.0;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivChinese:   // Kangxi:  Infantry oriented turtler
		{
			btRushBoom = 0.0;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivJapanese:   // Extreme rush, ignores trade routes
		{
			btRushBoom = 1.0;
			btOffenseDefense = 1.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.0;
			btBiasTrade = 0.5;
			break;
		}
		case cCivIndians:    // Cavalry oriented, balanced
		{
			btRushBoom = 1.0;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivUSA:     // Washington
		{
			btRushBoom = 0.5;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.0;
			btBiasTrade = 0.5;
			break;
		}
		case cCivItalians:     // Pope
		{
			btRushBoom = 0.0;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;
			btBiasNative = 0.5;
			btBiasTrade = 0.5;
			break;
		}
		case cCivSwedish:   // Christina
		{
			btRushBoom = 0.5;
			btOffenseDefense = 0.5;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;  
			btBiasNative = 0.0;
			btBiasTrade = 0.5;
			break;
		}
		case cCivMaltese:   // Alain
		{
			btRushBoom = 0.5;
			btOffenseDefense = 0.5;
			btBiasCav = 0.3;
			btBiasInf = 0.5;
			btBiasArt = 0.0;  
			btBiasNative = 0.0;
			btBiasTrade = 0.5;
			break;
		}
		case cCivColombians:   // Bolivar
		{
			btRushBoom = 0.0;
			btOffenseDefense = 0.0;
			btBiasCav = 0.2;
			btBiasInf = 0.5;
			btBiasArt = 0.0;  
			btBiasNative = 0.0;
			btBiasTrade = 0.5;
			break;
		}
		
	}
	btBiasNative = 1.0;
	btBiasTrade = 1.0;
	
	/*
		if (gSPC == false)
		btBiasCav = btBiasCav - 0.30; // Adjust cav-heavy choices across the board.  This will reduce the pref by .15, equivalent to a combat efficiency change of .075
	*/
	
	// Set default politician choices
	aiSetPoliticianChoice(cAge2, aiGetPoliticianListByIndex(cAge2, 0));  // Just grab the first available
	aiSetPoliticianChoice(cAge3, aiGetPoliticianListByIndex(cAge3, 0));
	aiSetPoliticianChoice(cAge4, aiGetPoliticianListByIndex(cAge4, 0));
	aiSetPoliticianChoice(cAge5, aiGetPoliticianListByIndex(cAge5, 0));
	
	
	
	//-- See who we are playing against.  If we have played against these players before, seed out unitpicker data, and then chat some.
	//XS_HELP("float aiPersonalityGetGameResource(int playerHistoryIndex, int gameIndex, int resourceID): Returns the given resource from the gameIndex game. If gameIndex is -1, this will return the avg of all games played.")
	//XS_HELP("int aiPersonalityGetGameUnitCount(int playerHistoryIndex, int gameIndex, int unitType): Returns the unit count from the gameIndex game. If gameIndex is -1, this will return the avg of all games played.")
	// To understand my opponent's unit biases, I'll have to do the following:
	//          1)  Store the opponents civ each game
	//          2)  On game start, look up his civ from last game
	//          3)  Based on his civ, look up how many units he made of each class (inf, cav, art), compare to 'normal'.
	//          4)  Set unitPicker biases to counter what he's likely to send.  
	
	int numPlayerHistories = aiPersonalityGetNumberPlayerHistories();
	//aiEcho("PlayerHistories: "+numPlayerHistories);
	for (pid = 1; < cNumberPlayers)
	{
		//-- Skip ourself.
		if (pid == cMyID)
		continue;
		
		//-- get player name
		string playerName = kbGetPlayerName(pid);
		//aiEcho("PlayerName: "+playerName);
		
		//-- have we played against them before.
		int playerHistoryID = aiPersonalityGetPlayerHistoryIndex(playerName);
		if(playerHistoryID == -1)
		{
			//aiEcho("PlayerName: Never played against");
			//-- Lets make a new player history.
			playerHistoryID = aiPersonalityCreatePlayerHistory(playerName);
			if (kbIsPlayerAlly(pid) == true)
            sendStatement(pid, cAICommPromptToAllyIntro); 
			else
            sendStatement(pid, cAICommPromptToEnemyIntro);
			if(playerHistoryID == -1)
			{
				//aiEcho("PlayerName: Failed to create player history for "+playerName);
				continue;
			}
			//aiEcho("PlayerName: Created new history for "+playerName);
		}
		else
		{
			//-- get how many times we have played against them.
			float totalGames = aiPersonalityGetPlayerGamesPlayed(playerHistoryID, cPlayerRelationAny);
			float numberGamePlayedAgainst = aiPersonalityGetPlayerGamesPlayed(playerHistoryID, cPlayerRelationEnemy);
			float numberGamesTheyWon = aiPersonalityGetTotalGameWins(playerHistoryID, cPlayerRelationEnemy);
			float myWinLossRatio = 1.0 - (numberGamesTheyWon/numberGamePlayedAgainst);
			//aiEcho("PlayedAgainst: "+numberGamePlayedAgainst);
			//aiEcho("TimesTheyWon: "+numberGamesTheyWon);
			//aiEcho("MyWinLossRatio: "+myWinLossRatio);
			
			bool iWonOurLastGameAgainstEachOther = aiPersonalityGetDidIWinLastGameVS(playerHistoryID);
			//bool weWonOurLastGameTogether; <-- cant do yet.
			
			
			//-- get how fast they like to attack
			// Minus one game index gives an average.
			int avgFirstAttackTime = aiPersonalityGetGameFirstAttackTime(playerHistoryID, -1);
			//aiEcho("Player's Avg first Attack time: "+avgFirstAttackTime);
			
			int lastFirstAttackTime = aiPersonalityGetGameFirstAttackTime(playerHistoryID, totalGames-1);
			//aiEcho("Player's Last game first Attack time: "+lastFirstAttackTime);
			
			//-- save some info.
			aiPersonalitySetPlayerUserVar(playerHistoryID, "myWinLossPercentage", myWinLossRatio);
			//-- test, get the value back out
			float tempFloat = aiPersonalityGetPlayerUserVar(playerHistoryID, "myWinLossPercentage");
			
			// Consider chats based on player history...
			// First, combinations of "was ally last time" and "am ally this time"
			bool wasAllyLastTime = true;
			bool isAllyThisTime = true;
			if (aiPersonalityGetPlayerUserVar(playerHistoryID, "wasMyAllyLastGame") == 0.0)
            wasAllyLastTime = false;
			if (kbIsPlayerAlly(pid) == false)
            isAllyThisTime = false;
			bool difficultyIsHigher = false;
			bool difficultyIsLower = false;
			float lastDifficulty = aiPersonalityGetPlayerUserVar(playerHistoryID, "lastGameDifficulty");
			if (lastDifficulty >= 0.0)
			{
				if (lastDifficulty > aiGetWorldDifficulty())
				difficultyIsLower = true;
				if (lastDifficulty < aiGetWorldDifficulty())
				difficultyIsHigher = true;
			}
			bool iBeatHimLastTime = false;
			bool heBeatMeLastTime = false;
			bool iCarriedHimLastTime = false;
			bool heCarriedMeLastTime = false;
			
			if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heBeatMeLastTime") == 1.0) // STORE ME
            heBeatMeLastTime = true;         
			if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iBeatHimLastTime") == 1.0) // STORE ME
            iBeatHimLastTime = true;
			if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime") == 1.0) // STORE ME
            iCarriedHimLastTime = true;
			if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime") == 1.0) // STORE ME
            heCarriedMeLastTime = true;
			
			
			if (wasAllyLastTime == false)
			{
				if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iBeatHimLastTime") == 1.0) // STORE ME
				iBeatHimLastTime = true;
				if (aiPersonalityGetPlayerUserVar(playerHistoryID, "heBeatMeLastTime") == 1.0) // STORE ME
				heBeatMeLastTime = true;
			}
			
			bool iWonLastGame = false;
			if (aiPersonalityGetPlayerUserVar(playerHistoryID, "iWonLastGame") == 1.0) // STORE ME
            iWonLastGame = true;
			
			
			if (isAllyThisTime)
			{  // We are allies
				if (difficultyIsHigher == true)
				sendStatement(pid, cAICommPromptToAllyIntroWhenDifficultyHigher);
				if (difficultyIsLower == true)
				sendStatement(pid, cAICommPromptToAllyIntroWhenDifficultyLower);
				if (iCarriedHimLastTime == true)
				sendStatement(pid, cAICommPromptToAllyIntroWhenICarriedHimLastGame);
				if (heCarriedMeLastTime == true)
				sendStatement(pid, cAICommPromptToAllyIntroWhenHeCarriedMeLastGame);
				if (iBeatHimLastTime == true)
				sendStatement(pid, cAICommPromptToAllyIntroWhenIBeatHimLastGame);
				if (heBeatMeLastTime == true)
				sendStatement(pid, cAICommPromptToAllyIntroWhenHeBeatMeLastGame);
				
				//aiEcho("Last map ID was "+aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID"));
				if ( (getMapID() >= 0) && (getMapID() == aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID")) )
				{
					sendStatement(pid, cAICommPromptToAllyIntroWhenMapRepeats);
					//aiEcho("Last map ID was "+aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID"));
				}
				if (wasAllyLastTime)
				{               
					//aiEcho(playerName + " was my ally last game and is my ally this game.");
					if (iWonLastGame == false)
					sendStatement(pid, cAICommPromptToAllyIntroWhenWeLostLastGame);
					else
					sendStatement(pid, cAICommPromptToAllyIntroWhenWeWonLastGame);
				}
				else
				{
					aiEcho(playerName + " was my enemy last game and is my ally this game.");
				}
			}
			else
			{  // We are enemies
				if (difficultyIsHigher == true)
				sendStatement(pid, cAICommPromptToEnemyIntroWhenDifficultyHigher);
				if (difficultyIsLower == true)
				sendStatement(pid, cAICommPromptToEnemyIntroWhenDifficultyLower);
				if ( (getMapID() >= 0) && (getMapID() == aiPersonalityGetPlayerUserVar(playerHistoryID, "lastMapID")) )
				sendStatement(pid, cAICommPromptToEnemyIntroWhenMapRepeats);
				if (wasAllyLastTime)
				{
					aiEcho(playerName + " was my ally last game and is my enemy this game.");
				}
				else
				{
					//aiEcho(playerName + " was my enemy last game and is my enemy this game.");
					// Check if he changed the odds
					// First, see if enemyCount is the same, but ally count is down
					int enemyCount = aiPersonalityGetPlayerUserVar(playerHistoryID, "myEnemyCount");
					int allyCount = aiPersonalityGetPlayerUserVar(playerHistoryID, "myAllyCount");
					if (enemyCount == getEnemyCount())
					{
						if (allyCount > getAllyCount())  // I have fewer allies now
						sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsEasier);  // He wimped out
						if (allyCount < getAllyCount()) // I have more allies now
						sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsHarder);  // He upped the difficulty
					}
					// Next, see if allyCount is the same, but enemyCount is smaller
					if (allyCount == getAllyCount())
					{
						if (enemyCount > getEnemyCount())  // I have fewer enemies now
						sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsHarder);  // He upped the difficulty
						if (enemyCount < getEnemyCount()) // I have more enemies now
						sendStatement(pid, cAICommPromptToEnemyIntroWhenTeamOddsEasier);  // He wimped out
					}               
				}
			}         
		}
		
		// Save info about this game
		aiPersonalitySetPlayerUserVar(playerHistoryID, "lastGameDifficulty", aiGetWorldDifficulty());
		int wasAlly = 0;
		if (kbIsPlayerAlly(pid)==true)
		wasAlly = 1;
		else
		{  // He is an enemy, remember the odds (i.e. 1v3, 2v2, etc.)
			aiPersonalitySetPlayerUserVar(playerHistoryID, "myAllyCount", getAllyCount());
			aiPersonalitySetPlayerUserVar(playerHistoryID, "myEnemyCount", getEnemyCount());         
		}
		aiPersonalitySetPlayerUserVar(playerHistoryID, "wasMyAllyLastGame", wasAlly);
		aiPersonalitySetPlayerUserVar(playerHistoryID, "lastMapID", getMapID());
		
	}
}

void gameOverHandler(int nothing = 0)
{
	bool iWon = false;
	if(kbHasPlayerLost(cMyID) == false)
	iWon = true;
	
	//aiEcho("Game is over.");
	//aiEcho("Have I lost returns "+kbHasPlayerLost(cMyID));
	if(iWon == false)
	aiEcho("I lost.");
	else
	aiEcho("I won.");
	
	for (pid = 1; < cNumberPlayers)
	{
		//-- Skip ourself.
		if (pid == cMyID)
		continue;
		
		//-- get player name
		string playerName = kbGetPlayerName(pid);
		//aiEcho("PlayerName: "+playerName);
		
		//-- Does a record exist?
		int playerHistoryID = aiPersonalityGetPlayerHistoryIndex(playerName);
		if(playerHistoryID == -1)
		{
			//aiEcho("PlayerName: Never played against");
			//-- Lets make a new player history.
			playerHistoryID = aiPersonalityCreatePlayerHistory(playerName);
		}
		
		
		/* Store the following user vars:
			heBeatMeLastTime
			iBeatHimLastTime
			iCarriedHimLastTime
			heCarriedMeLastTime
			iWonLastGame
		*/            
		if (iWon == true)
		{  // I won
			aiPersonalitySetPlayerUserVar(playerHistoryID, "iWonLastGame", 1.0);
			if (kbIsPlayerEnemy(pid) == true)
			{
				aiPersonalitySetPlayerUserVar(playerHistoryID, "iBeatHimLastTime", 1.0);
				aiPersonalitySetPlayerUserVar(playerHistoryID, "heBeatMeLastTime", 0.0);
				//aiEcho("This player was my enemy.");
			}
		}
		else
		{  // I lost
			aiPersonalitySetPlayerUserVar(playerHistoryID, "iWonLastGame", 0.0);
			if (kbIsPlayerEnemy(pid) == true)
			{
				aiPersonalitySetPlayerUserVar(playerHistoryID, "iBeatHimLastTime", 0.0);
				aiPersonalitySetPlayerUserVar(playerHistoryID, "heBeatMeLastTime", 1.0);
				//aiEcho("This player was my enemy.");
			}
		}
		if (kbIsPlayerAlly(pid) == true)
		{  // Was my ally
			if ( aiGetScore(cMyID) > (2 * aiGetScore(pid)) )   
			{  // I outscored him badly
				aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 1.0);
				//aiEcho("I carried my ally.");
			}
			else
            aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 0.0);
			if ( aiGetScore(pid) > (2 * aiGetScore(cMyID) ) )
			{  // My ally carried me.
				//aiEcho("My ally carried me.");
				aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 1.0);
			}
			else
            aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 0.0);
		}
		else
		{
			aiPersonalitySetPlayerUserVar(playerHistoryID, "iCarriedHimLastTime", 0.0);
			aiPersonalitySetPlayerUserVar(playerHistoryID, "heCarriedMeLastTime", 0.0);
		}
		
	}
	
}




rule buyCards1
inactive
minInterval 1
{
	for(i=0; < aiHCCardsGetTotal())
	{
		
		aiEcho();
	}
	
	xsDisableSelf();
}

int gCardNames = -1;       // Array of strings, handy name for this card.
int gCardStates = -1;      // Array of chars (strings), A = avail, N = Not avail, P = Purchased, D = in deck (and purchased)
int gCardPriorities = -1;  // Array of ints, used for selecting cards into deck.  

const int maxCards = 150;
const int pointsForLevel2 = 5;   // First five cards must be level 1
const int pointsForLevel3 = 25;  // Cards 6..25 must be levels 1 or 2
int lastRemainingSP = 0;
int loopCount = 0;

rule buyCards
inactive
minInterval 1
{
	
	static int pass = 0; // Pass 0, init arrays.  Pass 1, buy cards.  Pass 2, create deck.
	static int startingSP = -1;
	int skillPoints = kbResourceGet(cResourceSkillPoints) - 15;
	
	if(skillPoints > 100) skillPoints = 150 - loopCount;
	loopCount++;														
	

	
	if (startingSP < 0) startingSP = skillPoints;   // XS won't allow float initialization of const ints, also subtract first 15 free cards.
	int remainingSP = skillPoints;  
	
	int SPSpent = startingSP - remainingSP;
	int myLevel = 0;
	if (SPSpent >= 10) myLevel = 10;
	if (SPSpent >= 25) myLevel = 25;
	
	
	
	
	int totalCardCount = aiHCCardsGetTotal();
	
	//aiEcho("My starting level is "+myLevel+", my SP remaining is "+remainingSP);
	switch(pass)      // Break processing load into 3 passes:  init, buy, deck.
	{
		case 0:  // Init arrays
		{  
			gCardNames = xsArrayCreateString(maxCards, " ", "Card names");
			gCardStates = xsArrayCreateString(maxCards, "P", "Card states");  
			gCardPriorities = xsArrayCreateInt(maxCards, 0, "Card priorities");
			
			
			for (i=0; < totalCardCount)
			{  // First, set maximum priority for the "best" cards 
				// 'Advanced Trading Post', 'Royal Decree', 'Advanced Arsenal', 'New Ways' & 'Advanced Balloon',
				// plus '2 Grove Rickshaws' & 'Shogun Tokugawa'
				/*
					if(cMyCiv == cCivOttomans )
					{
						if (gDefaultDeck < 0) gDefaultDeck = aiHCDeckCreate("The AI Deck");
						if(openingTypeopeningType == 0 )
						{
							if(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSettlers3" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSilkRoadTeam" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSettlers4" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates2") 
							{
							//xsArraySetInt(gCardPriorities, i, 20); 
							aiHCDeckAddCardToDeck(gDefaultDeck, aiHCCardsGetCardCount(i));
							
							}
							if(i != totalCardCount)continue;
							else aiHCDeckActivate(gDefaultDeck);
							return;
							
							
							
							 ||
							
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCExtensiveFortifications" ||
							kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedBuildings" ||
								
							
							
							
						}
						
					}
				*/
				
				if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedBuildings") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCEnableMiners") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCExtensiveFortifications") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPUnlockFort2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedBuildingsGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeBritish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeDutch") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeFrench") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeOttoman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreePortuguese") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeRussian") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeSpanish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeSwedish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeItalians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalDecreeUS") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedArsenal") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedArsenalGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysIroquois") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNewWaysSioux") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPAdvancedBalloon") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactory") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBarons") ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFactoryGerman") && (kbGetCiv() != cCivGermans)) ||				
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRobberBaronsGerman") && (kbGetCiv() != cCivGermans)) ||								
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPIndustrialRevolution") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCExoticHardwoods") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGrainMarket") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRefrigeration") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalMint") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCTextileMills") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRoyalMintGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRefrigerationGerman") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCRoyalMintIndians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCFencingSchoolIndians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCRidingSchoolIndians") ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGermanTownFarmers") && (kbGetCiv() != cCivGermans)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCGuildArtisans") && (kbGetCiv() != cCivGermans)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCTeamTeutonTownCenter") && (kbGetCiv() != cCivGermans)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUhlanCombatGerman") && (kbGetCiv() != cCivGermans)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDutchEastIndiaCompany") && (kbGetCiv() != cCivDutch)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBetterBanks") && (kbGetCiv() != cCivDutch)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks1") && (kbGetCiv() != cCivDutch)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCBanks2") && (kbGetCiv() != cCivDutch)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRansack") && (kbGetCiv() != cCivRussians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCGurkhaAid") && (kbGetCiv() != cCivIndians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSustainableAgricultureIndians") && (kbGetCiv() != cCivIndians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIncreasedTribute") && (kbGetCiv() != cCivJapanese)) ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCMughalArchitecture") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCEastIndiaCompany") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelDamageIndians") ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRumDistillery") && (kbGetCiv() != cCivXPIroquois)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSustainableAgriculture") && (kbGetCiv() != cCivXPIroquois)) ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchool") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFencingSchoolGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchool") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRidingSchoolGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCombatOttoman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCost") ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipGroveWagonIndians2") && (kbGetCiv() != cCivIndians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantTrampling") && (kbGetCiv() != cCivIndians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantCombatIndians") && (kbGetCiv() != cCivIndians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCElephantLimit") && (kbGetCiv() != cCivIndians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCamelFrightening") && (kbGetCiv() != cCivIndians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf4Indians") && (kbGetCiv() != cCivIndians)) ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCoyoteCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryCombatIroquois") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPConservativeTactics") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCommandSkill") && (kbGetCiv() != cCivXPSioux)) ||				
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPMustangs") && (kbGetCiv() != cCivXPSioux)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSpiceTrade") && (kbGetCiv() != cCivBritish)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCPioneers") && (kbGetCiv() != cCivFrench)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCLightArtilleryHitpointsOttoman") && (kbGetCiv() != cCivOttomans)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryDamageOttoman") && (kbGetCiv() != cCivOttomans)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCArtilleryHitpointsOttomanTeam") && (kbGetCiv() != cCivOttomans)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeCombat") && (kbGetCiv() != cCivFrench)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeWarriors") && (kbGetCiv() != cCivFrench)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") && (kbGetCiv() != cCivFrench)) ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPAdoption") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPBuffalo4") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageSioux") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsSioux") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryCombatSioux") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPMedicineTeam") ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFoodSilos") && (kbGetCiv() != cCivXPSioux)) ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPEarthBounty") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWindRunner") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPNomadicExpansion") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatFrench") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryDamageFrenchTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageGermanTeam") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCDragoonCombatPortuguese") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatRussian") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCStreletsCombatRussian") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxTwoKettleSupport") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryCombatSpanish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierCombatBritish") ||								
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCHanAntiCavalryBonus") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAccupuncture") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCBannerSchool") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSamuraiDamage") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNobleCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataHitpoints") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNaginataAntiInfantryDamage") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiDamage") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiRange") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAshigaruDamage") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSamuraiSpeed") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCaballeros") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsSpanish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryCombatSpanish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryCombatDutch") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatDutch") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatOttoman") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPExoticHardwoodsTeam") ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCPioneers") && (kbGetCiv() != cCivRussians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSpiceTrade") && (kbGetCiv() != cCivRussians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMedicine") && (kbGetCiv() != cCivRussians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCPioneers") && (kbGetCiv() != cCivXPSioux)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSpiceTrade") && (kbGetCiv() != cCivXPSioux)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCPioneers") && (kbGetCiv() != cCivPortuguese)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryCombatPortuguese") && (kbGetCiv() != cCivPortuguese)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryHitpointsPortugueseTeam") && (kbGetCiv() != cCivPortuguese)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCPioneers") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPChinampa1") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPChinampa2") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleCenteotl") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleXipeTotec") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleXolotl") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleCoatlicue") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTempleTlaloc") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleQuetzalcoatl") && (kbGetCiv() != cCivXPAztec)) ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierHitpointsBritishTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCImprovedBuildingsTeam") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCWildernessWarfare") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryHitpointsDutchTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageFrenchTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryCombatBritish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCForbiddenArmyArmor") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCTerritorialArmyCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCMongolianScourge") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCStandardArmyHitpoints") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryCombatChinese") ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates4") && (kbGetCiv() != cCivXPSioux)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedLongbows") && (kbGetCiv() != cCivBritish)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFrontierDefenses2") && (kbGetCiv() != cCivDutch)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates3") && (kbGetCiv() != cCivDutch)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarHutTraining") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTownDance") && (kbGetCiv() != cCivXPAztec)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTownDance") && (kbGetCiv() != cCivXPIroquois)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTownDance") && (kbGetCiv() != cCivXPSioux)) ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipShogunate"))
				xsArraySetInt(gCardPriorities, i, 10);  // "Best" cards, pri 10
				
				// List of "best" cards also includes 'Agrarianism' for Indians
				// (A bug in aiHCDeckAddCardToDeck() keeps 'Foreign Logging' from being added.)
				
				if (kbGetCiv() == cCivIndians)
				{
					if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAgrarianism")
					xsArraySetInt(gCardPriorities, i, 10);  // "Best" cards, pri 10
				}
				
				// Now, set priorities for the prerequisite cards for the "best" ones.
				// These will be ignored later on.
				if (kbResourceGet(cResourceSkillPoints) >= 5)
				{  // Prerequisites for '2 Grove Rickshaws', only for HC level >= 5.
					if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipGroveWagonIndians2")
					xsArraySetInt(gCardPriorities, i, 10);  // Prerequisite cards, pri 10
				}
				if (kbResourceGet(cResourceSkillPoints) >= 15)
				{  // Prerequisites for 'Royal Decree', 'Advanced Arsenal', 'New Ways' and 'Shogun Tokugawa', only for HC level >= 15.
					if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCColonialMilitia") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMosqueConstruction") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFoodSilos") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFoodSilosTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRumDistillery") ||
						//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCExtensiveFortifications") ||
						//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPUnlockFort2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPTownDance") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoyoteMen3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCStreletsCombatRussian") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCJanissaryCombatOttoman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulateIndians") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCGurkhaAid") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCPioneers") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedWallsTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedIrregulars") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCheapWarAcademyTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNativeLearningIndians") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNativeIncorporationIndians") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCNativeTradeTaxIndians") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCheapStablesTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarchiefSioux1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipAxeRiders2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipAxeRiders3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipRifleRiders2") ||				   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxDakotaSupport") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxSanteeSupport") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiouxYanktonSupport") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipIndianHandCavalry3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipSamurai2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipShrineWagon2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIncreasedTribute") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoAizu") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDaimyoSatsuma"))
					xsArraySetInt(gCardPriorities, i, 10);  // Prerequisite cards, pri 10
				}
				if (kbResourceGet(cResourceSkillPoints) >= 25)
				{  // Prerequisites for 'Advanced Trading Post' and Indian 'Agrarism', only for HC level >= 25.
					if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeLore") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeLoreGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeTreaties") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeTreatiesGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeWarriors") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeWarriorsGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCNativeChampionsDutchTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRangedInfantryHitpointsFrench") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCuirassiers3") ||				   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsFrench") ||				   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCavalryArchers2") ||				   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCavalryArchers3") ||				   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSawmills") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSawmillsTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSustainableAgriculture") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipHowdahs1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIronmongerIndians") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCFoodSilosIndians") ||  
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSustainableAgricultureIndians") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCIronmonger") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSilversmith") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRumDistillery") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCigarRoller") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedMillGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSustainableAgricultureGerman") ||				   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCIronmongerGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSilversmithGerman") || 
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCRumDistilleryGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCigarRollerGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCIronmongerTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPChinampa1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguarKnights2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguarKnights3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightDamage") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPKnightHitpoints") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarchiefSioux2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPWarchiefSioux3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryDamageSioux") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPCavalryHitpointsSioux") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipWarRifles1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipWarRifles2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMedicine") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCSpiceTrade") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatHunter") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPBuffalo2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPBuffalo3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCImprovedBuildings") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHeavyFortifications") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipTomahawk3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryDamageIroquois") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPInfantryHitpointsIroquois") ||
						((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipYumi2") && (kbGetCiv() != cCivJapanese)) ||
						((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCYumiDamage") && (kbGetCiv() != cCivJapanese)) ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipShogunate") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCBakufu") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryHitpointsSpanish") ||	
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandCavalryDamageSpanish") ||				   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierDamageBritish") ||	   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCMusketeerGrenadierHitpointsBritishTeam") || 
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipHussars1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageSpanishTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsSpanish") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSkirmishers2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipRuyters2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryDamageDutch") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCInfantryHitpointsDutchTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipDopplesoldners2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryDamageGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCHandInfantryHitpointsGerman") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryDamageBritish") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCCavalryHitpointsBritish") ||	
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCavArchers1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCavArchers2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCavArchers3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipIronFlail1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipIronFlail2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipSteppeRider2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipSteppeRider3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipChangdao2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipChoKoNu2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipFlyingCrows1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryHitpointsChinese") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArtilleryDamageChinese") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipIndianRangedCavalry2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipIndianRangedCavalry3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCPioneersIndians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSawmillsIndians"))
					xsArraySetInt(gCardPriorities, i, 10);  // Prerequisite cards, pri 10
				}
				if (kbResourceGet(cResourceSkillPoints) >= 40)
				{  // Prerequisites for 'Advanced Balloon', only for HC level >= 40.
					if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipBalloons") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCuirassiers4") ||				   
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCuirassiers5") ||				   
						//(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPUnlockFort2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipMantlets2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipMantlets3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeHitpoints") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPSiegeDamage") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCEnlistIrregularsIndians") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCPioneersIndians") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCTheRaj") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCImprovedBuildingsTeam") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCMughalArchitecture") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMusketeers3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipDragoons3") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipDragoons4") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGenitours") ||
						((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf1Indians") && (kbGetCiv() != cCivIndians)) ||
						((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf3Indians") && (kbGetCiv() != cCivIndians)) ||
					((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf2Indians") && (kbGetCiv() != cCivIndians)))
					xsArraySetInt(gCardPriorities, i, 10);  // Prerequisite card, pri 10
				}
				
				
				// For all other cards, set priorities based on unit type.
				string tempString = "";
				int unit = aiHCCardsGetCardUnitType(i);
				int tech = aiHCCardsGetCardTechID(i);
				if ( (unit == cUnitTypeSettler) || (unit == cUnitTypeCoureur) || (unit == cUnitTypeSettlerWagon) || (unit == cUnitTypeSettlerNative) || (unit == cUnitTypeSettlerSwedish) || (unit == cUnitTypeypSettlerAsian) || (unit == cUnitTypeypSettlerJapanese) )
				xsArraySetInt(gCardPriorities, i, 7);  // Settler card, pri 9
				if ( (xsArrayGetInt(gCardPriorities, i) == 0) && (aiHCCardsGetCardCount(i) > 2) )
				xsArraySetInt(gCardPriorities, i, 6);  // Infinite cards, pri 8
				if (xsArrayGetInt(gCardPriorities, i) == 0)
				{
					
					if ( (unit == cUnitTypeFortWagon) ||
						(unit == cUnitTypeFactoryWagon) ||
						(unit == cUnitTypeCoveredWagon) ||
					(unit == cUnitTypeYPDojoWagon) )
					xsArraySetInt(gCardPriorities, i, 8);  // Fort, Factory, Dojo and Covered Wagons, pri 7
					if ( (unit == cUnitTypeOutpostWagon) || (unit == cUnitTypeYPCastleWagon) )
					{
						if (btRushBoom <= 0)  // Outpost and castle wagon, pri 0 for rushers, pri 7 otherwise
						{
							xsArraySetInt(gCardPriorities, i, 7);
						}
						else
						{
							xsArraySetInt(gCardPriorities, i, 0);
						}
					}
				}
				if ( (xsArrayGetInt(gCardPriorities, i) == 0) && (unit >= 0) )
				{  // Some type of unit, pri 6 for resources, 5 for others
					if (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractResourceCrate) == true)
					xsArraySetInt(gCardPriorities, i, 6);  // Resource
					else
					xsArraySetInt(gCardPriorities, i, 5);  // Generic unit
				}            
				if ( (xsArrayGetInt(gCardPriorities, i) == 5) && (unit >= 0) )
				{  // Demote cows, sheep and surgeons to 0, non-mil units to 4, ships to 0 on land maps.
					if ((kbProtoUnitIsType(cMyID, unit, cUnitTypeLogicalTypeLandMilitary) == false) || (aiHCCardsGetCardUnitCount(i) < 3))
					xsArraySetInt(gCardPriorities, i, 4);  // Non-military unit (including explorer dogs and uhlan pairs)
					if ((kbProtoUnitIsType(cMyID, unit, cUnitTypeHerdable) == true) || (kbProtoUnitIsType(cMyID, unit, cUnitTypeMissionary) == true) || (kbProtoUnitIsType(cMyID, unit, cUnitTypeSurgeon) == true))
					xsArraySetInt(gCardPriorities, i, 0);  // Herdables, missionaries or surgeons.              
					if ( (gNavyMap == false) && ( (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractWarShip) == true) || (kbProtoUnitIsType(cMyID, unit, cUnitTypeAbstractFishingBoat) == true) ) )
					xsArraySetInt(gCardPriorities, i, 0);  // Navy units on land?  Not good.              
				}
				
				// Set priority to 0 for cards to be avoided if possible
				if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFrontierDefenses2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFrontierDefenses1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoveredWagons2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCConestogaWagonsTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCUnlockFortVauban") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPUnlockFort2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPUnlockFort2German") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCREVShipFactory") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPRanching") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMinutemen") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedMarket") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedMarketGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedDock") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedDockGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedPlantations") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCAdvancedPlantationsGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSettlers1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoureurs1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSettlersNative1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipSettlerWagons1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFoodCrates1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipWoodCrates1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipCoinCrates1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipMixedCrates1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipFoodCrates1Indians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCrates1Indians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoinCrates1Indians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf1Indians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons1Indians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons2Indians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipTigers1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipLions1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipMonitorLizard1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipMonitorLizard2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons3") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipRajputs2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipRajputs3") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipIndianRangedCavalry2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipIndianRangedCavalry3") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipMongolScoutTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipEnvoyTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipMercsTigerClaw1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCPioneersTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCMercsNinja2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCEnlistIrregulars") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCallToArms1") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCDojoGenbukan") ||		
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipGroveWagonIndians1") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipFalconets2German") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipHorseArtillery1German") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortars1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortars2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortars1German") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortars2German") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipMortarsTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipPetards1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipDemolitionSquadGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipRams1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPIroquoisMohawkSupport") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSiege") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpies1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpies2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpies3") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpies1German") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipSpiesTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPGreatTempleTezcatlipoca") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipBears") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipBearsTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCougars") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoyotes") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoyotesTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipGrizzlies") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguars1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguars2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguars3") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipJaguarsTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipWolves") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoupRiders1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoupRiders2") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoupRiders3") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipCoupRiders4") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipDogsoldiersTeam1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPShipDogsoldiersTeam2") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPRanchingLlama") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFishMarket") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCFishMarketGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCFishMarket") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipWoodCratesInf1Indians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCExpandedTradingPost") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCExpandedTradingPostIndians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedDockIndians") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedRicePaddyIndians") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedWondersIndians") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedConsulate") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCFishMarketIndians") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSchoonersIndians") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSchoonersJapanese") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipRicePaddyWagon1") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCArmedFishermenIndians") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipDisciple1") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIndianMonkCombat") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipShrineWagon1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoveredWagonsAsian") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoveredWagonsChina") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoveredWagonsIndians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCoveredWagons2Indians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCIndianMonkFrighten") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCSacredFieldHealing") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCBazaar") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCGoraksha") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCExpandedMarket") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCCommoditiesMarket") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedMonastery") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCAdvancedMonasteryIndians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipBerryWagon1") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipRicePaddyWagon1") ||
					
					
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipMorutaru1") ||
				(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipMorutaru2"))
				xsArraySetInt(gCardPriorities, i, 0);  // Cards to be avoided, pri 0
				
				// Set priority to 0 for castle wagon cards to be specifically avoided for Japanese,
				// depending on whether this is a team game or not (only for HC level >= 30)
				if ((kbGetCiv() == cCivJapanese) && (kbResourceGet(cResourceSkillPoints) >= 30))
				{
					if (getAllyCount() > 0)
					{
						if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons1") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons3"))
						xsArraySetInt(gCardPriorities, i, 10);  // Re-evaluated as prerequisite cards, pri 10 (ignored later)
					}
					else
					{
						if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagonsTeam") ||
							(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagonsTeam2") ||
						(kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagons3"))
						xsArraySetInt(gCardPriorities, i, 0);  // Cards to be avoided, pri 0
					}
				}
				
				// Set priority to 0 for cards to be specifically avoided for Russians, as a bug
				// in aiHCDeckAddCardToDeck() keeps 'Advanced Balloon' from being added
				if (kbGetCiv() == cCivRussians)
				{
					if ((kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCXPAdvancedBalloon") ||
					(kbGetTechName(aiHCCardsGetCardTechID(i)) == "HCShipBalloons"))
					xsArraySetInt(gCardPriorities, i, 0);  // Cards to be avoided, pri 0
				}
				
				// Set priority to 0 for card to be specifically avoided for Indians, as a bug
				// in aiHCDeckAddCardToDeck() keeps 'Foreign Logging' from being added
				if (kbGetCiv() == cCivIndians)
				{
					if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCForeignLogging") 
					xsArraySetInt(gCardPriorities, i, 0);  // Card to be avoided, pri 0
				}
				
				// Set priority to 0 for card to be specifically avoided for Japanese, as a bug
				// in aiHCDeckAddCardToDeck() keeps '2 Team Castle Wagons' from being added
				if (kbGetCiv() == cCivJapanese)
				{
					if (kbGetTechName(aiHCCardsGetCardTechID(i)) == "YPHCShipCastleWagonsTeam2") 
					xsArraySetInt(gCardPriorities, i, 0);  // Card to be avoided, pri 0
				}
				
				// Set priority to 0 for archaic soldier cards in ages 3 and 4
				if ((aiHCCardsGetCardAgePrereq(i) == cAge3) || (aiHCCardsGetCardAgePrereq(i) == cAge4))
				{
					if ((aiHCCardsGetCardUnitType(i) == cUnitTypePikeman) ||
						(aiHCCardsGetCardUnitType(i) == cUnitTypeCrossbowman) ||
						(aiHCCardsGetCardUnitType(i) == cUnitTypeLongbowman) ||
						(aiHCCardsGetCardUnitType(i) == cUnitTypeStrelet) ||
						(aiHCCardsGetCardUnitType(i) == cUnitTypeypYumi) ||
						(aiHCCardsGetCardUnitType(i) == cUnitTypeFlatbowman) ||
						(aiHCCardsGetCardUnitType(i) == cUnitTypeypQiangPikeman) ||
					(aiHCCardsGetCardUnitType(i) == cUnitTypeypChuKoNu))
					xsArraySetInt(gCardPriorities, i, 0);  // Units to be to be avoided, pri 0
				}
				
				if ( (xsArrayGetInt(gCardPriorities, i) == 0) && (xsArrayGetString(gCardStates, i)=="P") )
				{  // We own this card, but it's not in the categories above, and won't be flagged when we do our purchases.
					// So, give it a P1 just to distinguish it from others.
					xsArraySetInt(gCardPriorities, i, 1);
				}
				if ((kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy))
				{  
					if ( (tech == cTechYPHCShipDaimyoAizu) || (tech == cTechYPHCShipDaimyoSatsuma) || (tech == cTechYPHCShipDaimyoTokushima) || (tech == cTechYPHCShipShogunate)
						|| (tech == cTechYPSPCHCShipDaimyoKiyomasa) || (tech == cTechYPSPCHCShipDaimyoMasamune) || (tech == cTechYPSPCHCShipDaimyoTadaoki) ) {
						xsArraySetInt(gCardPriorities, i, 0);  // BHG: don't want spcjapanese sending in unapproved daimyos
					}
				}
				if (kbGetCiv() == cCivSPCIndians)
				{  
					if ( (tech == cTechYPHCShipSepoy1) || (tech == cTechYPHCShipSepoy2) || (tech == cTechYPHCShipSepoy3) || (tech == cTechYPHCShipSepoy4) ) {
						xsArraySetInt(gCardPriorities, i, 0);  // BHG: don't want spcindians sending in unapproved sepoys
					}
				}
				if((kbGetTechName(aiHCCardsGetCardTechID(i)) ==  "HCExtensiveFortifications") || (kbGetTechName(aiHCCardsGetCardTechID(i)) ==  "HCXPUnlockFort2"))
				{
					xsArraySetInt(gCardPriorities, i, 10);
				}
				
				if((kbGetTechName(aiHCCardsGetCardTechID(i)) ==  "HCEnableMiners"))
				{
					xsArraySetInt(gCardPriorities, i, 11);
				}	
				
				
				// Priorities 2-4 will be set when the card is purchased, based on "find best" category that gets them.
				
				if (aiHCCardsIsCardBought(i) == true)
				xsArraySetString(gCardStates, i, "P"); // Purchased
				else
				{
					if (aiHCCardsCanIBuyThisCard(-1, i) == true)
					xsArraySetString(gCardStates, i, "A"); // Available
					else
					xsArraySetString(gCardStates, i, "N"); // Not available
				}
				if (kbGetCiv() == cCivSPCIndians)
				{  
					if ( (tech == cTechYPHCShipSepoy1) || (tech == cTechYPHCShipSepoy2) || (tech == cTechYPHCShipSepoy3) || (tech == cTechYPHCShipSepoy4) ) {
						xsArraySetString(gCardStates, i, "N");  // BHG: don't want spcindians sending in unapproved sepoys
					}
				}
				
				if (aiHCCardsGetCardCount(i) < 0)
				tempString = " Infinite";
				else
				tempString = "   "+aiHCCardsGetCardCount(i)+" use";
				tempString = tempString + " Pri "+xsArrayGetInt(gCardPriorities, i)+" ";
				tempString = tempString + " "+xsArrayGetString(gCardStates, i);
				tempString = tempString + "  L"+aiHCCardsGetCardLevel(i);
				tempString = tempString + "  A"+aiHCCardsGetCardAgePrereq(i);
				tempString = tempString + " ("+tech+") "+kbGetTechName(tech);
				if (unit >= 0)
				{
					tempString = tempString + " "+aiHCCardsGetCardUnitCount(i)+" "+kbGetProtoUnitName(unit);
				}
				
				xsArraySetString(gCardNames, i, tempString);
				aiEcho(i+" "+tempString);
			}
			pass = 1;   // Buy cards next time
			break;
		}
		case 1:  // Buy cards
		{
			
			for (attempt = 0; < 5)
			{
				//aiEcho("Purchase attempt "+attempt);
				
				if (remainingSP <= 0) // Have no points to spend...
				break;
				
				bool result = false;
				
				int boughtCardIndex = -1;
				int highestPriority = 0;   // Priority higher than this will be bought.
				// First, scan for the high-priority cards.
				for (index=0; <totalCardCount)  
				{  // Scan the list, looking for the highest-priority card still available
					if ( (aiHCCardsGetCardLevel(index) > myLevel) || (aiHCCardsCanIBuyThisCard(-1, index) == false) || (xsArrayGetString(gCardStates, index) == "P"))
					continue;   // Skip it.  Note...I use the "P" (purchased) flag to indicate ones that are purchased, AND ones that have failed in a buy attempt.                  
					// It is legal and available
					if (xsArrayGetInt(gCardPriorities, index) > highestPriority)
					{
						boughtCardIndex = index;
						highestPriority = xsArrayGetInt(gCardPriorities, index);
					}
				}
				if (boughtCardIndex >= 0)
				{
					result = aiHCCardsBuyCard(boughtCardIndex);
					//aiEcho("Buying priority "+highestPriority+" card "+xsArrayGetString(gCardNames, boughtCardIndex));
				}
				
				int cardIndex = -1;
				if (boughtCardIndex < 0)
				{  // No special cards remain, look for best one in each category.          
					cardIndex = aiHCCardsFindBestCard(cHCCardTypeEcon, myLevel);
					if ( cardIndex >= 0 )
					{  // Any econ card
						result = aiHCCardsBuyCard(cardIndex);
						//aiEcho("Buying econ card "+xsArrayGetString(gCardNames, cardIndex));
						boughtCardIndex = index;
						xsArraySetInt(gCardPriorities, cardIndex, 4);   // Pri 4, econ card
						break;
					}           
					cardIndex = aiHCCardsFindBestCard(cHCCardTypeMilitary, myLevel);
					if ( cardIndex >= 0 )
					{  // Any military card
						result = aiHCCardsBuyCard(cardIndex);
						//aiEcho("Buying military card "+xsArrayGetString(gCardNames, cardIndex));
						boughtCardIndex = cardIndex;
						xsArraySetInt(gCardPriorities, cardIndex, 2);   // Pri 2, military card
						break;                   
					}
					cardIndex = aiHCCardsFindBestCard(cHCCardTypeWagon, myLevel);
					if ( cardIndex >= 0 )
					{  // Any wagon card
						result = aiHCCardsBuyCard(cardIndex);
						//aiEcho("Buying wagon card "+xsArrayGetString(gCardNames, cardIndex));
						boughtCardIndex = cardIndex;
						xsArraySetInt(gCardPriorities, cardIndex, 7);   // Pri 7, wagon card...shouldn't get any hits here.
						break;                   
					}
					cardIndex = aiHCCardsFindBestCard(cHCCardTypeTeam, myLevel);
					if ( cardIndex >= 0 )
					{  // Any team card
						result = aiHCCardsBuyCard(cardIndex);
						//aiEcho("Buying team card "+xsArrayGetString(gCardNames, cardIndex));
						boughtCardIndex = cardIndex;
						xsArraySetInt(gCardPriorities, cardIndex, 1);   // Pri 1, team card
						break;                   
					}    
				}
				
				// If we're here, we've either selected a card, or exhausted the list.
				if (boughtCardIndex < 0)
				{  // Nothing to buy?!
					//aiEcho("  ERROR!  We have points to spend, but no cards to buy.");
					pass = 2;   // go on to deck picking
					return;
				}
				// We've selected a card.  Did the purchase work?
				if (result == false)
				{  // It failed, blacklist this card by marking it owned in the array.
					aiEcho("  ERROR!  Failed to buy card "+xsArrayGetString(gCardNames, boughtCardIndex));
				}
				xsArraySetString(gCardStates, boughtCardIndex, "P");  // Even if purchase failed, mark it purchased so we don't get stuck on it.
				
				remainingSP = remainingSP - 1;
				SPSpent = SPSpent + 1;
				if (SPSpent >= 10) myLevel = 10;
				if (SPSpent >= 25) myLevel = 25;
				
				
			}  // For attempt 0..4
			
			
			
			
			
			if(lastRemainingSP == remainingSP)
			{
				pass = 2;
			}
			else
			{
				lastRemainingSP = remainingSP;
			}
			
			//if (remainingSP <= 0)
			// pass = 2;
		}  // case 1
		case 2:  // Make deck
		{  
			//aiEcho("Making deck");
			if (gSPC == true)
			{
				if (gDefaultDeck < 0)
				gDefaultDeck = aiHCDeckCreate("The AI Deck");
			}
			else
			{
				//-- In non spc games, the game will make an empty deck for AI's at index 0.
				gDefaultDeck = 0;
			}
			
			//aiEcho("Building Deck");
			int cardsRemaining = 25;
			int toPick = 5;
			
			// First, "best" cards (if available).
			for (card=0; < maxCards)
			{
				if ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCImprovedBuildings") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) ==  "HCExtensiveFortifications") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) ==  "HCXPUnlockFort2")||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCImprovedBuildingsGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeBritish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeDutch") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeFrench") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeOttoman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreePortuguese") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeRussian") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeSpanish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeItalians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeSwedish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalDecreeUS") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCAdvancedArsenal") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCAdvancedArsenalGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCAdvancedArsenalGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPNewWaysIroquois") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPNewWaysSioux") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUnlockFactory") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRobberBarons") ||
					((kbGetCiv() == cCivGermans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUnlockFactoryGerman")) ||												
					((kbGetCiv() == cCivGermans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRobberBaronsGerman")) ||								
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPIndustrialRevolution") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCExoticHardwoods") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCGrainMarket") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRefrigeration") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalMint") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCTextileMills") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRoyalMintGerman") ||								
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRefrigerationGerman") ||								
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCRoyalMintIndians") ||	
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCFencingSchoolIndians") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCRidingSchoolIndians") ||
					((kbGetCiv() == cCivGermans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCGermanTownFarmers")) ||
					((kbGetCiv() == cCivGermans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCGuildArtisans")) ||
					((kbGetCiv() == cCivGermans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCTeamTeutonTownCenter")) ||
					((kbGetCiv() == cCivGermans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCUhlanCombatGerman")) ||
					((kbGetCiv() == cCivDutch) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCDutchEastIndiaCompany")) ||
					((kbGetCiv() == cCivDutch) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBetterBanks")) ||
					((kbGetCiv() == cCivDutch) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBanks1")) ||
					((kbGetCiv() == cCivDutch) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCBanks2")) ||
					((kbGetCiv() == cCivRussians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRansack")) ||
					((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCGurkhaAid")) ||
					((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSustainableAgricultureIndians")) ||
					((kbGetCiv() == cCivJapanese) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCIncreasedTribute")) ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCMughalArchitecture") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCEastIndiaCompany") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCCamelDamageIndians") ||
					((kbGetCiv() == cCivXPIroquois) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRumDistillery")) ||
					((kbGetCiv() == cCivXPIroquois) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCSustainableAgriculture")) ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFencingSchool") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFencingSchoolGerman") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRidingSchool") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRidingSchoolGerman") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCJanissaryCombatOttoman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCJanissaryCost") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipShogunate") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCoyoteCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightDamage") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightHitpoints") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPKnightCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryCombatIroquois") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiegeCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPConservativeTactics") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPInfantryHitpointsIroquois") ||
					((kbGetCiv() == cCivXPSioux) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCommandSkill")) ||
					((kbGetCiv() == cCivXPSioux) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPMustangs")) ||
					((kbGetCiv() == cCivBritish) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCSpiceTrade")) ||
					((kbGetCiv() == cCivFrench) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCPioneers")) ||
					((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCLightArtilleryHitpointsOttoman")) ||
					((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArtilleryDamageOttoman")) ||
					((kbGetCiv() == cCivOttomans) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCArtilleryHitpointsOttomanTeam")) ||
					((kbGetCiv() == cCivFrench) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCNativeCombat")) ||
					((kbGetCiv() == cCivFrench) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCNativeWarriors")) ||
					((kbGetCiv() == cCivFrench) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryHitpointsFrench")) ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPAdoption") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPBuffalo4") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryDamageSioux") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryHitpointsSioux") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPCavalryCombatSioux") ||
					((kbGetCiv() == cCivXPSioux) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFoodSilos")) ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPMedicineTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPEarthBounty") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPWindRunner") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPNomadicExpansion") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatFrench") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryDamageFrenchTeam") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryDamageGermanTeam") ||								
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCDragoonCombatPortuguese") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatRussian") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCStreletsCombatRussian") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxTwoKettleSupport") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxSanteeSupport") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPSiouxYanktonSupport") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryCombatGerman") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryCombatSpanish") ||								
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMusketeerGrenadierCombatBritish") ||				
					((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipGroveWagonIndians2")) ||
					((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantTrampling")) ||
					((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantCombatIndians")) ||
					((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCElephantLimit")) ||
					((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipWoodCratesInf4Indians")) ||
					((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCCamelFrightening")) ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCHanAntiCavalryBonus") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAccupuncture") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCBannerSchool") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSamuraiDamage") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCNobleCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCNaginataHitpoints") ||	
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCNaginataAntiInfantryDamage") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYumiDamage") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCYumiRange") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAshigaruDamage") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCSamuraiSpeed") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCaballeros") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryHitpointsSpanish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandInfantryCombatSpanish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryCombatDutch") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatDutch") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatOttoman") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPExoticHardwoodsTeam") ||
					((kbGetCiv() == cCivRussians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCPioneers")) ||
					((kbGetCiv() == cCivRussians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCSpiceTrade")) ||
					((kbGetCiv() == cCivRussians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMedicine")) ||
					((kbGetCiv() == cCivXPSioux) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCPioneers")) ||
					((kbGetCiv() == cCivXPSioux) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCSpiceTrade")) ||
					((kbGetCiv() == cCivPortuguese) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCPioneers")) ||
					((kbGetCiv() == cCivPortuguese) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryCombatPortuguese")) ||
					((kbGetCiv() == cCivPortuguese) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryHitpointsPortugueseTeam")) ||
					((kbGetCiv() == cCivPortuguese) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCRangedInfantryDamagePortuguese")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCPioneers")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPChinampa1")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPChinampa2")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTempleCenteotl")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTempleXipeTotec")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTempleXolotl")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTempleCoatlicue")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTempleTlaloc")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPGreatTempleQuetzalcoatl")) ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCMusketeerGrenadierHitpointsBritishTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCImprovedBuildingsTeam") ||				
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCWildernessWarfare") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCInfantryHitpointsDutchTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCHandCavalryDamageFrenchTeam") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCCavalryCombatBritish") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCForbiddenArmyArmor") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCTerritorialArmyCombat") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCMongolianScourge") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCStandardArmyHitpoints") ||
					(kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCArtilleryCombatChinese") ||
					((kbGetCiv() == cCivXPSioux) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates4")) ||
					((kbGetCiv() == cCivBritish) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCImprovedLongbows")) ||
					((kbGetCiv() == cCivDutch) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCFrontierDefenses2")) ||
					((kbGetCiv() == cCivDutch) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPWarHutTraining")) ||
					((kbGetCiv() == cCivXPAztec) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTownDance")) ||
					((kbGetCiv() == cCivXPIroquois) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTownDance")) ||				
					((kbGetCiv() == cCivXPSioux) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPTownDance")) ||				
				((kbGetCiv() == cCivIndians) && (kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCAgrarianism") ))
				{
					aiHCDeckAddCardToDeck(gDefaultDeck, card);
					cardsRemaining = cardsRemaining - 1;
					xsArraySetString(gCardStates, card, "D");
					//aiEcho("  Adding card "+xsArrayGetString(gCardNames, card));
					
					
				}
			}  // 22-25 remaining.
			
			
			// Next, 3 econ-biased age 1 cards.
			toPick = 3;
			for (i=0; < toPick) 
			{  // 3 age 1 cards
				int bestCard = -1;
				int bestCardPri = -1;
				for (card=0; < maxCards)
				{
					if (xsArrayGetString(gCardStates, card) != "P")
					continue;   // Only consider purchased cards not already in deck.
					if (xsArrayGetInt(gCardPriorities, card) == 10)
					continue;   // Ignore so-called "prerequisite cards"
					if (aiHCCardsGetCardAgePrereq(card) != cAge1)
					continue;
					if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
				}
				if (bestCard >= 0)
				{
					aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
					cardsRemaining = cardsRemaining - 1;
					xsArraySetString(gCardStates, bestCard, "D");
					//aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
				}
			}  // 19-22 remaining.
			
			
			// Next, econ-biased age 2 cards. 2 for rusher, 3 for others.
			toPick = 3;
			if (btRushBoom > 0)
            toPick = 2;
			for (i=0; < toPick) 
			{  
				bestCard = -1;
				bestCardPri = -1;
				for (card=0; < maxCards)
				{
					if (xsArrayGetString(gCardStates, card) != "P")
					continue;   // Only consider purchased cards not already in deck.
					if (xsArrayGetInt(gCardPriorities, card) == 10)
					continue;   // Ignore so-called "prerequisite cards"
					if (aiHCCardsGetCardAgePrereq(card) != cAge2)
					continue;
					if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
					else if (((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipFoodCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipCoinCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipFoodCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipCoinCrates2German")) ||
					((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipFoodCrates3Indians") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "YPHCShipFoodCrates2Indians")))
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;  // make sure 700 resource cards win over 600 resource cards
					}
					else if (((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates2") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates3")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates2") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates3")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates2German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipWoodCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipFoodCrates3German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates2German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates2German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCShipCoinCrates3German") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "HCShipWoodCrates3German")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipWoodCrates2Indians") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "YPHCShipFoodCrates2Indians")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipWoodCrates2Indians") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "YPHCShipFoodCrates3Indians")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "YPHCShipCoinCrates2Indians") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "YPHCShipWoodCrates2Indians")) ||
                        ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "ypHCShipWoodCrates2") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "ypHCShipFoodCrates2")) ||
					((kbGetTechName(aiHCCardsGetCardTechID(card)) == "ypHCShipCoinCrates2") && (kbGetTechName(aiHCCardsGetCardTechID(bestCard)) == "ypHCShipWoodCrates2")))
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;  // make sure wood wins over food and coin wins over wood in Age 2 (for India, even 600 wood/coin wins over 700 food)
					}
				}
				if (bestCard >= 0)
				{
					aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
					cardsRemaining = cardsRemaining - 1;
					xsArraySetString(gCardStates, bestCard, "D");
					//aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
				}
			}  // 16-20 remaining
			
			
			// Next, age 2 military cards.  2 for a boomer, 5 for a rusher.
			toPick = 2 + ((btRushBoom+1.0) * 1.51); // Boomer 2, rusher 5
			for (i=0; < toPick) 
			{  
				bestCard = -1;
				bestCardPri = -1;
				for (card=0; < maxCards)
				{
					if (xsArrayGetString(gCardStates, card) != "P")
					continue;   // Only consider purchased cards not already in deck.
					if (aiHCCardsGetCardAgePrereq(card) != cAge2)
					continue;
					if (xsArrayGetInt(gCardPriorities, card) != 5)
					continue;   // Ignore everything except military cards
					if (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercenary) == true)
					continue;   // Ignore any mercenary cards
					
					
					if (((civIsNative() == true) || (civIsAsian() == true)) && (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercType1) == true))
					continue;   // For natives and Asians, ignore any native allies cards (to be added later)
					if ((civIsNative() == true) && ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeRodelero) == true) ||
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeCuirassier) == true) ||
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeHalberdier) == true)))
					continue;   // For natives, ignore any renegade cards (to be added later)
					if ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawPistol) == true) ||
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRider) == true) ||
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRifleman) == true))
					continue;   // Ignore any outlaw cards (to be added later)
					if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
					else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) && 
					( (kbGetProtoUnitAICost(aiHCCardsGetCardUnitType(card))*aiHCCardsGetCardUnitCount(card)) > (kbGetProtoUnitAICost(aiHCCardsGetCardUnitType(bestCard))*aiHCCardsGetCardUnitCount(bestCard)) )) 
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
				}
				if (bestCard >= 0)
				{
					aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
					cardsRemaining = cardsRemaining - 1;
					xsArraySetString(gCardStates, bestCard, "D");
					//aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
				}
			} // 12-17 remaining
			
			
			// Next, 5 age 3 cards (more may be added later), but no mercenaries or allies.
			toPick = 5;
			for (i=0; < toPick) 
			{  
				bestCard = -1;
				bestCardPri = -1;
				for (card=0; < maxCards)
				{
					if (xsArrayGetString(gCardStates, card) != "P")
					continue;   // Only consider purchased cards not already in deck.
					if (xsArrayGetInt(gCardPriorities, card) == 10)
					continue;   // Ignore so-called "prerequisite cards"
					if (xsArrayGetInt(gCardPriorities, card) == 6)
					continue;   // Ignore resource cards
					if (aiHCCardsGetCardAgePrereq(card) != cAge3)
					continue;
					if (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercenary) == true)
					continue;   // Ignore any mercenary cards
					
					
					if (((civIsNative() == true) || (civIsAsian() == true)) && (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercType1) == true))
					continue;   // For natives and Asians, ignore any native allies cards (to be added later)
					if ((civIsNative() == true) && ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeRodelero) == true) ||
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeCuirassier) == true) ||
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeHalberdier) == true)))
					continue;   // For natives, ignore any renegade cards (to be added later)
					if ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawPistol) == true) ||
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRider) == true) ||
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRifleman) == true))
					continue;   // Ignore any outlaw cards (to be added later)
					if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
					else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) && 
					( (kbGetProtoUnitAICost(aiHCCardsGetCardUnitType(card))*aiHCCardsGetCardUnitCount(card)) > (kbGetProtoUnitAICost(aiHCCardsGetCardUnitType(bestCard))*aiHCCardsGetCardUnitCount(bestCard)) )) 
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
				}
				if (bestCard >= 0)
				{
					aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
					cardsRemaining = cardsRemaining - 1;
					xsArraySetString(gCardStates, bestCard, "D");
					//aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
				}
			}  // 7-12 remaining.
			
			
			// Next, 3 age 4 cards (more may be added later), but no mercenaries or allies.
			toPick = 3;
			for (i=0; < toPick) 
			{
				bestCard = -1;
				bestCardPri = -1;
				for (card=0; < maxCards)
				{
					if (xsArrayGetString(gCardStates, card) != "P")
					continue;   // Only consider purchased cards not already in deck.
					if (xsArrayGetInt(gCardPriorities, card) == 10)
					continue;   // Ignore so-called "prerequisite cards"
					if (xsArrayGetInt(gCardPriorities, card) == 6)
					continue;   // Ignore resource cards
					if (aiHCCardsGetCardAgePrereq(card) != cAge4)
					continue;
					if (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercenary) == true)
					continue;   // Ignore any mercenary cards
					
					
					if (((civIsNative() == true) || (civIsAsian() == true)) && (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercType1) == true))
					continue;   // For natives and Asians, ignore any native allies cards (to be added later)
					if ((civIsNative() == true) && ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeRodelero) == true) ||
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeCuirassier) == true) ||
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeHalberdier) == true)))
					continue;   // For natives, ignore any renegade cards (to be added later)
					if ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawPistol) == true) ||
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRider) == true) ||
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRifleman) == true))
					continue;   // Ignore any outlaw cards (to be added later)
					if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
					else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) && 
					( (kbGetProtoUnitAICost(aiHCCardsGetCardUnitType(card))*aiHCCardsGetCardUnitCount(card)) > (kbGetProtoUnitAICost(aiHCCardsGetCardUnitType(bestCard))*aiHCCardsGetCardUnitCount(bestCard)) )) 
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
				}
				if (bestCard >= 0)
				{
					aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
					cardsRemaining = cardsRemaining - 1;
					xsArraySetString(gCardStates, bestCard, "D");
					//aiEcho("  Adding card "+xsArrayGetString(gCardNames, bestCard));
				}
			} // 4-9 remaining.
			
			// Next, 'Advanced Balloon' (if available, but not for Russians).
			for (card=0; < maxCards)
			{
				if ((kbGetTechName(aiHCCardsGetCardTechID(card)) == "HCXPAdvancedBalloon") && (kbGetCiv() != cCivRussians))
				{
					aiHCDeckAddCardToDeck(gDefaultDeck, card);
					cardsRemaining = cardsRemaining - 1;
					xsArraySetString(gCardStates, card, "D");
					//aiEcho("  Adding card "+xsArrayGetString(gCardNames, card));
				}
			}  // 0-9 remaining.
			
			
			// Finally, remaining cards from any age, usually military units
			// Mercenaries and allies will be ignored here
			
			for (i=0; < cardsRemaining) 
			{
				
				bestCard = -1;
				bestCardPri = -1;
				for (card=0; < maxCards)
				{
					if (xsArrayGetString(gCardStates, card) != "P")
					continue;   // Only consider purchased cards not already in deck.
					if (xsArrayGetInt(gCardPriorities, card) == 10)
					continue;   // Ignore so-called "prerequisite cards"
					if ((xsArrayGetInt(gCardPriorities, card) == 6) || (xsArrayGetInt(gCardPriorities, card) == 8))
					continue;   // Ignore resource cards
					if (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercenary) == true)
					continue;   // Ignore any mercenary cards
					
					
					if (((civIsNative() == true) || (civIsAsian() == true)) && (kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeMercType1) == true) &&
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypexpSkullKnight) == false) &&
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypexpDogSoldier) == false))
					continue;   // For natives and Asians, ignore any native allies cards (excluding skull knights and dog soldiers, both wrongly classified as MercType1)
					if ((civIsNative() == true) && ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeRodelero) == true) ||
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeCuirassier) == true) ||
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeHalberdier) == true)))
					continue;   // For natives, ignore any renegade cards
					if ((kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawPistol) == true) ||
						(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRider) == true) ||
					(kbProtoUnitIsType(cMyID, aiHCCardsGetCardUnitType(card), cUnitTypeSaloonOutlawRifleman) == true))
					continue;   // Ignore any outlaw cards
					
					
					if (xsArrayGetInt(gCardPriorities, card) > bestCardPri)
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
					else if ((xsArrayGetInt(gCardPriorities, card) == bestCardPri) && 
					( (kbGetProtoUnitAICost(aiHCCardsGetCardUnitType(card))*aiHCCardsGetCardUnitCount(card)) > (kbGetProtoUnitAICost(aiHCCardsGetCardUnitType(bestCard))*aiHCCardsGetCardUnitCount(bestCard)) )) 
					{
						bestCardPri = xsArrayGetInt(gCardPriorities, card);
						bestCard = card;
					}
				}
				if (bestCard >= 0)
				{
					aiHCDeckAddCardToDeck(gDefaultDeck, bestCard);
					//cardsRemaining = cardsRemaining - 1;
					xsArraySetString(gCardStates, bestCard, "D");
					
				}
			}  // All done, no cards remaining. 
			
			//	    for(i = 0; < maxCards)
			//{
				//  aiHCDeckAddCardToDeck(gDefaultDeck, i);
			//}
			
			
			aiHCDeckActivate(gDefaultDeck);
			
			xsDisableSelf();
			break;
		}
	}
}
//==============================================================================
// init...Called once we have units in the new world.
//==============================================================================
void init(void)
{
	//Set the Explore Danger Threshold.
	aiSetExploreDangerThreshold(110.0);
	
	//Setup the resign handler
	aiSetHandler("resignHandler", cXSResignHandler);
	
	//Setup the nugget handler
	aiSetHandler("nuggetHandler", cXSNuggetHandler);
	
	// Set up the age-up chat handler
	aiSetHandler("ageUpHandler", cXSPlayerAgeHandler);
	
	//-- set the ScoreOppHandler
	aiSetHandler("scoreOpportunity", cXSScoreOppHandler);
	
	//Set up the communication handler
	aiCommsSetEventHandler("commHandler");
	
	// This handler runs when you have a shipment available in the home city
	aiSetHandler("shipGrantedHandler", cXSShipResourceGranted);
	
	// Handlers for mission start/end
	aiSetHandler("missionStartHandler",cXSMissionStartHandler);
	aiSetHandler("missionEndHandler",cXSMissionEndHandler);
	
	// Game ending handler, to save game-to-game data before game ends
	aiSetHandler("gameOverHandler",cXSGameOverHandler);
	
	// Handler when a player starts the monopoly victory timer
	aiSetHandler("monopolyStartHandler",cXSMonopolyStartHandler);
	
	// And when a monopoly timer prematurely ends
	aiSetHandler("monopolyEndHandler",cXSMonopolyEndHandler);
	
	// Handler when a player starts the KOTH victory timer
	aiSetHandler("KOTHVictoryStartHandler",cXSKOTHVictoryStartHandler);
	
	// And when a KOTH timer prematurely ends
	aiSetHandler("KOTHVictoryEndHandler",cXSKOTHVictoryEndHandler);
	
	//-- init Econ and Military stuff.
	initEcon();
	initMil();
	
	if ( (aiGetGameType() == cGameTypeCampaign) || (aiGetGameType() == cGameTypeScenario) )
	cvOkToResign = false;   // Default is to not allow resignation in scenarios.  Can override in postInit().
	
	// Fishing always viable on these maps
	if ( (cRandomMapName=="carolina") ||  
	(cRandomMapName=="carolinalarge") || 
	(cRandomMapName=="newengland") || 
	(cRandomMapName=="caribbean") || 
	(cRandomMapName=="patagonia") || 
	(cRandomMapName=="yucatan") ||
	(cRandomMapName=="caribbean") ||
        (cRandomMapName=="hispaniola") ||
        (cRandomMapName=="araucania") ||
        (cRandomMapName=="california") ||
        (cRandomMapName=="northwestterritory") ||
        (cRandomMapName=="saguenay") ||
        (cRandomMapName=="saguenaylarge") ||
        (cRandomMapName=="unknown") ||
        (cRandomMapName=="ceylon") ||
        (cRandomMapName=="borneo") ||
        (cRandomMapName=="honshu") ||
        (cRandomMapName=="regicidehonshu") ||
        (cRandomMapName=="korea") ||
        (cRandomMapName=="ESOCalaska") ||
        (cRandomMapName=="ESOCbajacalifornia") ||
        (cRandomMapName=="ESOCdhaka") ||
        (cRandomMapName=="ESOCflorida") ||
        (cRandomMapName=="ESOCindonesia") ||
        (cRandomMapName=="ESOCmalaysia") ||
        (cRandomMapName=="ESOCmanchuria") ||
        (cRandomMapName=="ESOCthailand") ||
        (cRandomMapName=="volgadelta") ||
	(cRandomMapName=="yellowriverwet") )
	{
		gGoodFishingMap = true;    
	}
	if (gSPC == false)
	if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)   // We have a flag, there must be water...
	gGoodFishingMap = true;
	
	if (gSPC == true) 
	{
		if (aiIsMapType("AIFishingUseful") == true)
		gGoodFishingMap = true;
		else
		gGoodFishingMap = false;
	}
	
	if ( (cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "ceylon") )
	gNavyMap = true;
	if (gSPC == false)
	{
		if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)   // We have a flag, there must be water...
		gNavyMap = true;     
		else
		{
			gNavyMap = false;
			//aiEcho("No water flag found, turning off navy.");
		}
	}
	if (gSPC == true)
	{
		if (kbUnitCount(cMyID, cUnitTypeHomeCityWaterSpawnFlag) > 0)   // We have a flag, there must be water...
		gNavyMap = true;    
		else
		gNavyMap = false;
	}
	
	// natives aim for slightly more villagers (fire pit dancers!)
	if (civIsNative() == true)
	{
		int i = 0;
		for (i=0; <=cAge5)
		{
			xsArraySetInt(gTargetSettlerCounts, i, xsArrayGetInt(gTargetSettlerCounts, i) * 1.1);
		}
	}
	
	
	// Create a temporary main base so the plans have something to deal with.
	// If there is a scenarioStart object, use it.  If not, use the TC, if any.
	// Failing that, use an explorer, a war chief, a monk, a settlerWagon, or a Settler.  
	// Failing that, select any freakin' unit and use it.
	vector tempBaseVec = cInvalidVector;
	int unitID = -1;
	unitID = getUnit(cUnitTypeAIStart, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(gTownCenter, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypeExplorer, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypexpAztecWarchief, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypexpIroquoisWarChief, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypexpLakotaWarchief, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypeypMonkChinese, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypeypMonkIndian, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypeypMonkIndian2, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypeypMonkJapanese, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypeypMonkJapanese2, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(gCoveredWagonUnit, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(cUnitTypeSettler, cMyID, cUnitStateAlive);
	if (unitID < 0)
	unitID = getUnit(gEconUnit, cMyID, cUnitStateAlive);
	
	if (unitID < 0)
	aiEcho("**** I give up...I can't find an aiStart unit, TC, wagon, explorer or settler.  How do you expect me to play?!");
	else
	tempBaseVec = kbUnitGetPosition(unitID);
	
	// This will create an interim main base at this location. 
	// Only done if there is no TC, otherwise we rely on the auto-created base
	if ( (gStartMode == cStartModeScenarioNoTC) || (getUnit(gTownCenter, cMyID, cUnitStateAlive) < 0) )
	gMainBase = createMainBase(tempBaseVec);     
	
	// If we have a covered wagon, let's pick a spot for the TC search to begin, and a TC start time to activate the build plan.
	int coveredWagon = getUnit(gCoveredWagonUnit, cMyID, cUnitStateAlive);
	if (coveredWagon >= 0)
	{
		vector coveredWagonPos = kbUnitGetPosition(coveredWagon);
		vector normalVec = xsVectorNormalize(kbGetMapCenter()-coveredWagonPos);
		int offset = 40;
		gTCSearchVector = coveredWagonPos + (normalVec * offset);
		
		while (  kbAreaGroupGetIDByPosition(gTCSearchVector) != kbAreaGroupGetIDByPosition(coveredWagonPos) )
		{  
			// Try for a goto point 40 meters toward center.  Fall back 5m at a time if that's on another continent/ocean.  
			// If under 5, we'll take it.
			offset = offset - 5;
			gTCSearchVector = coveredWagonPos + (normalVec * offset);
			if (offset < 5)
            break;  
		}
		
		// Note...if this is a scenario, we should use the AIStart object's position, NOT the covered wagon position.  Override...
		int aiStart = getUnit(cUnitTypeAIStart, cMyID, cUnitStateAny);
		if (aiStart >= 0)
		{
			gTCSearchVector = kbUnitGetPosition(aiStart);
			//aiEcho("Using aiStart object at "+gTCSearchVector+" to start TC placement search");
		}
	}
	
	
	// Keep Dutch envoy busy
	xsEnableRule("envoyMonitor");
	
	// Keep native scouts busy
	xsEnableRule("nativeScoutMonitor");
	
	// Keep mongol scouts busy
	xsEnableRule("mongolScoutMonitor");
	
	// Enable explorer rescue plan
	xsEnableRule("rescueExplorer");
	
	// Enable explorer ransoming
	xsEnableRule("ransomExplorer");
	
	// Disables early groups, starts nugget hunting, moves explorer later.
	xsEnableRule("exploreMonitor"); 
	
	if ( (gStartMode == cStartModeScenarioWagon) || 
		(gStartMode == cStartModeLandWagon) || 
	(gStartMode == cStartModeBoat) )
	{
		//aiEcho("Creating a TC build plan.");
		// Make a town center, pri 100, econ, main base, 1 builder.
		int buildPlan=aiPlanCreate("TC Build plan ", cPlanBuild);
		// What to build
		aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTownCenter);
		// Priority.
		aiPlanSetDesiredPriority(buildPlan, 100);
		// Mil vs. Econ.
		aiPlanSetMilitary(buildPlan, false);
		aiPlanSetEconomy(buildPlan, true);
		// Escrow.
		aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
		// Builders.
		if ( (gStartMode == cStartModeBoat) && (kbUnitCount(cMyID, gCoveredWagonUnit, cUnitStateAlive) == 0) )
		{
			switch(kbGetCiv())
			{
				case cCivXPAztec:
				{
					aiPlanAddUnitType(buildPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
					break;
				}
				case cCivXPIroquois:
				{
					aiPlanAddUnitType(buildPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
					break;
				}
				case cCivXPSioux:
				{
					aiPlanAddUnitType(buildPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
					break;
				}
				case cCivChinese:
				{
					aiPlanAddUnitType(buildPlan, cUnitTypeypMonkChinese, 1, 1, 1);
					break;
				}
				case cCivIndians:
				{
					aiPlanAddUnitType(buildPlan, cUnitTypeypMonkIndian, 1, 1, 1);
					aiPlanAddUnitType(buildPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
					break;
				}
				case cCivJapanese:
				{
					aiPlanAddUnitType(buildPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
					aiPlanAddUnitType(buildPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
					break;
				}
				default:
				{
					aiPlanAddUnitType(buildPlan, cUnitTypeExplorer, 1, 1, 1);
					break;
				}
			}
		}
		else
		{
			aiPlanAddUnitType(buildPlan, gCoveredWagonUnit, 1, 1, 1);
		}
		// Instead of base ID or areas, use a center position and falloff.
		if(gTCSearchVector == cInvalidVector)
		aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, coveredWagonPos);
		else
		aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, gTCSearchVector);
		aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, 40.00);
		
		// Add position influences for trees, gold
		aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, true);
		aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 3, true);
		aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 3, true);
		aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, true);
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 30.0);     // 30m range.
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);        // 10 points per tree
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1, 50.0);              // 50 meter range for gold
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 300.0);                // 300 points each
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2, 20.0);              // 20 meter inhibition to keep some space
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -300.0);                // -300 points each
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);      // Cliff falloff
		
		// Two position weights
		aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePosition, 2, true);
		aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionDistance, 2, true);
		aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionValue, 2, true);
		aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluencePositionFalloff, 2, true);
		
		// Give it a positive but wide-range prefernce for the search area, and a more intense but smaller negative to avoid the landing area.
		// Weight it to prefer the general starting neighborhood
		aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, gTCSearchVector);    // Position influence for search position
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 200.0);     // 200m range.
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);        // 300 points max
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
		
		// Add negative weight to avoid initial drop-off beach area
		aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 1, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));    // Position influence for landing position
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 1, 50.0);     // Smaller, 50m range.
		aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 1, -400.0);      // -400 points max
		aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
		// This combo will make it dislike the immediate landing (-100), score +25 at 50m, score +150 at 100m, then gradually fade to +0 at 200m.
		
		
		// Wait to activate TC build plan, to allow adequate exploration
		gTCBuildPlanID = buildPlan;   // Save in a global var so the rule can access it.
		aiPlanSetEventHandler(buildPlan, cPlanEventStateChange, "tcPlacedEventHandler");    
		
		xsEnableRule("tcBuildPlanDelay");
	}
	
	if (cvOkToBuildDeck == true)
	{
		xsEnableRule("buyCards");
	}
	
	xsEnableRule("townCenterComplete");  // Rule to build other buildings after TC completion
	//xsEnableRule("useCoveredWagons");   
	//xsEnableRule("useFactoryWagons");
	xsEnableRule("tcMonitor");    // Has explorer, war chief, Asian monks or settlers build a TC if there is none
	xsEnableRule("ageUpgradeMonitor");  // Make sure we freeze spending to allow age-ups at certain villie pop levels
	
	
	postInit();		// All normal initialization is done, let loader file clean up what it needs to.
	
	//aiEcho("INITIAL BEHAVIOR SETTINGS");
	//aiEcho("    Rush "+btRushBoom);
	//aiEcho("    Offense "+btOffenseDefense);
	//aiEcho("    Cav "+btBiasCav);
	//aiEcho("    Inf "+btBiasInf);
	//aiEcho("    Art "+btBiasArt);
	//aiEcho("    Natives "+btBiasNative);
	//aiEcho("    Trade "+btBiasTrade);
	
	// Re-do politician choices now that postInit() is complete...
	int poliScores = xsArrayCreateFloat(6, 0.0, "Politician scores");
	int numChoices = -1;
	int politician = -1;
	float bonus = 0.0;
	
	for (age = cAge2; <= cAge5)
	{
		for (p=0; <6)
		xsArraySetFloat(poliScores, p, 0.0);   // Reset scores
		numChoices = aiGetPoliticianListCount(age);
		for (p=0; <numChoices)
		{  // Score each of these choices based on the strength of our behavior settings.
			politician = aiGetPoliticianListByIndex(age, p);
			// Rusher bonuses
			if (btRushBoom > 0.0)
            bonus = btRushBoom;
			else
            bonus = 0.0;
			if (  (politician == cTechPoliticianQuartermaster) || 
				(politician == cTechPoliticianScout) ||
				(politician == cTechPoliticianScoutRussian) ||
				(politician == cTechPoliticianSergeantDutch) || 
				(politician == cTechPoliticianSergeantGerman) ||
				(politician == cTechPoliticianSergeantSpanish) || 
				(politician == cTechPoliticianMohawk) || 
				(politician == cTechPoliticianMarksman) ||
				(politician == cTechPoliticianMarksmanOttoman) ||
				(politician == cTechPoliticianMarksmanPortuguese) ||
				(politician == cTechPoliticianAdventurerBritish) ||
				(politician == cTechPoliticianAdventurerRussian) ||
			(politician == cTechPoliticianAdventurerSpanish) )
			{
				xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Add in a bonus based on our rusher trait.
			}
			// Boomer bonuses
			if (btRushBoom < 0.0)
            bonus = -1.0 * btRushBoom;
			else
            bonus = 0.0;
			if (  (politician == cTechPoliticianBishop) ||
				(politician == cTechPoliticianBishopGerman) ||
				(politician == cTechPoliticianTycoon) ||
				(politician == cTechPoliticianExiledPrince) ||
				(politician == cTechPoliticianPresidenteEU) ||
			(politician == cTechPoliticianPresidente) )
			{
				xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Add in a bonus based on our boomer trait.
			}
			// Defense bonuses
			if (btOffenseDefense < 0.0)
            bonus = -1.0 * btOffenseDefense; // Defense rating
			else
            bonus = 0.0;
			if (politician == cTechPoliticianGovernor)
			{
				xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Add in a bonus based on our defense trait.
			}
			// Offense bonuses
			if (btOffenseDefense > 0.0)
            bonus = btOffenseDefense;
			else
            bonus = 0.0;
			if (  (politician == cTechPoliticianScout) ||
				(politician == cTechPoliticianScoutRussian) ||
				(politician == cTechPoliticianSergeantDutch) || 
				(politician == cTechPoliticianSergeantGerman) ||
				(politician == cTechPoliticianSergeantSpanish) || 
				(politician == cTechPoliticianMohawk) || 
				(politician == cTechPoliticianMarksman) ||
				(politician == cTechPoliticianMarksmanOttoman) ||
				(politician == cTechPoliticianMarksmanPortuguese) ||
				(politician == cTechPoliticianAdventurerBritish) ||
				(politician == cTechPoliticianAdventurerRussian) ||
				(politician == cTechPoliticianAdventurerSpanish) ||
				(politician == cTechPoliticianGeneral) ||
				(politician == cTechPoliticianGeneralUSA) ||
				(politician == cTechPoliticianGeneralBritish) ||
			(politician == cTechPoliticianGeneralOttoman) )
			{
				xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Add in a bonus based on our offense trait.
			}
			if (gNavyMap == false)
			{
				bonus = -10.0; // Essentially disqualify any navy polis
				if (  (politician == cTechPoliticianAdmiral) ||
					(politician == cTechPoliticianAdmiralOttoman) ||
				(politician == cTechPoliticianPirate) )
				{
					xsArraySetFloat(poliScores, p, xsArrayGetFloat(poliScores, p) + bonus); // Disqualify naval polis on land maps
				}
			}         
		}  // for (p=0; <numChoices)
		
		// The scores are set, find the high score
		int bestChoice = 0;        // Select 0th item if all else fails
		float bestScore = -100.0;  // Impossibly low
		for (p=0; <numChoices)
		{
			if (xsArrayGetFloat(poliScores, p) > bestScore)
			{
				bestScore = xsArrayGetFloat(poliScores, p);
				bestChoice = p;
			}
		}
		politician = aiGetPoliticianListByIndex(age, bestChoice);
		aiSetPoliticianChoice(age, politician);
		//aiEcho("Politician for age "+age+" is #"+politician+", "+kbGetTechName(politician));
	} //for (age = cAge2; <= cAge5)
}

//==============================================================================
// initRule
// Add a brief delay to make sure the covered wagon (if any) has time to unload
//==============================================================================
rule initRule
inactive
minInterval 3
{
	if (cvInactiveAI == true) 
	return;  // Wait forever unless this changes
	init();
	
	xsDisableSelf();
}

//==============================================================================
// ottomanMonitor
// Make sure they always have a church, get techs as available
//==============================================================================
rule ottomanMonitor
inactive
minInterval 30
{  
	int speedPlanID = -1;   // Plan for improving vill training speed.
	int capPlanID = -1;     // Plan for raising settler pop limit.
	int churchPlanID = -1;
	
	// Disable rule once all techs have been researched
	if ((kbTechGetStatus(cTechChurchMilletSystem) == cTechStatusActive) &&
		(kbTechGetStatus(cTechChurchKopruluViziers) == cTechStatusActive) &&
		(kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusActive) &&
		(kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusActive) &&
		(kbTechGetStatus(cTechChurchTopkapi) == cTechStatusActive) &&
	(kbTechGetStatus(cTechChurchTanzimat) == cTechStatusActive))
	{
		xsDisableSelf();
	}
	
	// If no mosque and no build plan, build one, exit.
	if (kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) < 1)
	{  // No mosque, check for build plan, add one if needed
		churchPlanID = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeChurch);  
		if (churchPlanID < 0)
		{
			//aiEcho(" ");
			//aiEcho("Creating church build plan");
			//aiEcho(" ");
			createSimpleBuildPlan(cUnitTypeChurch, 1, 93, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		}
		return;
	}
	
	// We have a church, continue...
	// Check for each of their techs.  If it's obtainable and there's 
	// no plan, get it.
	
	
	if (kbTechGetStatus(cTechChurchMilletSystem) == cTechStatusObtainable)
	{
		speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMilletSystem);
		if (speedPlanID < 0)
		createSimpleResearchPlan(cTechChurchMilletSystem, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
	}
	
	if (kbTechGetStatus(cTechChurchKopruluViziers) == cTechStatusObtainable)
	{
		speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchKopruluViziers);
		if (speedPlanID < 0)
		createSimpleResearchPlan(cTechChurchKopruluViziers, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
	}     
	
	if (kbTechGetStatus(cTechChurchAbbassidMarket) == cTechStatusObtainable)
	{
		speedPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchAbbassidMarket);
		if (speedPlanID < 0)
		createSimpleResearchPlan(cTechChurchAbbassidMarket, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
	}
	
	if ((kbTechGetStatus(cTechChurchGalataTowerDistrict) == cTechStatusObtainable) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 18))
	{
		capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGalataTowerDistrict);
		if (capPlanID < 0)
		createSimpleResearchPlan(cTechChurchGalataTowerDistrict, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
	}     
	
	if ((kbTechGetStatus(cTechChurchTopkapi) == cTechStatusObtainable) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 33))
	{
		capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTopkapi);
		if (capPlanID < 0)
		createSimpleResearchPlan(cTechChurchTopkapi, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
	}  
	
	if ((kbTechGetStatus(cTechChurchTanzimat) == cTechStatusObtainable) && (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 33))
	{
		capPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTopkapi);
		if (capPlanID < 0)
		createSimpleResearchPlan(cTechChurchTanzimat, getUnit(cUnitTypeChurch),cEconomyEscrowID, 91);
	}
}

//==============================================================================
// tcBuildPlanDelay
/*
	Allows delayed activation of the TC build plan, so that the explorer has 
	uncovered a good bit of the map before a placement is selected.
	
	The int gTCBuildPlanID is used to simplify passing of the build plan ID from
	init().
*/
//==============================================================================

rule tcBuildPlanDelay
inactive
minInterval 2
{
	if (xsGetTime() < gTCStartTime)
	return;     // Do nothing until game time is beyond 10 seconds
	
	aiPlanSetActive(gTCBuildPlanID);
	//aiEcho("Activating TC build plan "+gTCBuildPlanID+".");
	xsDisableSelf();
}

//==============================================================================
/* tcMonitor
	
	Look for a TC, or a build plan for a TC.  If neither, start a new plan
	and have explorer, war chief or monk(s) build one.
*/
//==============================================================================
rule tcMonitor
inactive
minInterval 10
{
	
	//updatedOn 2019/04/04 By ageekhere  
	//---------------------------
	//if (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1 && kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateABQ) == 0) xsDisableSelf(); //this stops overriding the runaway rule
	
	//---------------------------
	if (cvOkToBuild == false)
	return;  // Quit if AI is not allowed to build
	
	if (xsGetTime() < 60000)
	return;  // Give first plan 60 sec to get going
	
	static float nextRadius = 50.0;
	
	int count = kbUnitCount(cMyID, gTownCenter, cUnitStateABQ);
	int plan = -1;
	if (count < 1)
	plan = aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gTownCenter, true);
	
	if ((count > 0) || (plan >= 0))
	return;     // We have a TC or a TC build plan, no more work to do.
	
	if ((count == 0) && (plan >= 0))
	aiPlanDestroy(plan);  // Destroy old plan to keep it from blocking the rule
	
	//aiEcho("Starting a new TC build plan.");
	// Make a town center, pri 100, econ, main base, 1 builder (explorer).
	int buildPlan=aiPlanCreate("TC Build plan explorer", cPlanBuild);
	// What to build
	aiPlanSetVariableInt(buildPlan, cBuildPlanBuildingTypeID, 0, gTownCenter);
	// Priority.
	aiPlanSetDesiredPriority(buildPlan, 100);
	// Mil vs. Econ.
	aiPlanSetMilitary(buildPlan, false);
	aiPlanSetEconomy(buildPlan, true);
	// Escrow.
	aiPlanSetEscrowID(buildPlan, cEconomyEscrowID);
	// Builders.
	int wantVill = 1;
	if(kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1 && kbUnitCount(cMyID, cUnitTypeSettlerWagon, cUnitStateABQ) == 0) wantVill = getUnit(gEconUnit, cMyID, cUnitStateAlive);
	switch(kbGetCiv())
	{
		case cCivXPAztec:
		{
			aiPlanAddUnitType(buildPlan, cUnitTypexpAztecWarchief, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, gEconUnit, wantVill, wantVill, wantVill);
			break;
		}
		case cCivXPIroquois:
		{
			aiPlanAddUnitType(buildPlan, cUnitTypexpIroquoisWarChief, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, gEconUnit, wantVill, wantVill, wantVill);
			break;
		}
		case cCivXPSioux:
		{
			aiPlanAddUnitType(buildPlan, cUnitTypexpLakotaWarchief, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, gEconUnit, wantVill, wantVill, wantVill);
			break;
		}
		case cCivChinese:
		{
			aiPlanAddUnitType(buildPlan, cUnitTypeypMonkChinese, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, gEconUnit, wantVill, wantVill, wantVill);
			break;
		}
		case cCivIndians:
		{
			aiPlanAddUnitType(buildPlan, cUnitTypeypMonkIndian, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, cUnitTypeypMonkIndian2, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, gEconUnit, wantVill, wantVill, wantVill);
			break;
		}
		case cCivJapanese:
		{
			aiPlanAddUnitType(buildPlan, cUnitTypeypMonkJapanese, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, cUnitTypeypMonkJapanese2, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, gEconUnit, wantVill, wantVill, wantVill);
			break;
		}
		default:
		{
			aiPlanAddUnitType(buildPlan, cUnitTypeExplorer, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, cUnitTypeEnvoy, wantVill, wantVill, wantVill);
			aiPlanAddUnitType(buildPlan, gEconUnit, wantVill, wantVill, wantVill);
			break;
		}
	}
	xsEnableRule("townCenterComplete"); //activate town center complete
	kbBaseSetActive(cMyID, gMainBase, true); //set base as active
	
	// Instead of base ID or areas, use a center position and falloff.
	aiPlanSetVariableVector(buildPlan, cBuildPlanCenterPosition, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	aiPlanSetVariableFloat(buildPlan, cBuildPlanCenterPositionDistance, 0, nextRadius);
	nextRadius = nextRadius + 50.0;  // If it fails again, search even farther out.
	
	// Add position influences for trees, gold
	aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitTypeID, 3, true);
	aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitDistance, 3, true);
	aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitValue, 3, true);
	aiPlanSetNumberVariableValues(buildPlan, cBuildPlanInfluenceUnitFalloff, 3, true);
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 0, cUnitTypeWood);
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 0, 30.0);     // 30m range.
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 0, 10.0);        // 10 points per tree
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 1, cUnitTypeMine);
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 1, 40.0);              // 40 meter range for gold
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 1, 100.0);                // 100 points each
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 1, cBPIFalloffLinear);  // Linear slope falloff
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitTypeID, 2, cUnitTypeMine);
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitDistance, 2, 20.0);              // 20 meter inhibition to keep some space
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluenceUnitValue, 2, -100.0);                // -100 points each
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluenceUnitFalloff, 2, cBPIFalloffNone);      // Cliff falloff
	
	// Weight it to prefer the general starting neighborhood
	aiPlanSetVariableVector(buildPlan, cBuildPlanInfluencePosition, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));    // Position inflence for landing position
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionDistance, 0, 200.0);     // 200m range.
	aiPlanSetVariableFloat(buildPlan, cBuildPlanInfluencePositionValue, 0, 300.0);        // 500 points max
	aiPlanSetVariableInt(buildPlan, cBuildPlanInfluencePositionFalloff, 0, cBPIFalloffLinear);  // Linear slope falloff
	
	// Activate
	aiPlanSetActive(buildPlan);
}

//==============================================================================
/* transportArrive()
	
	This function is called when it is time for the AI to come to life.
	
	In Scenario/Campaign games, it means the aiStart object has been placed.
	
	In RM/GC games, it means that the player has all the starting units.  This may
	mean that the initial boat has been unloaded, or the player has started
	with a TC and units, or the player has initial units and a covered wagon
	and must choose a TC location.  
	
	This function activates "initRule" if everything is OK for a start...
*/
//==============================================================================
void transportArrive(int parm=-1) // Event handler
{
	static bool firstTime = true;
	
	if (gSPC == true)
	{
		// Verify aiStart object, return if it isn't there
		if (kbUnitCount(cMyID, cUnitTypeAIStart, cUnitStateAlive) < 1)
		{
			xsEnableRule("waitForStartup");
			return();
		}
	}
	
	if (firstTime == true)
	{  
		// Do init processing
		//aiEcho("The transport has arrived.");
		firstTime = false;
		// No need for it, we're running
		xsDisableRule("transportArriveFailsafe");	
		xsEnableRule("initRule");
	}
}

rule transportArriveFailsafe
inactive
minInterval 30
{	// This rule is normally killed when transportArrive runs the first time.
	transportArrive(-1);		// Call it if we're still running at 30 seconds, make sure the AI starts.
}

rule autoSave
inactive
minInterval 5
{
	int interval = 2; // Interval in minutes
	static int nextTime = 0;
	
	// First, do an auto save game if needed
	//Dont save if we are told not to.
	if (aiGetAutosaveOn() == true)
	{
		int firstCPPlayerID = -1;
		for(i=0; < cNumberPlayers)
		{
			if(kbIsPlayerHuman(i) == true)
            continue;
			
			firstCPPlayerID = i;
		}
		if ( (cMyID == firstCPPlayerID) && (xsGetTime() >= nextTime) && (cvDoAutoSaves == true))
		{  // We're the first CP, it's our job to do the save, and it's time to do it.
			//Create the savegame name.
			static int psCount = 0;
			//Save it.
			if (cvDoAutoSaves == true)
			{
				aiQueueAutoSavegame(psCount);
				//Inc our count.
				psCount=psCount+interval;   // Count roughly matches game time in minutes
				while (psCount < (xsGetTime()/60000) )
				psCount = psCount+interval;    // Handle reloading of save games from machines that had saves off...
				nextTime = psCount * 60 * 1000;
			}
		}
	}
}

//==============================================================================
/* rule ageUpgradeMonitor
	
	This rule decides when it makes sense to work toward an age upgrade.  When that
	time comes, it shifts the normal escrow accounts to zero, sets the upgrade account 
	to 100%, and reallocates everything.  
	
	This causes the upgrade account to take everything it needs until the age upgrade
	is complete.  The escrows are restored in the next age's 'monitor' rule, i.e.
	the age2monitor, age3Monitor, etc.  
*/
//==============================================================================

rule ageUpgradeMonitor
inactive
group tcComplete
minInterval 10
{
	//if(waitingForRevolt == true && kbResourceGet(cResourceFame) < 1000) return; // skip
	int specialAgeTech = -1;   // Used for personality-specific overrides
	int planID = -1;
	int i=0;
	static int lastAgeFrozen = -1;
	//UpdatedOn 2019/03/31 By ageekhere  
	//---------------------------
	/*
		DISABLED FOR NOW
		if (kbGetAgeForPlayer(cMyID) == cAge4 && ourTeamSizeMain > 2 && kbResourceGet(cResourceFame) != 0)
		{ //ai is in IV age and team has over 2 players and fame is not 0
		bool revoltUpgrade = true;
		switch (kbGetCiv())
		{ //check if the civ can revolt
		case cCivBritish:{break;} 
		case cCivDutch:{break;}
		case cCivSpanish:{break;}
		case cCivGermans:{break;}
		case cCivPortuguese:{break;}
		case cCivOttomans:{break;}
		case cCivFrench:{break;}
		case cCivRussians:{break;}
		default:{revoltUpgrade = false;}
		} //end switch
		if(revoltUpgrade == true)
		{		
		for (x = 0; < cNumberPlayers)
		{ //loop through players
		waitingForRevolt = true;
		if (kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(x) && (x != cMyID))
		{ //That are on my team and is not me
		if (kbGetAgeForPlayer(x) < cAge5) 
		{ //There is another ai in age IV do not Revolution
		revoltUpgrade = false;
		waitingForRevolt = false;
		break; //do not revolt go to age 5
		} //end if
		} //end if
		} //end if
		} //end for
		
		if (revoltUpgrade == true && kbResourceGet(cResourceFame) < 1000) return; //Do not age up and wait for fame		
		
		if (revoltUpgrade == true)
		{//Revolution
		revolted = true;
		switch (kbGetCiv())
		{
		case cCivBritish:
		{
		if (aiRandInt(1) == 1)
		{
		createSimpleResearchPlan(cTechXPRevolutionLouverture, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		else
		{
		createSimpleResearchPlan(cTechXPRevolutionAsiaRev, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		break;
		}					
		case cCivDutch:
		{
		if (aiRandInt(1) == 1)
		{
		createSimpleResearchPlan(cTechXPRevolutionBonifacio, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		else
		{
		createSimpleResearchPlan(cTechXPRevolutionAfricaRev, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		break;
		}					
		case cCivSpanish:
		{
		if (aiRandInt(1) == 1)
		{
		createSimpleResearchPlan(cTechXPRevolutionOHiggins, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		else
		{
		createSimpleResearchPlan(cTechXPRevolutionHidalgo, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		break;
		}					
		case cCivGermans:
		{
		if (aiRandInt(1) == 1)
		{
		createSimpleResearchPlan(cTechXPRevolutionSanMartin, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		else
		{
		createSimpleResearchPlan(cTechXPRevolutionCircle, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		break;
		}
		case cCivPortuguese:
		{
		if (aiRandInt(1) == 1)
		{
		createSimpleResearchPlan(cTechXPRevolutionHidalgo, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		else
		{
		createSimpleResearchPlan(cTechXPRevolutionBonifacio, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		break;
		}					
		case cCivOttomans:
		{
		if (aiRandInt(1) == 1)
		{
		createSimpleResearchPlan(cTechXPRevolutionOHiggins, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		else
		{
		createSimpleResearchPlan(cTechXPRevolutionSanMartin, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		break;
		}					
		case cCivFrench:
		{
		if (aiRandInt(1) == 1)
		{
		createSimpleResearchPlan(cTechXPRevolutionOHiggins, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		else
		{
		createSimpleResearchPlan(cTechXPRevolutionSantander, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		break;
		}
		case cCivRussians:
		{
		if (aiRandInt(1) == 1)
		{
		createSimpleResearchPlan(cTechXPRevolutionBlackbeard, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		else
		{
		createSimpleResearchPlan(cTechXPRevolutionSantander, getUnit(gTownCenter), cEconomyEscrowID, 50);
		}
		break;
		}
		
		}
		return;
		}
		
		}
	*/
	//---------------------------
	
	if (kbGetAge() >= cAge5)
	{
		xsDisableSelf();
		return;
	}
	
	if ( kbGetAge() >= cvMaxAge )
	return;  // Don't disable, this var could change later...
    
	int politician = -1;
	
	if ( civIsAsian() == false )
	{
		// Try to research the preferred politician
		if (civIsNative() == false)
		{
			politician = chooseEuropeanPolitician();
		}
		else
		{
			politician = chooseNativeCouncilMember();
		}
		if (politician < 0)     //None specified, need one...
		politician = aiGetPoliticianListByIndex(kbGetAge()+1, 0);   // Pick the first in the list
		
		// Quit if we already have a plan in the works
		if (gAgeUpResearchPlan >= 0)
		{
			if (aiPlanGetState(gAgeUpResearchPlan) >= 0)
			{
				return;  
			}
			else 
			{  // Plan variable is set, but plan is dead.
				aiPlanDestroy(gAgeUpResearchPlan);
				gAgeUpResearchPlan = -1;
				// OK to continue, as we don't have an active plan
			}
		}
		
		// First, see if we can afford an age-up politician
		
		//-- try our personality choice first.
		specialAgeTech = politician;
		if ( specialAgeTech != -1 )
		{
			if ( kbCanAffordTech(specialAgeTech, cEmergencyEscrowID) == true )   
			{  // Can afford or in "escrow-wait" mode...go ahead and make the plan
				if ( (kbTechGetStatus(specialAgeTech) == cTechStatusObtainable) && (gAgeUpResearchPlan < 0) )
				{  // Tech is valid, and we're not yet researching it...
					gAgeUpResearchPlan = createSimpleResearchPlan(specialAgeTech, -1, cEmergencyEscrowID, 99);
					addTechToForecasts(gAgeUpResearchPlan);
					//aiEcho("Creating plan #"+gAgeUpResearchPlan+" to get age upgrade with tech "+kbGetTechName(specialAgeTech));
					
					return;
				}
			}
		}
		
		// No previous choice, let's see if something is available
		if (gAgeUpResearchPlan < 0) // If we're not already waiting for one...
		{
			//-- Walk what is available to us and choose the first one we can afford.
			int count = aiGetPoliticianListCount(kbGetAge()+1);
			for (i=0; < count)
			{
				specialAgeTech = aiGetPoliticianListByIndex(kbGetAge()+1, i);
				if ( kbCanAffordTech(specialAgeTech, cEmergencyEscrowID) == true )   
				{  // Can afford or in "escrow-wait" mode...go ahead and make the plan
					if ( (kbTechGetStatus(specialAgeTech) == cTechStatusObtainable) && (gAgeUpResearchPlan < 0) )
					{		 
						gAgeUpResearchPlan = createSimpleResearchPlan(specialAgeTech, -1, cEmergencyEscrowID, 99);  
						addTechToForecasts(gAgeUpResearchPlan);				
						//aiEcho("Creating plan #"+gAgeUpResearchPlan+" to get age upgrade with tech "+kbGetTechName(specialAgeTech));
						return;
					}
				}
			}
		}
	}
	else 
	{  //We are Asian, time to build a wonder
		// Not at deadline...see if we can afford the preferred politician
		politician = chooseAsianWonder();    // Get the specified wonder
		
		// Quit if we already have a plan in the works
		if (gAgeUpResearchPlan >= 0)
		{
			if (aiPlanGetState(gAgeUpResearchPlan) >= 0)
			{
				return;  
			}
			else 
			{  // Plan variable is set, but plan is dead.
				aiPlanDestroy(gAgeUpResearchPlan);
				gAgeUpResearchPlan = -1;
				// OK to continue, as we don't have an active plan
			}
		}
		
		// First, see if we can afford an age-up politician
		
		//-- try our personality choice first.
		specialAgeTech = politician;
		if ( specialAgeTech != -1 )
		{
			//aiEcho("Wonder to build: "+kbGetProtoUnitName(specialAgeTech));
			//aiEcho("Should we make the plan?: "+gAgeUpResearchPlan);
			if ( gAgeUpResearchPlan < 0 )
			{  // Tech is valid, and we're not yet researching it...
				gAgeUpResearchPlan = createSimpleBuildPlan(specialAgeTech, 1, 100, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 4);
				//aiEcho("<<<<<<<<<<RushBoom + OffenseDefense = "+btRushBoom+" + "+btOffenseDefense+" = "+(btRushBoom+btOffenseDefense));
				//aiEcho("Creating plan #"+gAgeUpResearchPlan+" to get age upgrade with wonder "+kbGetProtoUnitName(specialAgeTech));
				return;
			}
		}
	}
}

//==============================================================================
/* shipGrantedHandler()
	
	
	
	Update 02/10/2004:  New algorithm.
	1)  Clear the list
	2)  Get all the settlers you can.
	3)  If space remains, get the resource you're lowest on.
	
	Update on 04/22/2004:  New algorithm:
	1)  First year, get wood
	2)  Later years, get the resource that gives the largest bucket.
	3)  In a tie, coin > food > wood
	Note, in the early years, the resourceManager will sell food and buy wood as needed
	to drive early housing growth.
	
	Update on 4/27/2004:  Get wood for first TWO years.
	
	Scrapped on 5/12/2004.  Now, settlers have to be imported.  New logic:
	1)  Get settlers always, except:
	2)  If I can afford governor and I don't have him yet, get him
	3)  If I can afford viceroy and I don't have him yet and he's available, get him.
	4)  If settlers aren't available or less than 10 are available, get most needed resource.
	
	August:  Always get an age upgrade if you can.  Otherwise, compute the value for each bucket,
	and choose the best buy.  
	
	November:  Adding multiplier for econ/mil units based on rush/boom emphasis
*/
//==============================================================================

void shipGrantedHandler(int parm=-1) // Event handler
{
	//aiEcho(" ");
	//aiEcho("SHIP GRANTED:");
	
	//if(revolted == true) create deck for revolt
	//{
		//gDefaultDeck = 1;
		//
		//  aiHCDeckActivate(gDefaultDeck);
	//}
	if (kbResourceGet(cResourceShips) < 1.0)
	return;     // Early out if we don't have a ship...no point even checking.
	
	if (agingUp() == true)
	{
		// We're aging up, save this shipment for after it completes
		//aiEcho("We're aging up, delaying this shipment until then.");
		return;
	}
	
	//aiEcho("Choosing contents for next transport");
	
	bool result = false;
	
	bool homeBaseUnderAttack = false;
	if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
	homeBaseUnderAttack = true;      // So don't send resources or settlers....
	
	
	// Adjust for rush or boominess
	float econBias = 0.0; // How much to boost econ units or penalize mil units
	// Flip rushboom sign so boomer is +1 and rusher is -1.  
	econBias = (btRushBoom * -1.0);
	// Set econBias as a percentage boost or penalty for resources and settlers
	econBias = (econBias / 4.0) + 1.0;  // +/- up to 25%
	
 	int bestCard = -1;
	float bestUnitScore = -1.0;
	int unitType = -1;                 // The current unit's ID
	int unitCount = -1;              // How many unit types are available?
	int qtyAvail = -1;               // How many of each are available
	int age = -1;                    // What age do you need to use this card.
	float totalValue = -1.0;         // What is this bucket worth to me?
	bool isMilitaryUnit = false;
	
	
	int totalCards = aiHCDeckGetNumberCards(gDefaultDeck);
	//aiEcho("**** Picking HC card to play");
	for (i=0; < totalCards)
	{
		//-- Skip card if we can't play it.
		if(aiHCDeckCanPlayCard(i) == false)
		continue;
		
		unitType = aiHCDeckGetCardUnitType(gDefaultDeck, i);  // What is this unit?
		qtyAvail = aiHCDeckGetCardUnitCount(gDefaultDeck, i);
		age = aiHCDeckGetCardAgePrereq(gDefaultDeck, i);
		totalValue = 0.0;
		
		// Calculate a value for this unit.  If not found, use its aiCost.
		switch(unitType)
		{
			case cUnitTypeGoldMiner:   // European settlers
			{
				totalValue = 1000;
			}
			
			case cUnitTypeSettler:   // European settlers
			{
				totalValue = 165 * qtyAvail;      // Normal default
				totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
				totalValue = 0.0;
				break;
			}
			case cUnitTypeCoureur:   // French coureurs
			{
				totalValue = 190 * qtyAvail;      // Normal default
				totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
				totalValue = 0.0;
				break;
			}
			case cUnitTypeSettlerWagon:   // German settler wagons
			{
				totalValue = 270 * qtyAvail;      // Normal default
				totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
				totalValue = 0.0;
				break;
			}
			case cUnitTypeSettlerNative:   // Native villagers
			{
				totalValue = 165 * qtyAvail;      // Normal default
				totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
				totalValue = 0.0;
				break;
			}
			case cUnitTypeypSettlerAsian:   // Chinese settlers
			{
				totalValue = 165 * qtyAvail;      // Normal default
				totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
				totalValue = 0.0;
				break;
			}
			case cUnitTypeypSettlerJapanese:   // Japanese settlers
			{
				totalValue = 165 * qtyAvail;      // Normal default
				totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
				totalValue = 0.0;
				break;
			}
			case cUnitTypeSettlerSwedish:   // Swedish settlers
			{
				totalValue = 165 * qtyAvail;      // Normal default
				totalValue = totalValue * econBias; // Boomers prefer this, rushers rather skip.
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				if (getSettlerShortfall() < qtyAvail)  // We have enough settlers
				totalValue = 0.0;
				break;
			}
			case gCaravelUnit:
			{
				// totalValue = 200.0 * qtyAvail;
				totalValue = 0.0;
				break;
			}
			case gGalleonUnit:
			{
				// totalValue = 200.0 * qtyAvail;
				totalValue = 0.0;
				break;
			}
			case gFrigateUnit:
			{
				// totalValue = 200.0 * qtyAvail;
				totalValue = 0.0;
				break;
			}
			case cUnitTypeMonitor:
			{
				// totalValue = 200.0 * qtyAvail;
				totalValue = 0.0;
				break;
			}
			case gFishingUnit:
			{
				if (gFishingPlan < 0)
				totalValue = 0.0;
				else if (aiPlanGetActive(gFishingPlan) == false)
				totalValue = 0.0;                  
			}
			
			case gCoveredWagonUnit:
			{
				totalValue = 0.0;    
				if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 1)
				{
					totalValue = 100000.0;     // Trumps everything
				}
				else
				{
					int tcTarget = 1;
					if (kbGetAge() >= cAge3)
					{
						tcTarget = 2;
						if (cMyCiv == cCivOttomans)
						{
							tcTarget = 3;
						}
					}
					//if (btRushBoom < 0.5)
					//   tcTarget = (-1.0 * btRushBoom) + 2.5;
					if ( (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < tcTarget) && (homeBaseUnderAttack == false) )
					totalValue = 1600.0 * qtyAvail;
				}
				break;
			}
			case cUnitTypeOutpostWagon:
			{
				totalValue = 0.0;    
				if ( (kbUnitCount(cMyID, cUnitTypeOutpostWagon, cUnitStateABQ) + kbUnitCount(cMyID, cUnitTypeOutpost, cUnitStateABQ)) < gNumTowers)
				totalValue = 600.0 * qtyAvail;
				if (homeBaseUnderAttack == true)
				totalValue = 0.0;
				break;
			}
			
			case cUnitTypeBankWagon:
			{
				totalValue = 0.0;    
				if ( (kbUnitCount(cMyID, cUnitTypeBankWagon, cUnitStateABQ) + kbUnitCount(cMyID, cUnitTypeBank, cUnitStateABQ)) < kbGetBuildLimit(cMyID, cUnitTypeBank ) )
				totalValue = 600.0 * qtyAvail;
				if (homeBaseUnderAttack == true)
				totalValue = 0.0;
				break;
			}
			
			case cUnitTypeYPCastleWagon:
			{
				totalValue = 0.0;    
				if ( (kbUnitCount(cMyID, cUnitTypeYPCastleWagon, cUnitStateABQ) + kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateABQ)) < gNumTowers)
				totalValue = 900.0 * qtyAvail;
				if (homeBaseUnderAttack == true)
				totalValue = 0.0;
				break;
			}
			case cUnitTypeFortWagon:
			{
				totalValue = 0.0;
				if ( (cvOkToBuild == true) && (cvOkToBuildForts == true) && (homeBaseUnderAttack == false) )
				totalValue = 10000.0;   // Big, but smaller than TC wagon if there is no TC.
				
				//if ( kbUnitCount(cMyID, cUnitFortFrontier, cUnitStateABQ < kbGetBuildLimit(cMyID, cUnitFortFrontier)) ) totalValue = 0.0;
			}
			case cUnitTypeFactoryWagon:
			{
				totalValue = 0.0;
				if ( (cvOkToBuild == true) && (homeBaseUnderAttack == false) )
				totalValue = 2000.0 * qtyAvail;   // Big, but smaller than TC wagon if there is no TC.
				
				//if ( kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateABQ < kbGetBuildLimit(cMyID, cUnitTypeFactory)) ) totalValue = 0.0;
			}
			case cUnitTypeYPDojoWagon:
			{
				totalValue = 0.0;
				if ( (cvOkToBuild == true) && (homeBaseUnderAttack == false) )
				totalValue = 1500.0;   // Big, but smaller than TC wagon.
			}
			case cUnitTypeCrateofCoin:
			{                                                          
				if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
				qtyAvail = 6;
				else if (age == cAge3)
				qtyAvail = 10;
				else if (age > cAge3)
				qtyAvail = 15;
				totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);  
				if (kbGetAge() == cAge1)
				totalValue = totalValue / 2.0;
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				break;
			}
			case cUnitTypeCrateofCoinLarge:
			{               
				if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
				qtyAvail = 6;
				else if (age == cAge3)
				qtyAvail = 10;
				else if (age > cAge3)
				qtyAvail = 15;
				totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceGold);  
				if (kbGetAge() == cAge1)
				totalValue = totalValue / 2.0;
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				break;
			}
			case cUnitTypeCrateofFood:
			{
				if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
				qtyAvail = 6;
				else if (age == cAge3)
				qtyAvail = 10;
				else if (age > cAge3)
				qtyAvail = 15;
				totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
				if (kbGetAge() == cAge1)   // Increase value for rusher, decrease it for boomer
				totalValue = totalValue / econBias;
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				break;
			}
			case cUnitTypeCrateofFoodLarge:
			{
				if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
				qtyAvail = 6;
				else if (age == cAge3)
				qtyAvail = 10;
				else if (age > cAge3)
				qtyAvail = 15;
				totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceFood);
				if (kbGetAge() == cAge1)   // Increase value for rusher, decrease it for boomer
				totalValue = totalValue / econBias;
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				break;
			}
			case cUnitTypeCrateofWood:
			{
				if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
				qtyAvail = 6;
				else if (age == cAge3)
				qtyAvail = 10;
				else if (age > cAge3)
				qtyAvail = 15;
				totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);  
				if (kbGetAge() == cAge1)
				totalValue = totalValue / 2.0;
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				break;
			}
			case cUnitTypeCrateofWoodLarge:
			{
				if (age == cAge2) // May be a mix of large and small crates, and we can't tell.  Make a guess based on card age.
				qtyAvail = 6;
				else if (age == cAge3)
				qtyAvail = 10;
				else if (age > cAge3)
				qtyAvail = 15;
				totalValue = qtyAvail * 90.0 * kbGetAICostWeight(cResourceWood);  
				if (kbGetAge() == cAge1)
				totalValue = totalValue / 2.0;
				if (homeBaseUnderAttack == true)
				totalValue = 1.0; // Tiny...ANYTHING else is better
				break;
			}
			case cUnitTypeCow:
			{
				totalValue = 80.0 * qtyAvail;
				if (homeBaseUnderAttack == true)
				totalValue = 1.0;
				break;
			}
			case cUnitTypeSheep:
			{
				totalValue = 50.0 * qtyAvail;
				if (homeBaseUnderAttack == true)
				totalValue = 1.0;
				break;
			}
			default:
			{ 
				totalValue = kbGetProtoUnitAICost(unitType) * qtyAvail;
				
				// Handle 'Advanced Trading Post'
				if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdvancedTradingPost") 
				{
					if ((homeBaseUnderAttack == true) || (getUnit(cUnitTypeTradingPost, cMyID, cUnitStateAlive) <= 0) )
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 7000.0;
					}
				}
				
				// Handle 'Royal Decree'
				if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeBritish") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeDutch") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeFrench") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeGerman") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeOttoman") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreePortuguese") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeRussian") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeItalians") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeSwedish") ||
					(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeUS") ||
				(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCRoyalDecreeSpanish"))
				{
					if ((homeBaseUnderAttack == true) || (getUnit(cUnitTypeChurch, cMyID, cUnitStateAlive) <= 0) || (kbGetAge() < cAge3))
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 1510.0;
						if (kbGetCiv() == cCivGermans)
						totalValue = 6010.0; // Necessary to cope with uhlans being included in calculation
					}
				}
				
				// Handle 'Advanced Arsenal'
				if ((kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdvancedArsenal") ||
				(kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCAdvancedArsenalGerman"))
				{
					if ((homeBaseUnderAttack == true) || (getUnit(cUnitTypeArsenal, cMyID, cUnitStateAlive) <= 0) || (kbGetAge() < cAge4))
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 1505.0;
						if (kbGetCiv() == cCivGermans)
						totalValue = 6005.0; // Necessary to cope with uhlans being included in calculation
					}
				}
				
				// Handle 'New Ways' (Iroquois)
				if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPNewWaysIroquois")
				{
					if ((homeBaseUnderAttack == true) || (getUnit(cUnitTypeLonghouse, cMyID, cUnitStateAlive) <= 0) || (kbGetAge() < cAge4))
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 1505.0;
					}
				}
				
				// Handle 'New Ways' (Sioux)
				if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPNewWaysSioux")
				{
					if ((homeBaseUnderAttack == true) || (getUnit(cUnitTypeTeepee, cMyID, cUnitStateAlive) <= 0) || (kbGetAge() < cAge4))
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 1505.0;
					}
				}
				
				// Handle 'Advanced Hot Air Balloon'
				if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "HCXPAdvancedBalloon")
				{
					if ((homeBaseUnderAttack == true) || (cvOkToExplore == false))
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 1500.0;
						if (kbGetCiv() == cCivGermans)
						totalValue = 6000.0; // Necessary to cope with uhlans being included in calculation
					}
				}
				
				// Handle 'Agrarianism' for Indians
				if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCAgrarianism") 
				{
					if ((homeBaseUnderAttack == true) || (kbGetAge() > cAge1) || (kbGetCiv() != cCivIndians) )
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 10000.0;  // For non-SPC Indians this is should be the first card sent in normal games
					}
				}
				
				// Handle '2 Grove Rickshaws'
				if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipGroveWagonIndians2") 
				{
					if (homeBaseUnderAttack == true)
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 660.0 * econBias; // Treated as equivalent to 4 settlers. Boomers prefer this, rushers rather skip.
					}
				}
				
				// Handle 'Shogun Tokugawa'
				if (kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, i)) == "YPHCShipShogunate") 
				{
					if (homeBaseUnderAttack == true)
					{
						totalValue = 1.0;
					}
					else
					{
						totalValue = 1000.0 + (aiRandInt(6) * 300.0);  // Randomized, making sure it beats most Age 3 shipments and can beat Age 4 ones
					}
				}
				
				if ( (totalValue < 1.0) && (age >= cAge1) )
				{  // Set a min value based on age
					switch(age)
					{
						case cAge1:
						{
							totalValue = 200.0;
							break;
						}
						case cAge2:
						{
							totalValue = 500.0;
							break;
						}
						case cAge3:
						{
							totalValue = 900.0;
							break;
						}
						case cAge4:
						{
							totalValue = 1300.0;
							break;
						}
						case cAge5:
						{
							totalValue = 1300.0;
							break;
						}
						
					}
				}
				break;
			}
		}
		
		// Adjust scores for military units
		isMilitaryUnit = kbProtoUnitIsType(cMyID, unitType, cUnitTypeLogicalTypeLandMilitary);
		if ( (kbGetAge() < cAge3) && ( isMilitaryUnit == true) )
		totalValue = totalValue / econBias;  // Adjust value up for pure rusher, down for pure boomer
		if ( (kbGetAge() < cAge2) && ( isMilitaryUnit == true) )
		totalValue = 0.0; // No military units before age 2.
		if ( unitType == kbUnitPickGetResult( gLandUnitPicker, 0) )
		totalValue = totalValue * 1.5;   // It's what we're trying to train
		
		// Adjust score for mercenaries if not enough coin is available.
		if ( (age == cAge2) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeMercenary) == true) && (kbResourceGet(cResourceGold) < 500) )
		totalValue = 1.0;   // No Age 2 mercenaries if less than 500 coin is available.
		if ( (age == cAge3) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeMercenary) == true) && (kbResourceGet(cResourceGold) < 1500) )
		totalValue = 1.0;   // No Age 3 mercenaries if less than 1500 coin is available.
		if ( (age == cAge4) && (kbProtoUnitIsType(cMyID, unitType, cUnitTypeMercenary) == true) && (kbResourceGet(cResourceGold) < 2500) )
		totalValue = 1.0;   // No Age 4 mercenaries if less than 2500 coin is available.
		
		if (totalValue > bestUnitScore)
		{
			bestUnitScore = totalValue;
			bestCard = i;
		}
	}
	
	
	if (bestCard >= 0 )
	{
		/*
			if (aiHCDeckGetCardUnitCount(gDefaultDeck, bestCard) > 0)
			{
			aiEcho("  Choosing card "+bestCard+", "+aiHCDeckGetCardUnitCount(gDefaultDeck, bestCard)+" "+kbGetUnitTypeName(aiHCDeckGetCardUnitType(gDefaultDeck, bestCard)));
			}
			else
			{
			aiEcho("  Choosing card "+bestCard+", "+kbGetTechName(aiHCDeckGetCardTechID(gDefaultDeck, bestCard)));
			}
		*/
		//createSimpleTrainPlan(bestUnitType, 1, cRootEscrowID, -1, 1, true);
		aiHCDeckPlayCard(bestCard);
	}
}

//==============================================================================
// extraShipMonitor
// Checks for shipments (not just for extra ones!) and calls appropriate handler
//==============================================================================
rule extraShipMonitor
inactive
group tcComplete
minInterval 20
{
	if (kbResourceGet(cResourceShips) > 0)
	{
		shipGrantedHandler();   // normal shipment handler
	}
}

void getHCTech(string name="", int techID=-1, int pri=50)
{  // Make a simple plan to research a HC tech.
	int planID = aiPlanCreate(name, cPlanResearch);
	aiPlanSetVariableInt(planID, cResearchPlanTechID, 0, techID);
	aiPlanSetEscrowID(planID, cRootEscrowID);
	aiPlanSetDesiredPriority(planID, pri);
	aiPlanSetActive(planID);
}

//==============================================================================
// ShouldIResign
//==============================================================================
//==============================================================================
// ShouldIResign
//==============================================================================
rule ShouldIResign
minInterval 7
active
{
	static bool hadHumanAlly = false;
	
	if (gSPC == true)
	{
		xsDisableSelf();
		return;
	}
	
	if (cvOkToResign == false)
	{
		return;     // Early out if we're not allowed to think about this.
	}
	
	// Don't resign if you have a human ally that's still in the game
	int i = 0;
	bool humanAlly = false;    // Set true if we have a surviving human ally.
	int humanAllyID = -1;
	bool complained = false;   // Set flag true if I've already whined to my ally.
	bool wasHumanInGame = false;  // Set true if any human players were in the game
	bool isHumanInGame = false;   // Set true if a human survives.  If one existed but none survive, resign.
	
	// Look for humans
	for (i=1; <=cNumberPlayers)
	{
		if ( kbIsPlayerHuman(i) == true)
		{
			wasHumanInGame = true;
			if ( kbHasPlayerLost(i) == false )
            isHumanInGame = true;
		}
		if ( (kbIsPlayerAlly(i) == true) && (kbHasPlayerLost(i) == false) && (kbIsPlayerHuman(i) == true) )
		{
			humanAlly = true; // Don't return just yet, let's see if we should chat.
			hadHumanAlly = true; // Set flag to indicate that we once had a human ally.
			humanAllyID = i;  // Player ID of lowest-numbered surviving human ally.
		}
	}
	
	//   if ( (hadHumanAlly == true) && (humanAlly == false) )
	if ( (wasHumanInGame == true) && (isHumanInGame == false) ) // Resign if my human allies have quit.
	{
		//aiResign(); // If there are no humans left, and this wasn't a bot battle from the start, quit.
		aiEcho("Resigning because I had a human ally, and he's gone...");
		aiResign(); // I had a human ally or allies, but do not any more.  Our team loses.
		return;  // Probably not necessary, but whatever...
	}
	// Check for MP with human allies gone.  This trumps the OkToResign setting, below.
	if ( (aiIsMultiplayer() == true) && (wasHumanInGame == true) && (isHumanInGame == false) )   
	{  // In a multiplayer game...we had a human ally earlier, but none remain.  Resign immediately
		aiEcho("Resign because my human ally is no longer in the game.");
		aiResign();    // Don't ask, just quit.
		xsEnableRule("resignRetry");
		xsDisableSelf();
		return;
	}
	
	//Don't resign too soon.
	if (xsGetTime() < 300000)     // 600K = 10 min
	return;
	
	//Don't resign if we have over 30 active pop slots.
	if (kbGetPop() >= 30)
	return;
	
	// Resign if the known enemy pop is > 10x mine
	
	int enemyPopTotal = 0.0;
	int enemyCount = 0;
	int myPopTotal = 0.0;
	
	for (i=1; < cNumberPlayers)
	{
		if (kbHasPlayerLost(i) == false)
		{
			if( i == cMyID )
            myPopTotal = myPopTotal + kbUnitCount(i, cUnitTypeUnit, cUnitStateAlive);
			if( (kbIsPlayerEnemy(i) == true) && (kbHasPlayerLost(i) == false) )
			{
				enemyPopTotal = enemyPopTotal + kbUnitCount(i, cUnitTypeUnit, cUnitStateAlive);
				enemyCount = enemyCount + 1;
			}
		}
	}
	
	if (enemyCount < 1)
	enemyCount = 1;      // Avoid div 0
	
	float enemyRatio = (enemyPopTotal/enemyCount) / myPopTotal;
	
	if ( enemyRatio > 10 )       // My pop is 1/10 the average known pop of enemies
	{
		if ( humanAlly == false )
		{
			aiEcho("Resign at 10:1 pop: EP Total("+enemyPopTotal+"), MP Total("+myPopTotal+")");
			aiAttemptResign(cAICommPromptToEnemyMayIResign);
			xsEnableRule("resignRetry");
			xsDisableSelf();
			return;
		}
		if ( (humanAlly == true) && (complained == false) )
		{  // Whine to your partner
			sendStatement(humanAllyID, cAICommPromptToAllyImReadyToQuit);
			xsEnableRule("resignRetry");
			xsDisableSelf();
			complained = true;
		}
	}
	if ( (enemyRatio > 4) &&                    // My pop is 1/4 the average known pop of enemies, and 
        (kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1 ) &&     // I have no TC or covered wagon
	(kbUnitCount(cMyID, cUnitTypeCoveredWagon, cUnitStateAlive) < 1 ))
	{
		if (humanAlly == false)
		{
			aiEcho("Resign with no 4:1 pop and no TC: EP Total("+enemyPopTotal+"), MP Total("+myPopTotal+")");     
			//sendStatement(aiGetMostHatedPlayerID(), cAICommPromptAIResignActiveEnemies, -1);
			aiAttemptResign(cAICommPromptToEnemyMayIResign);
			//breakpoint;
			xsEnableRule("resignRetry");
			xsDisableSelf();
			return;
		}
	}
}
/*
	rule ShouldIResign
	
	minInterval 10
	active
	{
	static bool hadHumanAlly = false;
	
	if (gSPC == true)
	{
	xsDisableSelf();
	return;
	}
	
	if (cvOkToResign == false)
	{
	return;     // Early out if we're not allowed to think about this.
	}
	
	// Don't resign if you have a human ally that's still in the game
	int i = 0;
	bool humanAlly = false;    // Set true if we have a surviving human ally.
	int humanAllyID = -1;
	bool complained = false;   // Set flag true if I've already whined to my ally.
	bool wasHumanInGame = false;  // Set true if any human players were in the game
	bool isHumanInGame = false;   // Set true if a human survives.  If one existed but none survive, resign.
	
	// Look for humans
	for (i=1; <=cNumberPlayers)
	{
	if ( kbIsPlayerHuman(i) == true)
	{
	wasHumanInGame = true;
	if ( kbHasPlayerLost(i) == false )
	isHumanInGame = true;
	}
	if ( (kbIsPlayerAlly(i) == true) && (kbHasPlayerLost(i) == false) && (kbIsPlayerHuman(i) == true) )
	{
	humanAlly = true; // Don't return just yet, let's see if we should chat.
	hadHumanAlly = true; // Set flag to indicate that we once had a human ally.
	humanAllyID = i;  // Player ID of lowest-numbered surviving human ally.
	}
	}
	
	//   if ( (hadHumanAlly == true) && (humanAlly == false) )
	if ( (wasHumanInGame == true) && (isHumanInGame == false) ) // Resign if my human allies have quit.
	{
	//aiResign(); // If there are no humans left, and this wasn't a bot battle from the start, quit.
	//aiEcho("Resigning because I had a human ally, and he's gone...");
	aiAttemptResign(cAICommPromptToEnemyMayIResign);//aiResign(); // I had a human ally or allies, but do not any more.  Our team loses.
	xsDisableSelf();
	return;  // Probably not necessary, but whatever...
	}
	// Check for MP with human allies gone.  This trumps the OkToResign setting, below.
	if ( (aiIsMultiplayer() == true) && (wasHumanInGame == true) && (isHumanInGame == false) )   
	{  // In a multiplayer game...we had a human ally earlier, but none remain.  Resign immediately
	//aiEcho("Resign because my human ally is no longer in the game.");
	aiAttemptResign(cAICommPromptToEnemyMayIResign); //aiResign();    // Don't ask, just quit.
	xsEnableRule("resignRetry");
	xsDisableSelf();
	return;
	}
	//ageekhere
	//only resign when there are no tc left in whole team
	bool resignNow = true;
	
	bool aiTeam = false; 
	if(hadHumanAlly == false)
	{
	aiTeam = true;
	for (t = 0; < cNumberPlayers +1)
	{ //loop through players
	if (kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(t))
	{ //That are on my team
	if (kbUnitCount(t, gTownCenter, cUnitStateAlive) > 0)
	{
	resignNow = false;
	}
	
	}
	} 
	}
	else
	{
	resignNow = false;
	}
	
	if(resignNow == true && kbGetAge() > cAge1)
	{
	aiAttemptResign(cAICommPromptToEnemyMayIResign);//aiResign();
	xsDisableSelf();
	}
	if(aiTeam == true)return;
	
	
	//Don't resign too soon.
	if (xsGetTime() < 600000)     // 600K = 10 min
	return;
	
	//Don't resign if we have over 30 active pop slots.
	//if (kbGetPop() >= 30)
	// return;
	
	// Resign if the known enemy pop is > 10x mine
	
	int enemyPopTotal = 0.0;
	int enemyCount = 0;
	int myPopTotal = 0.0;
	
	for (i=1; < cNumberPlayers)
	{
	if (kbHasPlayerLost(i) == false)
	{
	if( i == cMyID )
	myPopTotal = myPopTotal + kbUnitCount(i, cUnitTypeUnit, cUnitStateAlive);
	if( (kbIsPlayerEnemy(i) == true) && (kbHasPlayerLost(i) == false) )
	{
	enemyPopTotal = enemyPopTotal + kbUnitCount(i, cUnitTypeUnit, cUnitStateAlive);
	enemyCount = enemyCount + 1;
	}
	}
	}
	
	if (enemyCount < 1)
	enemyCount = 1;      // Avoid div 0
	
	float enemyRatio = (enemyPopTotal/enemyCount) / myPopTotal;
	
	if ( enemyRatio > 10 )       // My pop is 1/10 the average known pop of enemies
	{
	if ( humanAlly == false )
	{
	//aiEcho("Resign at 10:1 pop: EP Total("+enemyPopTotal+"), MP Total("+myPopTotal+")");
	aiAttemptResign(cAICommPromptToEnemyMayIResign);
	xsEnableRule("resignRetry");
	xsDisableSelf();
	return;
	}
	if ( (humanAlly == true) && (complained == false) )
	{  // Whine to your partner
	sendStatement(humanAllyID, cAICommPromptToAllyImReadyToQuit);
	xsEnableRule("resignRetry");
	xsDisableSelf();
	complained = true;
	}
	}
	if ( (enemyRatio > 4) &&                    // My pop is 1/4 the average known pop of enemies, and 
	(kbUnitCount(cMyID, gTownCenter, cUnitStateABQ) < 1 ) &&     // I have no TC or covered wagon
	(kbUnitCount(cMyID, cUnitTypeCoveredWagon, cUnitStateAlive) < 1 ))
	{
	if (humanAlly == false)
	{
	//aiEcho("Resign with no 4:1 pop and no TC: EP Total("+enemyPopTotal+"), MP Total("+myPopTotal+")");     
	//sendStatement(aiGetMostHatedPlayerID(), cAICommPromptAIResignActiveEnemies, -1);
	aiAttemptResign(cAICommPromptToEnemyMayIResign);
	//breakpoint;
	xsEnableRule("resignRetry");
	xsDisableSelf();
	return;
	}
	}
	}
*/


rule resignRetry
inactive
minInterval 240
{
	xsEnableRule("ShouldIResign");
	xsDisableSelf();
}

//==============================================================================
// resignHandler
//==============================================================================
/*
	void resignHandler(int result =-1)
	{
	//aiEcho("***************** Resign handler running with result "+result);
	
	if (result == 0)
	{
	
	xsEnableRule("resignRetry");
	return;
	}
	//aiEcho("Resign handler returned "+result);
	
	aiResign();
	return;
	}
*/

void resignHandler(int result =-1)
{
	aiEcho("***************** Resign handler running with result "+result);
	if (result == 0)
	{
		xsEnableRule("resignRetry");
		return;
	}
	aiEcho("Resign handler returned "+result);
	
	int sendTo = 0;
	int lowestScore = 99999999;
	for (x = 0; < cNumberPlayers)
	{ //loop through players
		if (kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(x) && (x != cMyID) && kbIsPlayerHuman(x))
		{ //That are on my team and is not me and is a human
			if (lowestScore > aiGetScore(x))
			{
				lowestScore = aiGetScore(x);
				sendTo = x;
			}
		}
	}
	if(sendTo == 0)
	{
		for (t = 0; < cNumberPlayers)
		{ //loop through players
			if (kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(t) && (t != cMyID))
			{ //That are on my team and is not me and is a human
				if (lowestScore > aiGetScore(t))
				{
					lowestScore = aiGetScore(t);
					sendTo = t;
				}
			}
		}
	}
	
	aiTribute(sendTo, cResourceFood, kbResourceGet(cResourceFood));
	aiTribute(sendTo, cResourceWood, kbResourceGet(cResourceWood));
	aiTribute(sendTo, cResourceGold, kbResourceGet(cResourceGold));
	
	aiResign();
	return;
}

int createTechProgression(int techID = -1, int escrowID = -1, int pri = 50)
{
	int planID = -1;
	if ((techID < 0) || (escrowID < 0))
	return(-1);
	
	planID = aiPlanCreate("Tech Progression "+techID, cPlanProgression);
	if (planID < 0)
	return(-1);
	
	aiPlanSetVariableInt(planID, cProgressionPlanGoalTechID, 0, techID);
	aiPlanSetDesiredPriority(planID, pri);
	aiPlanSetEscrowID(planID, escrowID);
	aiPlanSetBaseID(planID, kbBaseGetMainID(cMyID));
	aiPlanSetActive(planID);
	
	return(planID);
}

rule bigTechManager
group tcComplete
inactive
minInterval 120
{
	if (civIsNative() == false)
	{
		xsDisableSelf();
		return;
	}
	if (xsGetTime() < 28*60*1000)
	return;  // Wait until 28 minutes
	
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 1)
	return;
	
	//aiEcho(" ");
	//aiEcho("#### Starting 'big tech' research plans. ####");
	//aiEcho(" ");
	
	if (cMyCiv == cCivXPAztec)
	{
		createSimpleResearchPlan(cTechBigFarmCinteotl, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigFirepitFounder, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigPlantationTezcatlipoca, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigWarHutBarometz, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigNoblesHutWarSong, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigHouseCoatlicue, -1, cMilitaryEscrowID, 80);
	}
	else if (cMyCiv == cCivXPIroquois)
	{
		createSimpleResearchPlan(cTechBigFarmStrawberry, -1, cEconomyEscrowID, 80);
		createSimpleResearchPlan(cTechBigPlantationMapleFestival, -1, cEconomyEscrowID, 80);
		createSimpleResearchPlan(cTechBigLonghouseWoodlandDwellers, -1, cEconomyEscrowID, 80);
		createSimpleResearchPlan(cTechBigWarHutLacrosse, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigSiegeshopSiegeDrill, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigCorralHorseSecrets, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigDockRawhideCovers, -1, cMilitaryEscrowID, 80);
	}
	else if (cMyCiv == cCivXPSioux)
	{
		createSimpleResearchPlan(cTechBigCorralBonepipeArmor, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigWarHutWarDrums, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigPlantationGunTrade, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigFarmHorsemanship, -1, cMilitaryEscrowID, 80);
		createSimpleResearchPlan(cTechBigDockFlamingArrows, -1, cMilitaryEscrowID, 80);
	}
	
	xsDisableSelf();
}

//==============================================================================
// rule lateInAge
//==============================================================================
extern int gLateInAgePlayerID = -1;
extern int gLateInAgeAge = -1;
rule lateInAge
minInterval 120
inactive
{
	// This rule is used to taunt a player who is behind in the age race, but only if
	// he is still in the previous age some time (see minInterval) after the other
	// players have all advanced.  Before activating this rule, the calling function
	// (ageUpHandler) must set the global variables for playerID and age, 
	// gLateInAgePlayerID and gLateInAgeAge.  When the rule finally fires minInterval 
	// seconds later, it checks to see if that player is still behind, and taunts accordingly.
	if (gLateInAgePlayerID < 0)
	return;
	
	if (kbGetAgeForPlayer(gLateInAgePlayerID) == gLateInAgeAge)
	{
		if ( gLateInAgeAge == cAge1 )
		{
			if ( (kbIsPlayerAlly(gLateInAgePlayerID) == true) && (gLateInAgePlayerID != cMyID) )
            sendStatement(gLateInAgePlayerID, cAICommPromptToAllyHeIsAge1Late); 
			if ( (kbIsPlayerEnemy(gLateInAgePlayerID) == true ) )
            sendStatement(gLateInAgePlayerID, cAICommPromptToEnemyHeIsAge1Late);
		}
		else
		{
			if ( (kbIsPlayerAlly(gLateInAgePlayerID) == true) && (gLateInAgePlayerID != cMyID) )
            sendStatement(gLateInAgePlayerID, cAICommPromptToAllyHeIsStillAgeBehind); 
			if ( (kbIsPlayerEnemy(gLateInAgePlayerID) == true ) )
            sendStatement(gLateInAgePlayerID, cAICommPromptToEnemyHeIsStillAgeBehind);
		}
	}
	gLateInAgePlayerID = -1;
	gLateInAgeAge = -1;
	xsDisableSelf();
}


//==============================================================================
// AgeUpHandler
//==============================================================================
void ageUpHandler(int playerID = -1) 
{
	
	int age = kbGetAgeForPlayer(playerID);
	bool firstToAge = true;      // Set true if this player is the first to reach that age, false otherwise
	bool lastToAge = true;         // Set true if this player is the last to reach this age, false otherwise
	int index = 0;
	int slowestPlayer = -1;
	int lowestAge = 100000;
	int lowestCount = 0;          // How many players are still in the lowest age?
	
	//aiEcho("AGE HANDLER:  Player "+playerID+" is now in age "+age);
	
	for (index = 1; < cNumberPlayers)
	{
		if (index != playerID)
		{
			// See if this player is already at the age playerID just reached.
			if (kbGetAgeForPlayer(index) >= age)
            firstToAge = false;  // playerID isn't the first
			if (kbGetAgeForPlayer(index) < age)
            lastToAge = false;   // Someone is still behind playerID.
		}
		if (kbGetAgeForPlayer(index) < lowestAge)
		{
			lowestAge = kbGetAgeForPlayer(index);
			slowestPlayer = index;
			lowestCount = 1;
		}
		else
		{
			if (kbGetAgeForPlayer(index) == lowestAge)
            lowestCount = lowestCount + 1;
		}
	}
	
	
	if ( (firstToAge == true) && (age == cAge2) )
	{  // This player was first to age 2
		if ( (kbIsPlayerAlly(playerID) == true) && (playerID != cMyID) )
		sendStatement(playerID, cAICommPromptToAllyHeReachesAge2First); 
		if ( (kbIsPlayerEnemy(playerID) == true ) )
		sendStatement(playerID, cAICommPromptToEnemyHeReachesAge2First);
		return();
	}
	if ( (lastToAge == true) && (age == cAge2) )
	{  // This player was last to age 2
		if ( (kbIsPlayerAlly(playerID) == true) && (playerID != cMyID) )
		sendStatement(playerID, cAICommPromptToAllyHeReachesAge2Last); 
		if ( (kbIsPlayerEnemy(playerID) == true ) )
		sendStatement(playerID, cAICommPromptToEnemyHeReachesAge2Last);
		return();
	}
	
	// Check to see if there is a lone player that is behind everyone else
	if ( (lowestCount == 1) && (slowestPlayer != cMyID) )
	{
		// This player is slowest, nobody else is still in that age, and it's not me,
		// so set the globals and activate the rule...unless it's already active.
		// This will cause a chat to fire later (currently 120 sec mininterval) if
		// this player is still lagging technologically.
		if (gLateInAgePlayerID < 0)
		{
			if (xsIsRuleEnabled("lateInAge") == false)
			{
				gLateInAgePlayerID = slowestPlayer;
				gLateInAgeAge = lowestAge;
				xsEnableRule("lateInAge");
				return();
			}
		}
	}
	
	// Check to see if ally advanced before me
	if ( (kbIsPlayerAlly(playerID) == true) && (age > kbGetAgeForPlayer(cMyID)) )
	{
		sendStatement(playerID, cAICommPromptToAllyHeAdvancesAhead);   
		return();
	}
	
	// Check to see if ally advanced before me
	if ( (kbIsPlayerEnemy(playerID) == true) && (age > kbGetAgeForPlayer(cMyID)) )
	{
		sendStatement(playerID, cAICommPromptToEnemyHeAdvancesAhead);   
		return();
	}      
	
}


/*
	getNuggetChatID()
	
	Called from the nugget event handler.  Given the player ID, determine what
	type of nugget was just claimed, and return a specific appropriate chat ID, if any.
	
	If none apply, return the general 'got nugget' chat ID.
*/
int getNuggetChatID(int playerID = -1)
{
	int retVal = cAICommPromptToEnemyWhenHeGathersNugget;
	int type = aiGetLastCollectedNuggetType(playerID);
	int effect = aiGetLastCollectedNuggetEffect(playerID);
	
	switch(type)
	{
		case cNuggetTypeAdjustResource:
		{
			switch(effect)
			{
				case cResourceGold:
				{
					retVal = cAICommPromptToEnemyWhenHeGathersNuggetCoin;
					break;
				}
				case cResourceFood:
				{
					retVal = cAICommPromptToEnemyWhenHeGathersNuggetFood;
					break;
				}
				case cResourceWood:
				{
					retVal = cAICommPromptToEnemyWhenHeGathersNuggetWood;
					break;
				}
			}
			break;
		}
		case cNuggetTypeSpawnUnit:
		{
			if ( (effect == cUnitTypeNatMedicineMan) || (effect == cUnitTypeNatClubman) || (effect == cUnitTypeNatRifleman)
				|| (effect == cUnitTypeNatHuaminca) || (effect == cUnitTypeNatTomahawk) || (effect == cUnitTypeNativeScout)
			|| (effect == cUnitTypeNatEagleWarrior) )
			{
				retVal = cAICommPromptToEnemyWhenHeGathersNuggetNatives;
			}
			if ( (effect == cUnitTypeSettler) || (effect == cUnitTypeCoureur) || (effect == cUnitTypeSettlerNative) || (effect == cUnitTypeSettlerSwedish) || (effect == cUnitTypeypSettlerAsian) || (effect == cUnitTypeypSettlerIndian) )
            retVal = cAICommPromptToEnemyWhenHeGathersNuggetSettlers;
			break;
		}
		case cNuggetTypeGiveLOS:
		{
			break;
		}
		case cNuggetTypeAdjustSpeed:
		{
			break;
		}
		case cNuggetTypeAdjustHP:
		{
			break;
		}
		case cNuggetTypeConvertUnit:
		{
			if ( (effect == cUnitTypeNatMedicineMan) || (effect == cUnitTypeNatClubman) || (effect == cUnitTypeNatRifleman)
				|| (effect == cUnitTypeNatHuaminca) || (effect == cUnitTypeNatTomahawk) || (effect == cUnitTypeNativeScout)
			|| (effect == cUnitTypeNatEagleWarrior) )
			{
				retVal = cAICommPromptToEnemyWhenHeGathersNuggetNatives;
			}
			if ( (effect == cUnitTypeSettler) || (effect == cUnitTypeCoureur) || (effect == cUnitTypeSettlerNative) || (effect == cUnitTypeSettlerSwedish) || (effect == cUnitTypeypSettlerAsian) || (effect == cUnitTypeypSettlerIndian) )
            retVal = cAICommPromptToEnemyWhenHeGathersNuggetSettlers;
			break;
		}
	}
	
	
	return(retVal);
}

//==============================================================================
// nuggetHandler
//==============================================================================
void nuggetHandler(int playerID =-1)
{
	if (kbGetAge() > cAge2)
	return;  // Do not send these chats (or even bother keeping count) after age 2 ends.
	//aiEcho("***************** Nugget handler running with playerID"+playerID);   
	static int nuggetCounts = -1;    // Array handle.  nuggetCounts[i] will track how many nuggets each player has claimed
	static int totalNuggets = 0;
	const int  cNuggetRange = 100;   // Nuggets within this many meters of a TC are "owned".
	int defaultChatID = getNuggetChatID(playerID);
	
	if ( (playerID < 1) || (playerID > cNumberPlayers) )
	return;
	
	// Initialize the array if we haven't done this before.
	if (nuggetCounts < 0)
	{
		nuggetCounts = xsArrayCreateInt(cNumberPlayers, 0, "Nugget Counts");
	}
	
	// Score this nugget
	totalNuggets = totalNuggets + 1;
	xsArraySetInt(nuggetCounts, playerID, xsArrayGetInt(nuggetCounts, playerID) + 1);
	
	// Check to see if one of the special-case chats might be appropriate.
	// If so, use it, otherwise, fall through to the generic ones.
	// First, some bookkeeping
	int i = 0;
	int count = 0;
	int lowestPlayer = -1;
	int lowestCount = 100000;  // Insanely high start value, first pass will reset it.
	int totalCount = 0;
	int averageCount = 0;
	int highestPlayer = -1;
	int highestCount = 0;
	for (i=1; <cNumberPlayers)
	{
		count = xsArrayGetInt(nuggetCounts, i,);  // How many nuggets has player i gathered?
		if ( count < lowestCount )
		{
			lowestCount = count;
			lowestPlayer = i;
		}
		if ( count > highestCount )
		{
			highestCount = count;
			highestPlayer = i;
		}
		totalCount = totalCount + count; 
	}
	averageCount = totalCount / (cNumberPlayers - 1);
	
	if (totalCount == 1) // This is the first nugget in the game
	{
		if(playerID != cMyID)
		{
			if(kbIsPlayerAlly(playerID) == true)
			{
				sendStatement(playerID, cAICommPromptToAllyWhenHeGathersFirstNugget); 
				return;
			}
			else
			{
				sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersFirstNugget);
				return;
			}
		}
	}
	
	int playersCount = 0;
	int myCount = 0;
	myCount = xsArrayGetInt(nuggetCounts, cMyID);
	playersCount = xsArrayGetInt(nuggetCounts, playerID);
	// Check if this player is way ahead of me, i.e. 2x my total and ahead by at least 2
	if ( ((playersCount - myCount) >= 2) && (playersCount >= (myCount*2)) )
	{
		if(kbIsPlayerAlly(playerID) == true)
		{
			sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetHeIsAhead); 
			return;
		}
		else
		{
			sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersNuggetHeIsAhead);
			return;
		}
	}
	
	// Check if I'm way ahead of any other players
	int player = 0;      // Loop counter...who might I send a message to
	bool messageSent = false;
	if (playerID == cMyID)
	{
		for (player = 1; <cNumberPlayers)
		{
			playersCount = xsArrayGetInt(nuggetCounts, player);
			if ( ((myCount - playersCount) >= 2) && (myCount >= (playersCount*2)) )
			{
				if(kbIsPlayerAlly(player) == true)
				{
					sendStatement(player, cAICommPromptToAllyWhenIGatherNuggetIAmAhead); 
					messageSent = true;
				}
				else
				{
					sendStatement(player, cAICommPromptToEnemyWhenIGatherNuggetIAmAhead);
					messageSent = true;
				}
			}  
		}
	}
	if (messageSent == true)
	return;
	
	// Check to see if the nugget was gathered near a main base.  
	// For now, check playerID's explorer location, assume nugget was gathered there.
	// Later, we may add location info to the event handler.
	vector explorerPos = cInvalidVector;
	int explorerID = -1;
	int tcID = -1;
	
	explorerID = getUnit(cUnitTypeExplorer, playerID, cUnitStateAlive);
	if (explorerID < 0)
	explorerID = getUnit(cUnitTypexpAztecWarchief, playerID, cUnitStateAlive);
	if (explorerID < 0)
	explorerID = getUnit(cUnitTypexpIroquoisWarChief, playerID, cUnitStateAlive);
	if (explorerID < 0)
	explorerID = getUnit(cUnitTypexpLakotaWarchief, playerID, cUnitStateAlive);
	if (explorerID < 0)
	explorerID = getUnit(cUnitTypeypMonkChinese, playerID, cUnitStateAlive);
	if (explorerID < 0)
	explorerID = getUnit(cUnitTypeypMonkIndian, playerID, cUnitStateAlive);
	if (explorerID < 0)
	explorerID = getUnit(cUnitTypeypMonkIndian2, playerID, cUnitStateAlive);
	if (explorerID < 0)
	explorerID = getUnit(cUnitTypeypMonkJapanese, playerID, cUnitStateAlive);
	if (explorerID < 0)
	explorerID = getUnit(cUnitTypeypMonkJapanese2, playerID, cUnitStateAlive);
	if (explorerID >= 0) // We know of an explorer, war chief or Asian monk for this player
	{
		if (kbUnitVisible(explorerID) == true)
		{  // And we can see him.
			explorerPos = kbUnitGetPosition(explorerID);
			if (playerID == cMyID)
			{  // I gathered the nugget
				// Get nearest ally TC distance
				tcID = getUnitByLocation(gTownCenter, cPlayerRelationAlly, cUnitStateAlive, explorerPos, cNuggetRange);
				if ( (tcID > 0) && (kbUnitGetPlayerID(tcID) != cMyID) )
				{  // A TC is near, owned by an ally, and it's not mine...
					sendStatement(kbUnitGetPlayerID(tcID), cAICommPromptToAllyWhenIGatherNuggetHisBase); // I got a nugget near his TC
					return;
				}
				// Get nearest enemy TC distance
				tcID = getUnitByLocation(gTownCenter, cPlayerRelationEnemy, cUnitStateAlive, explorerPos, cNuggetRange);
				if ( tcID > 0 )
				{  // A TC is near, owned by an enemy...
					sendStatement(kbUnitGetPlayerID(tcID), cAICommPromptToEnemyWhenIGatherNuggetHisBase); // I got a nugget near his TC
					return;
				}
			}
			else 
			{
				if (kbIsPlayerAlly(playerID) == true)
				{  // An ally has found a nugget, see if it's close to my TC
					tcID = getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, explorerPos, cNuggetRange);   
					if (tcID > 0)
					{  // That jerk took my nugget!
						sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetMyBase); // He got one in my zone
						return;
					}
				}
				else 
				{  // An enemy has found a nugget, see if it's in my zone
					tcID = getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, explorerPos, cNuggetRange);   
					if (tcID > 0)
					{  // That jerk took my nugget!
						sendStatement(playerID, cAICommPromptToEnemyWhenHeGathersNuggetMyBase); // He got one in my zone
						return;      
					}
				}
			}     // if me else
		}  // If explorer is visible to me
	}  // If explorer known
	
	// No special events fired, so go with generic messages
	// defaultChatID has the appropriate chat if an enemy gathered the nugget...send it.
	// Otherwise, convert to the appropriate case.
	if(playerID != cMyID)
	{
		if(kbIsPlayerEnemy(playerID) == true)
		{
			sendStatement(playerID, defaultChatID);
		}
		else
		{  // Find out what was returned, send the equivalent ally version
			switch(defaultChatID)
			{
				case cAICommPromptToEnemyWhenHeGathersNugget:
				{
					sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNugget); 
					break;
				}
				case cAICommPromptToEnemyWhenHeGathersNuggetCoin:
				{
					sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetCoin); 
					break;
				}
				case cAICommPromptToEnemyWhenHeGathersNuggetFood:
				{
					sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetFood); 
					break;
				}
				case cAICommPromptToEnemyWhenHeGathersNuggetWood:
				{
					sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetWood); 
					break;
				}
				case cAICommPromptToEnemyWhenHeGathersNuggetNatives:
				{
					sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetNatives); 
					break;
				}
				case cAICommPromptToEnemyWhenHeGathersNuggetSettlers:
				{
					sendStatement(playerID, cAICommPromptToAllyWhenHeGathersNuggetSettlers); 
					break;
				}
			}
		}
	}
	else
	{
		//-- I gathered the nugget.  Figure out what kind it is based on the defaultChatID enemy version.
		// Substitute appropriate ally and enemy chats.
		switch(defaultChatID)
		{
			case cAICommPromptToEnemyWhenHeGathersNugget:
			{
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNugget);
				sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNugget);
				break;
			}
			case cAICommPromptToEnemyWhenHeGathersNuggetCoin:
			{
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetCoin);
				sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetCoin);
				break;
			}
			case cAICommPromptToEnemyWhenHeGathersNuggetFood:
			{
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetFood);
				sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetFood);
				break;
			}
			case cAICommPromptToEnemyWhenHeGathersNuggetWood:
			{
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetWood);
				sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetWood);
				break;
			}
			case cAICommPromptToEnemyWhenHeGathersNuggetNatives:
			{
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetNatives);
				sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetNatives);
				break;
			}
			case cAICommPromptToEnemyWhenHeGathersNuggetSettlers:
			{
				sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenIGatherNuggetSettlers);
				sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyWhenIGatherNuggetSettlers);
				break;
			}
		}
	}
	
	return;
}

rule monitorFeeding
inactive
minInterval 60
{
	// Once a minute, check the global vars to see if there is somebody we need
	// to be sending resources to.  If so, send whatever we have in root.  If not,
	// go to sleep.
	// Feeding is not allowed before Age 2 is reached
	bool stayAwake = false; // Set true if we have orders to feed anything, keeps rule active.
	float toSend = 0.0;
	bool goldSent = false;  // Used for choosing chat at end.
	bool woodSent = false;
	bool foodSent = false;
	bool failure = false;
	int failPlayerID = -1;
	
	// Ignore already eliminated players
	if (kbHasPlayerLost(gFeedGoldTo) == true)
	gFeedGoldTo = 0;
	if (kbHasPlayerLost(gFeedWoodTo) == true)
	gFeedWoodTo = 0;
	if (kbHasPlayerLost(gFeedFoodTo) == true)
	gFeedFoodTo = 0;
	
	if (gFeedGoldTo > 0)
	{
		stayAwake = true; // There is work to do, stay active.
		toSend = 0.0;
		if (aiResourceIsLocked(cResourceGold) == false)
		{
			kbEscrowFlush(cEconomyEscrowID, cResourceGold, false);
			kbEscrowFlush(cMilitaryEscrowID, cResourceGold, false);
			toSend = kbEscrowGetAmount(cRootEscrowID, cResourceGold) * .85;   // Round down for trib penalty
		}
		if ((toSend > 100.0) && (kbGetAge() >= cAge2))
		{  // can send something
			goldSent = true;
			gLastTribSentTime = xsGetTime();
			if (toSend > 1000.0)
            toSend = 1000;
			if (toSend > 200.0)
            aiTribute(gFeedGoldTo, cResourceGold, toSend/2);
			else
            aiTribute(gFeedGoldTo, cResourceGold, 100.0);
		}
		else
		{
			failure = true;
			failPlayerID = gFeedGoldTo;
		}
		stayAwake = true; // There is work to do, stay active.
	}
	
	if (gFeedWoodTo > 0)
	{
		stayAwake = true; // There is work to do, stay active.
		toSend = 0.0;
		if (aiResourceIsLocked(cResourceWood) == false)
		{
			kbEscrowFlush(cEconomyEscrowID, cResourceWood, false);
			kbEscrowFlush(cMilitaryEscrowID, cResourceWood, false);
			toSend = kbEscrowGetAmount(cRootEscrowID, cResourceWood) * .85;   // Round down for trib penalty
		}
		if ((toSend > 100.0) && (kbGetAge() >= cAge2))
		{  // can send something
			gLastTribSentTime = xsGetTime();
			woodSent = true;
			if (toSend > 1000.0)
            toSend = 1000;
			if (toSend > 200.0)
            aiTribute(gFeedWoodTo, cResourceWood, toSend/2);
			else
            aiTribute(gFeedWoodTo, cResourceWood, 100.0);
		}
		else
		{
			failure = true;
			failPlayerID = gFeedWoodTo;
		}
		stayAwake = true; // There is work to do, stay active.
	}
	
	if (gFeedFoodTo > 0)
	{
		stayAwake = true; // There is work to do, stay active.
		toSend = 0.0;
		if (aiResourceIsLocked(cResourceFood) == false)
		{
			kbEscrowFlush(cEconomyEscrowID, cResourceFood, false);
			kbEscrowFlush(cMilitaryEscrowID, cResourceFood, false);
			toSend = kbEscrowGetAmount(cRootEscrowID, cResourceFood) * .85;   // Round down for trib penalty
		}
		if ((toSend > 100.0) && (kbGetAge() >= cAge2))
		{  // can send something
			gLastTribSentTime = xsGetTime();
			foodSent = true;
			if (toSend > 1000.0)
            toSend = 1000;
			if (toSend > 200.0)
            aiTribute(gFeedFoodTo, cResourceFood, toSend/2);
			else
            aiTribute(gFeedFoodTo, cResourceFood, 100.0);
		}
		else
		{
			failure = true;
			failPlayerID = gFeedFoodTo;
		}
		stayAwake = true; // There is work to do, stay active.
	}
	
	int tributes = 0;
	if (goldSent == true)
	tributes = tributes + 1;
	if (woodSent == true)
	tributes = tributes + 1;
	if (foodSent == true)
	tributes = tributes + 1;
	
	if (stayAwake == false)
	{
		//aiEcho("Disabling monitorFeeding rule.");
		xsDisableSelf();  // No work to do, go to sleep.
	}
}

extern int gMissionToCancel = -1;   // Function returns # of units available, sets global var so commhandler can kill the mission if needed.
int unitCountFromCancelledMission(int oppSource = cOpportunitySourceAllyRequest)
{
	int retVal = 0;   // Number of military units available
	gMissionToCancel = -1;
	
	if (oppSource == cOpportunitySourceTrigger)
	return(0); // DO NOT mess with scenario triggers
	
	int planCount = aiPlanGetNumber(cPlanMission, cPlanStateWorking, true);
	int plan = -1;
	int childPlan = -1;
	int oppID = -1;
	int pri = -1;
	
	
	//aiEcho(planCount+" missions found");
	for (i=0; < planCount)
	{
		plan = aiPlanGetIDByIndex(cPlanMission, cPlanStateWorking, true, i);
		if (plan < 0)
		continue;
		childPlan = aiPlanGetVariableInt(plan, cMissionPlanPlanID, 0);
		oppID = aiPlanGetVariableInt(plan, cMissionPlanOpportunityID, 0);
		//aiEcho("  Examining mission "+plan);
		//aiEcho("    Child plan is "+childPlan);
		//aiEcho("    Opp ID is "+oppID);
		pri = aiGetOpportunitySourceType(oppID);
		//aiEcho("    Opp priority is "+pri+", incoming command is "+oppSource);
		if ( (pri > cOpportunitySourceAutoGenerated) && (pri <= oppSource) ) // This isn't an auto-generated opp, and the incoming command has sufficient rank.
		{
			//aiEcho("  This is valid to cancel.");
			gMissionToCancel = plan;   // Store this so commHandler can kill it.
			//aiEcho("    Child plan has "+aiPlanGetNumberUnits(childPlan, cUnitTypeLogicalTypeLandMilitary)+" units.");
			retVal = aiPlanGetNumberUnits(childPlan, cUnitTypeLogicalTypeLandMilitary);
		}
		else
		{
			//aiEcho("Cannot cancel mission "+plan);
			retVal = 0;
		}
	}   
	return(retVal);
}

//==============================================================================
// commHandler
//==============================================================================
void commHandler(int chatID =-1)
{
	// Set up our parameters in a convenient format...
	int fromID = aiCommsGetSendingPlayer(chatID);         // Which player sent this?
	int verb = aiCommsGetChatVerb(chatID);                // Verb, like cPlayerChatVerbAttack or cPlayerChatVerbDefend
	int targetType = aiCommsGetChatTargetType(chatID);    // Target type, like cPlayerChatTargetTypePlayers or cPlayerChatTargetTypeLocation
	int targetCount = aiCommsGetTargetListCount(chatID);  // How many targets?
	static int targets = -1;                              // Array handle for target array.
	vector location = aiCommsGetTargetLocation(chatID);   // Target location
	int firstTarget = -1;
	static int  targetList = -1;
	int opportunitySource = cOpportunitySourceAllyRequest;             // Assume it's from a player unless we find out it's player 0, Gaia, indicating a trigger
	int newOppID = -1;
	
	if (fromID == 0)  // Gaia sent this 
	opportunitySource = cOpportunitySourceTrigger;
	
	if (fromID == cMyID)
	return;  // DO NOT react to echoes of my own commands/requests.
	
	if ( (kbIsPlayerEnemy(fromID) == true) && (fromID != 0) )
	return;  // DO NOT accept messages from enemies.
	
	if (targets < 0)
	{
		//aiEcho("Creating comm handler target array.");
		targets = xsArrayCreateInt(30, -1, "Chat targets");
		//aiEcho("Create array int returns "+targets);
	}  
	
	// Clear, then fill targets array
	int i=0;
	for (i=0; <30)
	xsArraySetInt(targets, i, -1);
	
	if (targetCount > 30)
	targetCount = 30; // Stay within array bounds
	for (i=0; <targetCount)
	xsArraySetInt(targets, i, aiCommsGetTargetListItem(chatID, i));
	
	if (targetCount > 0)
	firstTarget = xsArrayGetInt(targets, 0);
	
	// Spew
	//aiEcho(" ");
	//aiEcho(" ");
	//aiEcho("***** Incoming communication *****");
	//aiEcho("From: "+fromID+",  verb: "+verb+",  targetType: "+targetType+",  targetCount: "+targetCount);
	//for (i=0; <targetCount)
	//aiEcho("        "+xsArrayGetInt(targets, i));
	//aiEcho("Vector: "+location);
	//aiEcho(" ");
	//aiEcho("***** End of communication *****");
	
	switch(verb)      // Parse this message starting with the verb
	{
		case cPlayerChatVerbAttack: 
		{     // "Attack" from an ally player could mean attack enemy base, defend my base, or claim empty VP Site.  
            // Attack from a trigger means attack unit list.
            // Permission checks need to be done inside the inner switch statement, as cvOkToAttack only affects true attack commands.
			int militaryAvail = unitCountFromCancelledMission(opportunitySource);
			int reserveAvail = aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
			int totalAvail = militaryAvail + reserveAvail;
			//aiEcho("Plan units available: "+militaryAvail+", reserve ="+reserveAvail+", good army size is "+gGoodArmyPop); 
			if(opportunitySource == cOpportunitySourceAllyRequest)
			{  // Don't mess with triggers this late in development
				if (totalAvail < 3)
				{
					//aiEcho("Sorry, no units available.");
					// chat "no units" and bail
					sendStatement(fromID, cAICommPromptToAllyDeclineNoArmy);
					return;
				}
				if ( aiTreatyActive() == true )
				{
					//aiEcho("Can't attack under treaty.");
					sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
					return;
				}
				else
				{
					if (totalAvail < (gGoodArmyPop/2))
					{
						//aiEcho("Sorry, not enough units.");
						// chat "not enough army units" and bail
						sendStatement(fromID, cAICommPromptToAllyDeclineSmallArmy);
						return;
					}
				}
				// If we get here, it's not a trigger, but we do have enough units to go ahead.
				// See if cancelling an active mission is really necessary.
				if ( (reserveAvail > gGoodArmyPop) || (gMissionToCancel < 0) )
				{
					aiEcho("Plenty in reserve, no need to cancel...or no mission to cancel.");
				}
				else
				{
					//aiEcho("Not enough military units, need to destroy mission "+gMissionToCancel);
					aiPlanDestroy(gMissionToCancel); // Cancel the active mission.
				}
			}
			switch(targetType)
			{
				case cPlayerChatTargetTypeLocation:
				{
					//-- Figure out what is in the this area, and do the correct thing.
					//-- Find nearest base and vpSite, and attack/defend/claim as appropriate.
					int closestBaseID = kbFindClosestBase(cPlayerRelationAny, location);     // If base is ally, attack point/radius to help out
					int closestVPSite = getClosestVPSite(location, cVPAll, cVPStateAny, -1);
					
					if ( (closestVPSite >= 0) && (distance(location, kbVPSiteGetLocation(closestVPSite)) < 20.0))
					{  // Near a VP site...this is a claim opportunity
						newOppID = createOpportunity(cOpportunityTypeClaim, cOpportunityTargetTypeVPSite, closestVPSite, -1, opportunitySource);
						sendStatement(fromID, cAICommPromptToAllyConfirm);
						aiActivateOpportunity(newOppID, true);
						break;   // We've created an Opp, we're done.
					}
					if( (closestBaseID != -1) && (distance(location, kbBaseGetLocation(kbBaseGetOwner(closestBaseID),closestBaseID)) < 50.0) )
					{  // Command is inside a base.  If enemy, base attack.  If ally, point/radius attack.
						if (kbIsPlayerAlly( kbBaseGetOwner(closestBaseID) ) == false)
						{  // This is an enemy base, create a base attack opportunity
							if ( (cvOkToAttack == false) && (opportunitySource == cOpportunitySourceAllyRequest) )  // Attacks prohibited unless it's a trigger
							{
								// bail out, we're not allowed to do this.
								sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
								//aiEcho("ERROR:  We're not allowed to attack.");
								return();
								break;
							}
							newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypeBase, closestBaseID, kbBaseGetOwner(closestBaseID), opportunitySource);
							sendStatement(fromID, cAICommPromptToAllyConfirm, kbBaseGetLocation(kbBaseGetOwner(closestBaseID),closestBaseID));
						}
						else
						{  // Ally base, so do attack point/radius here.
							newOppID = createOpportunity(cOpportunityTypeDefend, cOpportunityTargetTypeBase, closestBaseID, kbBaseGetOwner(closestBaseID), opportunitySource);
							aiSetOpportunityLocation(newOppID, kbBaseGetLocation(kbBaseGetOwner(closestBaseID),closestBaseID));
							aiSetOpportunityRadius(newOppID, 50.0);                     
							sendStatement(fromID, cAICommPromptToAllyIWillHelpDefend, location);
							//createOpportunity(int type, int targettype, int targetID, int targetPlayerID, int source ): 
						}
						aiActivateOpportunity(newOppID, true);
						break;   // We've created an Opp, we're done.
					}  
					
					// If we're here, it's not a VP site, and not an enemy or ally base - basically open map.
					// Create a point/radius destroy opportunity.
					newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypePointRadius, -1, chooseAttackPlayerID(location, 50.0), opportunitySource);
					aiSetOpportunityLocation(newOppID, location);
					aiSetOpportunityRadius(newOppID, 50.0);
					aiActivateOpportunity(newOppID, true);                     
					sendStatement(fromID, cAICommPromptToAllyConfirm);               
					break;   
				}  // case targetType location
				case cPlayerChatTargetTypeUnits:
				{  // This is a trigger command to attack a unit list.
					newOppID = createOpportunity(cOpportunityTypeDestroy, cOpportunityTargetTypeUnitList, targets, chooseAttackPlayerID(location, 50.0), opportunitySource);
					aiSetOpportunityLocation(newOppID, location);
					aiSetOpportunityRadius(newOppID, 50.0);    
					aiActivateOpportunity(newOppID, true);                 
					sendStatement(fromID, cAICommPromptToAllyConfirm);               
					break;
				}
				default:
				{  // Not recognized
					sendStatement(fromID, cAICommPromptToAllyDeclineGeneral);  
					//aiEcho("ERROR!  Target type "+targetType+" not recognized.");
					return();   // Don't risk sending another chat...
					break;
				}
			}  // end switch targetType
			break;   
		}  // end verb attack
		
		case cPlayerChatVerbTribute:
		{
			if ( opportunitySource == cOpportunitySourceAllyRequest )
			{
				//aiEcho("    Command was to tribute to player "+fromID+".  Resource list:");
				bool alreadyChatted = false;
				for (i=0; < targetCount)
				{
					float amountAvailable = 0.0;
					if (xsArrayGetInt(targets, i) == cResourceGold)
					{
						kbEscrowFlush(cEconomyEscrowID, cResourceGold, false);
						kbEscrowFlush(cMilitaryEscrowID, cResourceGold, false);
						amountAvailable = kbEscrowGetAmount(cRootEscrowID, cResourceGold) * .85;   // Leave room for tribute penalty
						if (aiResourceIsLocked(cResourceGold) == true)
						amountAvailable = 0.0;
						if ((amountAvailable > 100.0) && (kbGetAge() >= cAge2))
						{  // We will tribute something
							if (alreadyChatted == false)
							{
								sendStatement(fromID, cAICommPromptToAllyITributedCoin);  
								alreadyChatted = true;
							}
							gLastTribSentTime = xsGetTime();
							if (amountAvailable > 1000.0)
							amountAvailable = 1000;
							if (amountAvailable > 200.0)
							aiTribute(fromID, cResourceGold, amountAvailable/2);
							else
							aiTribute(fromID, cResourceGold, 100.0);
						}
						else
						{
							if (alreadyChatted == false)
							{
								sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
								alreadyChatted = true;
							}
						}
						//aiEcho("        Tribute gold");
					}
					if (xsArrayGetInt(targets, i) == cResourceFood)
					{
						kbEscrowFlush(cEconomyEscrowID, cResourceFood, false);
						kbEscrowFlush(cMilitaryEscrowID, cResourceFood, false);
						amountAvailable = kbEscrowGetAmount(cRootEscrowID, cResourceFood) * .85;   // Leave room for tribute penalty
						if (aiResourceIsLocked(cResourceFood) == true)
						amountAvailable = 0.0;
						if ((amountAvailable > 100.0) && (kbGetAge() >= cAge2))
						{  // We will tribute something
							if (alreadyChatted == false)
							{
								sendStatement(fromID, cAICommPromptToAllyITributedFood);  
								alreadyChatted = true;
							}
							gLastTribSentTime = xsGetTime();
							if (amountAvailable > 1000.0)
							amountAvailable = 1000;
							if (amountAvailable > 200.0)
							aiTribute(fromID, cResourceFood, amountAvailable/2);
							else
							aiTribute(fromID, cResourceFood, 100.0);
						}
						else
						{
							if (alreadyChatted == false)
							{
								sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
								alreadyChatted = true;
							}
						}
						//aiEcho("        Tribute food");
					}
					if (xsArrayGetInt(targets, i) == cResourceWood)
					{
						kbEscrowFlush(cEconomyEscrowID, cResourceWood, false);
						kbEscrowFlush(cMilitaryEscrowID, cResourceWood, false);
						amountAvailable = kbEscrowGetAmount(cRootEscrowID, cResourceWood) * .85;   // Leave room for tribute penalty
						if (aiResourceIsLocked(cResourceWood) == true)
						amountAvailable = 0.0;
						if ((amountAvailable > 100.0) && (kbGetAge() >= cAge2))
						{  // We will tribute something
							if (alreadyChatted == false)
							{
								sendStatement(fromID, cAICommPromptToAllyITributedWood);  
								alreadyChatted = true;
							}
							gLastTribSentTime = xsGetTime();
							if (amountAvailable > 1000.0)
							amountAvailable = 1000;
							if (amountAvailable > 200.0)
							aiTribute(fromID, cResourceWood, amountAvailable/2);
							else
							aiTribute(fromID, cResourceWood, 100.0);
							kbEscrowAllocateCurrentResources();
						}
						else
						{
							if (alreadyChatted == false)
							{
								sendStatement(fromID, cAICommPromptToAllyDeclineCantAfford);
								alreadyChatted = true;
							}
						}
						//aiEcho("        Tribute wood");
					}
				}
			} // end source allyRequest
			else
			{     // Tribute trigger...send it to player 1
				//aiEcho("    Command was a trigger to tribute to player 1.  Resource list:");
				for (i=0; <= 2)   // Target[x] is the amount of resource type X to send
				{
					float avail = kbEscrowGetAmount(cRootEscrowID, i) * .85;
					int qty = xsArrayGetInt(targets, i);
					if (qty > 0)
					{
						//aiEcho("        Resource # "+i+", amount: "+qty+" requested.");
						if (avail >= qty)  // we can afford it
						{
							aiTribute(1, i, qty);
							//aiEcho("            Sending full amount.");
						}
						else
						{
							aiTribute(1, i, avail);   // Can't afford it, send what we have.
							//aiEcho("            Sending all I have, "+avail+".");
						}
					}
				}
			}
			break;
		}  // End verb tribute
		
		case cPlayerChatVerbFeed:     // Ongoing tribute.  Once a minute, send whatever you have in root.
		{
			//aiEcho("    Command was to feed resources to a player.");
			alreadyChatted = false;
			for (i=0; < targetCount)
			{
				switch(xsArrayGetInt(targets, i))
				{
					case cResourceGold:
					{
						gFeedGoldTo = fromID;
						if (xsIsRuleEnabled("monitorFeeding") == false)
						{
							xsEnableRule("monitorFeeding");
							monitorFeeding();
						}
						if (alreadyChatted == false)
						{
							sendStatement(fromID, cAICommPromptToAllyIWillFeedCoin);
							alreadyChatted = true;
						}
						break;
					}
					case cResourceWood:
					{
						gFeedWoodTo = fromID;
						if (xsIsRuleEnabled("monitorFeeding") == false)
						{
							xsEnableRule("monitorFeeding");
							monitorFeeding();
						}
						if (alreadyChatted == false)
						{
							sendStatement(fromID, cAICommPromptToAllyIWillFeedWood);
							alreadyChatted = true;
						}
						break;
					}
					case cResourceFood:
					{
						gFeedFoodTo = fromID;
						if (xsIsRuleEnabled("monitorFeeding") == false)
						{
							xsEnableRule("monitorFeeding");
							monitorFeeding();
						}
						if (alreadyChatted == false)
						{
							sendStatement(fromID, cAICommPromptToAllyIWillFeedFood);
							alreadyChatted = true;
						}
						break;
					}
				}            
			}
			break;
		} // End verb feed
		
		case cPlayerChatVerbTrain:
		{
			//aiEcho("    Command was to train units starting with "+firstTarget+", unit type "+kbGetProtoUnitName(firstTarget));
			// See if we have authority to change the settings
			bool okToChange = false;
			if (opportunitySource == cOpportunitySourceTrigger)
            okToChange = true;   // Triggers always rule
			if (opportunitySource == cOpportunitySourceAllyRequest)
			{
				if ( (gUnitPickSource == cOpportunitySourceAllyRequest) || (gUnitPickSource == cOpportunitySourceAutoGenerated) )
				okToChange = true;
			}
			if (okToChange == true)
			{
				//aiEcho("    Permission granted, changing units.");
				gUnitPickSource = opportunitySource;    // Record who made this change
				gUnitPickPlayerID = fromID;
				
				cvPrimaryArmyUnit = firstTarget;
				cvSecondaryArmyUnit = -1;
				//aiEcho("        Primary unit is "+firstTarget+" "+kbGetProtoUnitName(firstTarget));
				setUnitPickerPreference(gLandUnitPicker);
				
				if (gUnitPickSource == cOpportunitySourceAllyRequest)
				sendStatement(fromID, cAICommPromptToAllyConfirm);
			}
			else 
			{
				sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
				//aiEcho("    Cannot override existing settings.");
			}
			break;
		}
		case cPlayerChatVerbDefend:
		{  // Currently, defend is only available via the aiCommsDefend trigger, it is not in the UI.
			// An "implicit" defend can be done when a human player issues an attack command on a location
			// that does not have enemy units nearby.  
			// Currently, all defend verbs will be point/radius
			newOppID = createOpportunity(cOpportunityTypeDefend, cOpportunityTargetTypePointRadius, -1, chooseAttackPlayerID(location, 50.0), opportunitySource);
			aiSetOpportunityLocation(newOppID, location);
			aiSetOpportunityRadius(newOppID, 50.0);              
			aiActivateOpportunity(newOppID, true);
			break;
		}
		case cPlayerChatVerbClaim:
		{  // Available only from trigger, sends a vector.  Humans can send implicit claim commands
			// by sending "attack" with a point that is near an unclaimed VP site.
			closestVPSite = getClosestVPSite(location, cVPAll, cVPStateAny, -1);
			bool permitted = true;
			if ( (cvOkToClaimTrade == false) && (kbVPSiteGetType(closestVPSite) == cVPTrade) )
            permitted = false;
			if ( (cvOkToAllyNatives== false) && (kbVPSiteGetType(closestVPSite) == cVPNative) )
            permitted = false;
			
			if (permitted = false)
			{
				sendStatement(fromID, cAICommPromptToAllyDeclineProhibited);
				//aiEcho("    Not allowed to claim this type of site.");            
			}
			else
			{
				newOppID = createOpportunity(cOpportunityTypeClaim, cOpportunityTargetTypeVPSite, closestVPSite, -1, opportunitySource);
				aiActivateOpportunity(newOppID, true); 
			}            
			break;
		}
		case cPlayerChatVerbStrategy:
		{
			if(xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyRush)
			{
				btRushBoom = 1.0;
				xsEnableRule("turtleUp");
				gPrevNumTowers = gNumTowers;
				gNumTowers = 0;
			}
			else if(xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyBoom)
			{
				btRushBoom = -1.0;
			}
			else if(xsArrayGetInt(targets, 0) == cPlayerChatTargetStrategyTurtle)
			{
				
				btOffenseDefense = -1.0;
				xsEnableRule("turtleUp");
				gPrevNumTowers = gNumTowers;
				if (civIsAsian() == false)
				{
					gNumTowers = 7;
				}
				else
				{
					gNumTowers = 5;
				}
			}
			sendStatement(fromID, cAICommPromptToAllyConfirm);
			break;
		}
		case cPlayerChatVerbCancel:
		{
			// Clear training (unit line bias) settings
			if ( (gUnitPickSource == cOpportunitySourceAllyRequest) || (opportunitySource == cOpportunitySourceTrigger) )  
			{  // We have an ally-generated unit line choice, destroy it
				gUnitPickSource = cOpportunitySourceAutoGenerated;
				gUnitPickPlayerID = -1;
				cvPrimaryArmyUnit = -1;
				cvSecondaryArmyUnit = -1;
				setUnitPickerPreference(gLandUnitPicker);
			}
			
			// Clear Feeding (ongoing tribute) settings
			gFeedGoldTo = -1;
			gFeedWoodTo = -1;
			gFeedFoodTo = -1;
			
			// Cancel any active attack, defend or claim missions from allies or triggers
			if ( (opportunitySource == cOpportunitySourceTrigger) || (opportunitySource == cOpportunitySourceAllyRequest) )
			{
				if (gMostRecentAllyOpportunityID >= 0)
				{
					aiDestroyOpportunity(gMostRecentAllyOpportunityID);
					//aiEcho("Destroying opportunity "+gMostRecentAllyOpportunityID+" because of cancel command.");
					gMostRecentAllyOpportunityID = -1;
				}
			}
			if (opportunitySource == cOpportunitySourceTrigger)
			{
				if (gMostRecentTriggerOpportunityID >= 0)
				{
					aiDestroyOpportunity(gMostRecentTriggerOpportunityID);
					//aiEcho("Destroying opportunity "+gMostRecentTriggerOpportunityID+" because of cancel command.");
					gMostRecentTriggerOpportunityID = -1;
				}       
				// Also, a trigger cancel must kill any active auto-generated attack or defend plans
				int numPlans = aiPlanGetNumber(cPlanMission, -1, true);
				int index = 0;
				int plan = -1;
				int planOpp = -1;
				for (index = 0; < numPlans)
				{
					plan = aiPlanGetIDByIndex(cPlanMission, -1, true, index);
					planOpp = aiPlanGetVariableInt(plan, cMissionPlanOpportunityID, 0);
					if (planOpp >= 0)
					{
						if (aiGetOpportunitySourceType(planOpp) == cOpportunitySourceAutoGenerated)
						{
							//aiEcho("--------DESTROYING MISSION "+plan+" "+aiPlanGetName(plan));
							aiPlanDestroy(plan);
						}
					}
				}
			}
			// Reset number of towers
			if (gPrevNumTowers >= 0)
            gNumTowers = gPrevNumTowers;
			break;
		}
		default:
		{
			//aiEcho("    Command verb not found, verb value is: "+verb);
			break;
		}
	}
	//aiEcho("********************************************");   
}

rule delayAttackMonitor
inactive
group tcComplete
minInterval 10
{
	// If this rule is active, it means that gDelayAttacks has been set true,
	// and we're on a diffuclty level where we can't attack until AFTER someone
	// has attacked us, or until we've reached age 4.  
	
	gDelayAttacks = false;
	if(aiGetWorldDifficulty() == cDifficultySandbox) 
	{
		gDelayAttacks = true;
		return;
	}
	/*
		if(aiGetWorldDifficulty() == cDifficultyEasy && xsGetTime() < 1800000) gDelayAttacks = true;
		
		if(kbGetAge() < cAge3 && xsGetTime() > 1200000)
		{
		gDelayAttacks = true;
		}
		
		if(kbGetAge() < cAge4 && xsGetTime() > 2500000)
		{
		gDelayAttacks = true;
		}
		if(kbGetAge() < cAge5 && xsGetTime() > 3500000)
		{
		gDelayAttacks = true;
		}
	*/
	
	/*
		if (kbGetAge() >= cAge4)
		{
		if ( (gDelayAttacks == true) && (aiGetWorldDifficulty() >= cDifficultyEasy) )
		{
		aiEcho(" ");
		aiEcho("    OK, THE GLOVES COME OFF NOW!");
		aiEcho(" ");
		gDelayAttacks = false;
		}
		//  xsDisableSelf();
		return;
		}
	*/
	/*
		// See if we're under attack.
		if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))
		{  // Main base is under attack
		if ( (gDelayAttacks == true) && (aiGetWorldDifficulty() >= cDifficultyEasy) )
		{
		aiEcho(" ");
		aiEcho("    OK, THE GLOVES COME OFF NOW!");
		aiEcho(" ");
		gDelayAttacks = false;
		}
		// xsDisableSelf();  // If sandbox, just turn off.
		}
	*/
	
}

//==============================================================================
// exploreMonitor
/*
	Used to correctly implement changes in cvOkToExplore.
	If it's off, make sure the explore plan is killed.
	If it's on, make sure the explore plan is active.
	
	Initially, the explore plan gets an explorer plus 5/15/20 military units,
	so that it can effectively gather nuggets.  We switch out of this mode 3 minutes
	after reaching age 2, unless the explore plan is in nugget gathering mode.
*/
//==============================================================================
rule exploreMonitor
inactive 
minInterval 10
{
	const int   cExploreModeStart = 0;     // Initial setting, when first starting out
	const int   cExploreModeNugget = 1;    // Explore and gather nuggets.  Heavy staffing, OK to recruit more units.
	const int   cExploreModeStaff = 2;     // Restaffing the plan, active for 10 seconds to let the plan grab 1 more unit.
	const int   cExploreModeExplore = 3;   // Normal...explore until this unit dies, check again in 5 minutes.
	
	static int  exploreMode = cExploreModeStart;
	static int  age2Time = -1;
	static int  nextStaffTime = -1;        // Prevent the explore plan from constantly sucking in units.
	
	if ( (age2Time < 0) && (kbGetAge() >= cAge2) )
	age2Time = xsGetTime();
	
	// Check for a failed plan
	if ( (gLandExplorePlan >= 0) && (aiPlanGetState(gLandExplorePlan) < 0) )
	{
		// Somehow, the plan has died.  Reset it to start up again if allowed.
		gLandExplorePlan = -1;
		exploreMode = cExploreModeStart;
		nextStaffTime = -1;
	}
	
	// Decide on which unit type to use as single scouts
	// If possible, converted guardians or cheap infantry units are used
	int scoutType = -1;
	if (kbUnitCount(cMyID, cUnitTypeGuardian, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeGuardian;
	else if (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeCrossbowman;
	else if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypePikeman;
	else if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeStrelet;
	else if (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeLongbowman;
	else if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeMusketeer;
	else if (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarrior;
	else if (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpAenna;
	else if (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpTomahawk;
	else if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpMacehualtin;
	else if (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpPumaMan;
	else if (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarBow;
	else if (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarClub;
	else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawPistol, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeSaloonOutlawPistol;
	else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawRifleman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeSaloonOutlawRifleman;
	else if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeJanissary;
	else if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypQiangPikeman;
	else if (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypChuKoNu;
	else if (kbUnitCount(cMyID, cUnitTypeypMonkDisciple, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypMonkDisciple;
	else if (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypArquebusier;
	else if (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypChangdao;
	else if (kbUnitCount(cMyID, cUnitTypeypSepoy, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypSepoy;
	else if (kbUnitCount(cMyID, cUnitTypeypNatMercGurkha, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypNatMercGurkha;
	else if (kbUnitCount(cMyID, cUnitTypeypRajput, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypRajput;
	else if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypYumi;
	else if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypAshigaru;
	else if (kbUnitCount(cMyID, cUnitTypeEnvoy, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeEnvoy;
	else if (kbUnitCount(cMyID, cUnitTypeNativeScout, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeNativeScout;
	else if (kbUnitCount(cMyID, cUnitTypeypMongolScout, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypMongolScout;
	else
	scoutType = cUnitTypeLogicalTypeValidSharpshoot;
	
	// First, check the control variable and react appropriately
	
	if ( cvOkToExplore == true )
	{
		if (aiPlanGetActive(gLandExplorePlan) == false)
		if (gLandExplorePlan >= 0)
		aiPlanSetActive(gLandExplorePlan);     // Reactivate if we were shut off
		switch(exploreMode)
		{
			case cExploreModeStart:
			{
				if (aiPlanGetState(gLandExplorePlan) < 0)
				{  // Need to create it.
					gLandExplorePlan=aiPlanCreate("Land Explore", cPlanExplore);
					aiPlanSetDesiredPriority(gLandExplorePlan, 75);
					if (cvOkToGatherNuggets == true)
					{
						switch(kbGetCiv())
						{
							case cCivXPAztec:
							{
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 1, 1, 1);
								break;
							}
							case cCivXPIroquois:
							{
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
								break;
							}
							case cCivXPSioux:
							{
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
								break;
							}
							case cCivChinese:
							{
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 1, 1, 1);
								break;
							}
							case cCivIndians:
							{
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 1, 1, 1);
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 1, 1, 1);
								break;
							}
							case cCivJapanese:
							{
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 1, 1, 1);
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
								break;
							}
							default:
							{
								aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 1, 1, 1);
								break;
							}
						}
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractCavalry, 2, 2, 2);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypeAbstractPet, 1, 6, 10);
						aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanOkToGatherNuggets, 0, true);
						exploreMode = cExploreModeNugget;
					}
					else
					{
						aiPlanAddUnitType(gLandExplorePlan, scoutType, 1, 1, 1);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 0, 0, 0);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 0, 0, 0);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 0, 0, 0);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 0, 0, 0);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 0, 0, 0);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 0, 0, 0);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 0, 0, 0);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 0, 0, 0);
						aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 0, 0, 0);
						aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanOkToGatherNuggets, 0, false);
						exploreMode = cExploreModeStaff;
						nextStaffTime = xsGetTime() + 120000;     // Two minutes from now, let it get another soldier if it loses this one.
						if (gExplorerControlPlan < 0)
						{
							gExplorerControlPlan = aiPlanCreate("Explorer control plan", cPlanDefend);
							switch(kbGetCiv())
							{
								case cCivXPAztec:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
									break;
								}
								case cCivXPIroquois:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
									break;
								}
								case cCivXPSioux:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
									break;
								}
								case cCivChinese:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkChinese, 1, 1, 1);
									break;
								}
								case cCivIndians:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian, 1, 1, 1);
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
									break;
								}
								case cCivJapanese:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
									break;
								}
								default:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeExplorer, 1, 1, 1);
									break;
								}
							}
							aiPlanSetVariableVector(gExplorerControlPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
							aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanEngageRange, 0, 20.0);    // Tight
							aiPlanSetVariableBool(gExplorerControlPlan, cDefendPlanPatrol, 0, false);
							aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanGatherDistance, 0, 20.0);
							aiPlanSetInitialPosition(gExplorerControlPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
							aiPlanSetUnitStance(gExplorerControlPlan, cUnitStanceDefensive);
							aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanRefreshFrequency, 0, 30);
							aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
							aiPlanSetDesiredPriority(gExplorerControlPlan, 90);    // Quite high, don't suck him into routine attack plans, etc.
							aiPlanSetActive(gExplorerControlPlan);      
						}     
					}
					aiPlanSetEscrowID(gLandExplorePlan, cEconomyEscrowID);
					aiPlanSetBaseID(gLandExplorePlan, kbBaseGetMainID(cMyID));
					aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, true);
					aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 1);
					aiPlanSetActive(gLandExplorePlan); 
				}
				else
				{
					exploreMode = cExploreModeNugget;
				}
				break;
			}
			case cExploreModeNugget:
			{  
				// Check to see if we're out of time, and switch to single-unit exploring if we are.
				if (age2Time >= 0)
				{
					if (( ((xsGetTime() - age2Time) > 1800000) && (aiPlanGetState(gLandExplorePlan) != cPlanStateClaimNugget) ) ||
					((xsGetTime() - age2Time) > 3000000) )     // we've been in age 2 > 5 minutes, or > 3 minutes and not in gathering mode
					
					{  // Switch to a normal explore plan, create explorer control plan, enable local nugget gathering
						if (gExplorerControlPlan < 0)
						{
							gExplorerControlPlan = aiPlanCreate("Explorer control plan", cPlanDefend);
							switch(kbGetCiv())
							{
								case cCivXPAztec:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
									break;
								}
								case cCivXPIroquois:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
									break;
								}
								case cCivXPSioux:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
									break;
								}
								case cCivChinese:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkChinese, 1, 1, 1);
									break;
								}
								case cCivIndians:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian, 1, 1, 1);
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
									break;
								}
								case cCivJapanese:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
									break;
								}
								default:
								{
									aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeExplorer, 1, 1, 1);
									break;
								}
							}
							aiPlanSetVariableVector(gExplorerControlPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
							aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanEngageRange, 0, 20.0);    // Tight
							aiPlanSetVariableBool(gExplorerControlPlan, cDefendPlanPatrol, 0, false);
							aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanGatherDistance, 0, 20.0);
							aiPlanSetInitialPosition(gExplorerControlPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
							aiPlanSetUnitStance(gExplorerControlPlan, cUnitStanceDefensive);
							aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanRefreshFrequency, 0, 30);
							aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
							aiPlanSetDesiredPriority(gExplorerControlPlan, 90);    // Quite high, don't suck him into routine attack plans, etc.
							aiPlanSetActive(gExplorerControlPlan);     
							xsEnableRule("localNuggetGathering"); 
						}
						
						// Destroy and re-create plan for single scout
						aiPlanDestroy(gLandExplorePlan);
						gLandExplorePlan=aiPlanCreate("Land Explore", cPlanExplore);
						aiPlanSetDesiredPriority(gLandExplorePlan, 75);
						aiPlanAddUnitType(gLandExplorePlan, scoutType, 1, 1, 1);
						aiPlanSetNoMoreUnits(gLandExplorePlan, false);
						aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 0);
						aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, false);
						exploreMode = cExploreModeStaff;
						nextStaffTime = xsGetTime() + 120000;     // Two minutes from now, let it get another soldier.
						//aiEcho("Allowing the explore plan to grab a unit.");
					}
				}
				if (cvOkToGatherNuggets == false)
				{
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypeExplorer, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpAztecWarchief, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpIroquoisWarChief, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypexpLakotaWarchief, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkChinese, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkIndian2, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, cUnitTypeypMonkJapanese2, 0, 0, 0);
					aiPlanAddUnitType(gLandExplorePlan, scoutType, 1, 1, 1);
					aiPlanSetNoMoreUnits(gLandExplorePlan, false);
					aiPlanSetVariableInt(gLandExplorePlan, cExplorePlanNumberOfLoops, 0, 0);
					aiPlanSetVariableBool(gLandExplorePlan, cExplorePlanDoLoops, 0, false);
					exploreMode = cExploreModeStaff;
					nextStaffTime = xsGetTime() + 120000;     // Two minutes from now, let it get another soldier.
					//aiEcho("Allowing the explore plan to grab a unit.");               
				}
				break;
			}
			case cExploreModeStaff:
			{
				// We've been staffing for 10 seconds, set no more units to true
				aiPlanSetNoMoreUnits(gLandExplorePlan, true);
				exploreMode = cExploreModeExplore;
				//aiEcho("Setting the explore plan to 'noMoreUnits'");
				break;
			}
			case cExploreModeExplore:
			{  // See if we're allowed to add another unit
				if (xsGetTime() > nextStaffTime)
				{
					aiPlanSetNoMoreUnits(gLandExplorePlan, false);     // Let it grab a unit
					//aiEcho("Setting the explore plan to grab a unit if needed.");
					nextStaffTime = xsGetTime() + 120000;
					exploreMode = cExploreModeStaff;
				}
				break;
			}
		}
	}
	else // cvOkToExplore = false
	{
		aiPlanSetActive(gLandExplorePlan, false);
	}
}

//==============================================================================
// Opportunities and Missions
//==============================================================================

void missionStartHandler(int missionID = -1)
{  // Track times for mission starts, so we can tell how long its been since
	// we had a mission of a given type.
	if (missionID < 0)
	return;
	
	int oppID = aiPlanGetVariableInt(missionID, cMissionPlanOpportunityID, 0);
	int oppType = aiGetOpportunityType(oppID);
	
	aiPlanSetVariableInt(missionID, cMissionPlanStartTime, 0, xsGetTime()); // Set the start time in ms.
	
	switch(oppType)
	{
		case cOpportunityTypeDestroy:
		{
			gLastAttackMissionTime = xsGetTime();
			//aiEcho("-------- ATTACK MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
			break;
		}
		case cOpportunityTypeDefend:
		{
			gLastDefendMissionTime = xsGetTime();
			//aiEcho("-------- DEFEND MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
			break;
		}
		case cOpportunityTypeClaim:
		{
			gLastClaimMissionTime = xsGetTime();
			//aiEcho("-------- CLAIM MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
			break;
		}
		default:
		{
			//aiEcho("-------- UNKNOWN MISSION ACTIVATION: Mission "+missionID+", Opp "+oppID);
			break;
		}
	}
}

void missionEndHandler(int missionID = -1)
{
	aiEcho("-------- MISSION TERMINATION:  Mission "+missionID+", Opp "+aiGetOpportunityType(aiPlanGetVariableInt(missionID, cMissionPlanOpportunityID, 0)));
}

// Get a class rating, 0.0 to 1.0, for this type of opportunity.
// Scores zero when an opportunity of this type was just launched.
// Scores 1.0 when it has been 'gXXXMissionInterval' time since the last one.
float getClassRating(int oppType = -1, int target = -1)
{
	float retVal = 1.0;
	float timeElapsed = 0.0;
	int targetType = -1;
	
	switch(oppType)
	{
		case cOpportunityTypeDestroy:
		{
			timeElapsed = xsGetTime() - gLastAttackMissionTime;
			retVal = 1.0 * (timeElapsed / gAttackMissionInterval);
			break;
		}
		case cOpportunityTypeDefend:
		{
			timeElapsed = xsGetTime() - gLastDefendMissionTime;
			retVal = 1.0 * (timeElapsed / gDefendMissionInterval);
			break;
		}
		case cOpportunityTypeClaim:
		{
			timeElapsed = xsGetTime() - gLastClaimMissionTime;
			if (kbVPSiteGetType(target) == cVPTrade)
			{
				if ( btBiasTrade > 0.0)
				timeElapsed = timeElapsed * (1.0 + btBiasTrade);   // Multiply by at least one, up to 2, i.e. btBiasTrade of 1.0 will double elapsed time.
				else
				timeElapsed = timeElapsed / ((-1.0 * btBiasTrade) + 1.0);  // Divide by 1.00 up to 2.00, i.e. cut it in half if btBiasTrade = -1.0
				retVal = 1.0 * (timeElapsed / gClaimMissionInterval);
			}
			else  // VPNative
			{
				if ( btBiasNative > 0.0)
				timeElapsed = timeElapsed * (1.0 + btBiasNative);   // Multiply by at least one, up to 2, i.e. btBiasNative of 1.0 will double elapsed time.
				else
				timeElapsed = timeElapsed / ((-1.0 * btBiasNative) + 1.0);  // Divide by 1.00 up to 2.00, i.e. cut it in half if btBiasNative = -1.0
				retVal = 1.0 * (timeElapsed / gClaimMissionInterval);
			}
			break;
		}
	}
	if (retVal > 1.0)
	retVal = 1.0;
	if (retVal < 0.0)
	retVal = 0.0;
	return(retVal);
}

// Calculate an approximate rating for enemy strength in/near this base.
float getBaseEnemyStrength(int baseID = -1)
{
	
	float retVal = 0.0;
	int owner = kbBaseGetOwner(baseID);
	static int allyBaseQuery = -1;
	
	if (allyBaseQuery < 0)
	{
		allyBaseQuery = kbUnitQueryCreate("Ally Base query");
		kbUnitQuerySetIgnoreKnockedOutUnits(allyBaseQuery, true);
		kbUnitQuerySetPlayerRelation(allyBaseQuery, cPlayerRelationEnemyNotGaia);
		kbUnitQuerySetState(allyBaseQuery, cUnitStateABQ);
		kbUnitQuerySetUnitType(allyBaseQuery, cUnitTypeLogicalTypeLandMilitary);
	}
	
	
	if (baseID < 0)
	return(-1.0);
	
	if (owner <= 0)
	return(-1.0);
	
	if (kbIsPlayerEnemy(owner) == true)  
	{  // Enemy base, add up military factors normally
		retVal = retVal + (5.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, gTownCenter));  // 5 points per TC
		retVal = retVal + (10.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemy, cUnitTypeFortFrontier));  // 10 points per fort
		retVal = retVal + kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeLogicalTypeLandMilitary); // 1 point per soldier
		retVal = retVal + (3.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeOutpost));  // 3 points per outpost
		retVal = retVal + (3.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeBlockhouse));  // 3 points per blockhouse
		retVal = retVal + (3.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeWarHut));  // 3 points per war hut
		retVal = retVal + (5.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeNoblesHut));  // 5 points per nobles hut
		retVal = retVal + (5.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort2));  // 5 points per agra fort
		retVal = retVal + (5.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort3));
		retVal = retVal + (5.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort4));
		retVal = retVal + (5.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypWIAgraFort5));
		retVal = retVal + (5.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeypCastle));  // 5 points per castle
		retVal = retVal + (3.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeYPOutpostAsian));  // 3 points per Asian outpost
		retVal = retVal + (5.0 * kbBaseGetNumberUnits(owner, baseID, cPlayerRelationEnemyNotGaia, cUnitTypeTradingPost));  // 5 points per trading post (Advanced TP suspected!)
	}
	else
	{  // Ally base, we're considering defending.  Count enemy units present
		kbUnitQuerySetUnitType(allyBaseQuery, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetPosition(allyBaseQuery, kbBaseGetLocation(owner, baseID));
		kbUnitQuerySetMaximumDistance(allyBaseQuery, 55.0);
		kbUnitQueryResetResults(allyBaseQuery);
		retVal = kbUnitQueryExecute(allyBaseQuery);
	}
	if (retVal < 1.0)
	retVal = 1.0;  // Return at least 1.
	return(retVal);
}

// Calculate an approximate strength rating for the enemy units/buildings near this point.
float getPointEnemyStrength(vector loc = cInvalidVector)
{
	float retVal = 0.0;
	static int enemyPointQuery = -1;
	
	if (enemyPointQuery < 0)
	{
		enemyPointQuery = kbUnitQueryCreate("Enemy Point query");
		kbUnitQuerySetIgnoreKnockedOutUnits(enemyPointQuery, true);
		kbUnitQuerySetPlayerRelation(enemyPointQuery, cPlayerRelationEnemyNotGaia);
		kbUnitQuerySetState(enemyPointQuery, cUnitStateABQ);
		kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeLogicalTypeLandMilitary);
	}
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeLogicalTypeLandMilitary);
	kbUnitQuerySetPosition(enemyPointQuery, loc);
	kbUnitQuerySetMaximumDistance(enemyPointQuery, 50.0);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = kbUnitQueryExecute(enemyPointQuery);
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeFortFrontier);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 10.0 * kbUnitQueryExecute(enemyPointQuery);  // Each fort counts as 10 units
	
	kbUnitQuerySetUnitType(enemyPointQuery, gTownCenter);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // Each TC counts as 5 units
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeOutpost);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 3.0 * kbUnitQueryExecute(enemyPointQuery);  // Each tower counts as 3 units
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeBlockhouse);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 3.0 * kbUnitQueryExecute(enemyPointQuery);  // Each blockhouse counts as 3 units 
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeWarHut);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 3.0 * kbUnitQueryExecute(enemyPointQuery);  // Each war hut counts as 3 units 
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeNoblesHut);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // Each nobles hut counts as 5 units 
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort2);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort3);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort4);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypWIAgraFort5);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // An agra fort counts as 5 units 
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeypCastle);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // Each castle counts as 5 units 
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeYPOutpostAsian);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 3.0 * kbUnitQueryExecute(enemyPointQuery);  // Each Asian outpost counts as 3 units
	
	kbUnitQuerySetUnitType(enemyPointQuery, cUnitTypeTradingPost);
	kbUnitQueryResetResults(enemyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(enemyPointQuery);  // Each trading post counts as 5 units (Advanced TP suspected!)
	
	if (retVal < 1.0)
	retVal = 1.0;  // Return at least 1.
	return(retVal);
}

// Calculate an approximate strength rating for the allied units/buildings near this point.
float getPointAllyStrength(vector loc = cInvalidVector)
{
	float retVal = 0.0;
	static int allyPointQuery = -1;
	
	if (allyPointQuery < 0)
	{
		allyPointQuery = kbUnitQueryCreate("Ally Point query 2");
		kbUnitQuerySetIgnoreKnockedOutUnits(allyPointQuery, true);
		kbUnitQuerySetPlayerRelation(allyPointQuery, cPlayerRelationAlly);
		kbUnitQuerySetState(allyPointQuery, cUnitStateABQ);
		kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeLogicalTypeLandMilitary);
	}
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeLogicalTypeLandMilitary);
	kbUnitQuerySetPosition(allyPointQuery, loc);
	kbUnitQuerySetMaximumDistance(allyPointQuery, 50.0);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = kbUnitQueryExecute(allyPointQuery);
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeFortFrontier);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 10.0 * kbUnitQueryExecute(allyPointQuery);  // Each fort counts as 10 units
	
	kbUnitQuerySetUnitType(allyPointQuery, gTownCenter);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // Each TC counts as 5 units
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeOutpost);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each tower counts as 3 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeBlockhouse);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each blockhouse counts as 3 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeWarHut);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each war hut counts as 3 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeNoblesHut);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // Each nobles hut counts as 5 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort2);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort3);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort4);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypWIAgraFort5);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // An agra fort counts as 5 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeypCastle);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // Each castle counts as 5 units 
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeYPOutpostAsian);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 3.0 * kbUnitQueryExecute(allyPointQuery);  // Each Asian outpost counts as 3 units
	
	kbUnitQuerySetUnitType(allyPointQuery, cUnitTypeTradingPost);
	kbUnitQueryResetResults(allyPointQuery);
	retVal = retVal + 5.0 * kbUnitQueryExecute(allyPointQuery);  // Each trading post counts as 5 units (Advanced TP suspected!)
	
	if (retVal < 1.0)
	retVal = 1.0;  // Return at least 1.
	return(retVal);
}

// Calculate an approximate value for this base.
float getBaseValue(int baseID = -1)
{
	float retVal = 0.0;
	int owner = kbBaseGetOwner(baseID);
	int relation = -1;
	
	if (baseID < 0)
	return(-1.0);
	
	if (owner <= 0)
	return(-1.0);
	
	if (kbIsPlayerAlly(owner) == true)
	relation = cPlayerRelationAlly;
	else
	relation = cPlayerRelationEnemyNotGaia;
	
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeLogicalTypeBuildingsNotWalls));
	retVal = retVal + (1000.0 * kbBaseGetNumberUnits(owner, baseID, relation, gTownCenter));  // 1000 points extra per TC
	retVal = retVal + (600.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypePlantation));  // 600 points extra per plantation
	retVal = retVal + (2000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFortFrontier));  // 2000 points extra per fort
	retVal = retVal + (150.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeLogicalTypeLandMilitary)); // 150 points per soldier
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettler));  // 200 points per settler
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeCoureur));  // 200 points per coureur
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeCoureurCree));  // 200 points per cree coureur
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettlerNative));  // 200 points per native settler
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerAsian));  // 200 points per Asian settler
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerIndian));  // 200 points per Indian settler
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypSettlerJapanese));  // 200 points per Japanese settler
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettlerSwedish));  // 200 points per Swedish settler
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeSettlerWagon));  // 300 points per settler wagon
	retVal = retVal + (1000.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeTradingPost));  // 1000 points per trading post
	retVal = retVal + (800.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFactory));  // 800 points extra per factory
	retVal = retVal + (300.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeBank));  // 300 points extra per bank
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeMill));  // 200 points extra per mill
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeFarm));  // 200 points extra per farm
	retVal = retVal + (200.0 * kbBaseGetNumberUnits(owner, baseID, relation, cUnitTypeypRicePaddy));  // 200 points extra per rice paddy
	
	if (retVal < 1.0)
	retVal = 1.0;  // Return at least 1.
	return(retVal);
}

// Calculate an approximate value for the playerRelation units/buildings near this point.
// I.e. if playerRelation is enemy, calculate strength of enemy units and buildings.
float getPointValue(vector loc = cInvalidVector, int relation = cPlayerRelationEnemyNotGaia)
{
	float retVal = 0.0;
	static int allyQuery = -1;
	static int enemyQuery = -1;
	int queryID = -1; // Use either enemy or ally query as needed.
	
	if (allyQuery < 0)
	{
		allyQuery = kbUnitQueryCreate("Ally point value query");
		kbUnitQuerySetIgnoreKnockedOutUnits(allyQuery, true);
		kbUnitQuerySetPlayerRelation(allyQuery, cPlayerRelationAlly);
		kbUnitQuerySetState(allyQuery, cUnitStateABQ);
	}
	
	if (enemyQuery < 0)
	{
		enemyQuery = kbUnitQueryCreate("Enemy point value query");
		kbUnitQuerySetIgnoreKnockedOutUnits(enemyQuery, true);
		kbUnitQuerySetPlayerRelation(enemyQuery, cPlayerRelationEnemyNotGaia);
		kbUnitQuerySetSeeableOnly(enemyQuery, true);
		kbUnitQuerySetState(enemyQuery, cUnitStateAlive);
	}   
	
	if ( (relation == cPlayerRelationEnemy) || (relation == cPlayerRelationEnemyNotGaia) )
	queryID = enemyQuery;
	else
	queryID = allyQuery;
	
	kbUnitQueryResetResults(queryID);
	kbUnitQuerySetUnitType(queryID, cUnitTypeLogicalTypeBuildingsNotWalls);
	kbUnitQueryResetResults(queryID);
	retVal = 200.0 * kbUnitQueryExecute(queryID);   // 200 points per building
	
	kbUnitQuerySetUnitType(queryID, gTownCenter);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 1000.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per TC
	
	kbUnitQuerySetUnitType(queryID, cUnitTypeTradingPost);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 1000.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per trading post
	
	kbUnitQuerySetUnitType(queryID, cUnitTypeFactory);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 800.0 * kbUnitQueryExecute(queryID);  // Extra 800 per factory
	
	kbUnitQuerySetUnitType(queryID, cUnitTypePlantation);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 600.0 * kbUnitQueryExecute(queryID);  // Extra 600 per plantation
	
	kbUnitQuerySetUnitType(queryID, cUnitTypeBank);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 300.0 * kbUnitQueryExecute(queryID);  // Extra 300 per bank
	
	kbUnitQuerySetUnitType(queryID, cUnitTypeMill);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 200.0 * kbUnitQueryExecute(queryID);  // Extra 200 per mill
	
	kbUnitQuerySetUnitType(queryID, cUnitTypeFarm);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 200.0 * kbUnitQueryExecute(queryID);  // Extra 200 per farm
	
	kbUnitQuerySetUnitType(queryID, cUnitTypeypRicePaddy);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 200.0 * kbUnitQueryExecute(queryID);  // Extra 200 per rice paddy
	
	kbUnitQuerySetUnitType(queryID, cUnitTypeSPCXPMiningCamp);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 1000.0 * kbUnitQueryExecute(queryID);  // Extra 1000 per SPC mining camp for XPack scenario
	
	kbUnitQuerySetUnitType(queryID, cUnitTypeUnit);
	kbUnitQueryResetResults(queryID);
	retVal = retVal + 200.0 * kbUnitQueryExecute(queryID);  // 200 per unit.
	
	if (retVal < 1.0)
	retVal = 1.0;
	
	return(retVal);
}

//==============================================================================
// Called for each opportunity that needs to be scored.
//==============================================================================
extern int defendOppId = -1;
void scoreOpportunity(int oppID = -1)
{
	/*
		
		Sets all the scoring components for the opportunity, and a final score.  The scoring
		components and their meanings are:
		
		int PERMISSION  What level of permission is needed to do this?  
		cOpportunitySourceAutoGenerated is the lowest...go ahead and do it.
		cOpportunitySourceAllyRequest...the AI may not do it on its own, i.e. it may be against the rules for this difficulty.
		cOpportunitySourceTrigger...even ally requests are denied, as when prevented by control variables, but a trigger (gaia request) may do it.
		cOpportunitySourceTrigger+1...not allowed at all.
		
		float AFFORDABLE  Do I have what it takes to do this?  This includes appropriate army sizes, resources to pay for things (like trading posts)
		and required units like explorers.  0.80 indicates a neutral, good-to-go position.  1.0 means overstock, i.e. an army of 20 would be good, 
		and I have 35 units available.  0.5 means extreme shortfall, like the minimum you could possibly imagine.  0.0 means you simply can't do it,
		like no units at all.  Budget issues like amount of wood should never score below 0.5, scores below 0.5 mean deep, profound problems.
		
		int SOURCE  Who asked for this mission?  Uses the cOpportunitySource... constants above.
		
		float CLASS  How much do we want to do this type of mission?   Based on personality, how long it's been since the last mission of this type, etc.
		0.8 is a neutral, "this is a good mission" rating.  1.0 is extremely good, I really, really want to do this next.  0.5 is a poor score.  0.0 means 
		I just flat can't do it.  This class score will creep up over time for most classes, to make sure they get done once in a while.
		
		float INSTANCE  How good is this particular target?  Includes asset value (is it important to attack or defend this?) and distance.  Defense values
		are incorporated in the AFFORDABLE calculation above.  0.0 is no value, this target can't be attacked.  0.8 is a good solid target.  1.0 is a dream target.
		
		float TOTAL  Incorporates AFFORDABLE, CLASS and INSTANCE by multiplying them together, so a zero in any one sets total to zero.  Source is added as an int
		IF AND ONLY IF SOURCE >= PERMISSION.  If SOURCE < PERMISSION, the total is set to -1.  Otherwise, all ally source opportunities will outrank all self generated
		opportunities, and all trigger-generated opportunities will outrank both of those.  Since AFFORDABLE, CLASS and INSTANCE all aim for 0.8 as a good, solid
		par value, a total score of .5 is rougly "pretty good".  A score of 1.0 is nearly impossible and should be quite rare...a high-value target, weakly defended,
		while I have a huge army and the target is close to me and we haven't done one of those for a long, long time.  
		
		Total of 0.0 is an opportunity that should not be serviced.  >0 up to 1 indicates a self-generated opportunity, with 0.5 being decent, 1.0 a dream, and 0.2 kind
		of marginal.  Ally commands are in the range 1.0 to 2.0 (unless illegal), and triggers score 2.0 to 3.0.
		
	*/
   	
	// Interim values for the scoring components:
	int   permission = 0; 
	float instance = 0.0;
	float classRating = 0.0;
	float total = 0.0;
	float affordable = 0.0;
	float score = 0.0;
	
	// Info about this opportunity
	int   source = aiGetOpportunitySourceType(oppID);
	if (source < 0) 
	source = cOpportunitySourceAutoGenerated;
	if (source > cOpportunitySourceTrigger)
	source = cOpportunitySourceTrigger;
	int target = aiGetOpportunityTargetID(oppID);
	int targetType = aiGetOpportunityTargetType(oppID);
	int oppType = aiGetOpportunityType(oppID);
	int targetPlayer = aiGetOpportunityTargetPlayerID(oppID);
	vector location = aiGetOpportunityLocation(oppID);
	float radius = aiGetOpportunityRadius(oppID);
	if (radius < 40.0)
	radius = 40.0;
	int baseOwner = -1;
	float baseEnemyPower = 0.0;   // Used to measure troop and building strength.  Units roughly equal to unit count of army.
	float baseAllyPower = 0.0;    // Strength of allied buildings and units, roughly equal to unit count.
	float netEnemyPower = 0.0;    // Basically enemy minus ally, but the ally effect can, at most, cut 80% of enemy strength
	float baseAssets = 0.0;    // Rough estimate of base value, in aiCost.  
	float affordRatio = 0.0;
	bool  errorFound = false;  // Set true if we can't do a good score.  Ends up setting score to -1.
	
	// Variables for available number of units and plan to kill if any
	float armySizeAuto = 0.0;  // For source cOpportunitySourceAutoGenerated
	float armySizeAlly = 0.0;  // For ally-generated commands, how many units could we scrounge up?
	int missionToKillAlly = -1;   // Mission to cancel in order to provide the armySizeAlly number of units.  
	float armySizeTrigger = 0.0;  // For trigger-generated commands, how many units could we scrounge up?
	int missionToKillTrigger = -1;   // Mission to cancel in order to provide the armySizeTrigger number of units.
	float armySize = 0.0;      // The actual army size we'll use for calcs, depending on how big the target is.
	float missionToKill = -1;  // The actual mission to kill based on the army size we've selected.
	
	float oppDistance = 0.0;      // Distance to target location or base.
	bool  sameAreaGroup = true;   // Set false if opp is on another areagroup.
	
	bool defendingMonopoly = false;
	bool attackingMonopoly = false;
	int  tradePostID = -1;     // Set to trade post ID if this is a base target, and a trade post is nearby.
	
	bool defendingKOTH = false;
	bool attackingKOTH = false;
	int  KOTHID = -1;     // Set to the hill ID if this is a base target, and the hill is nearby.
	
	if (gIsMonopolyRunning == true)
	{
		if (gMonopolyTeam == kbGetPlayerTeam(cMyID))
		defendingMonopoly = true;  // We're defending, let's not go launching any attacks
		else
		attackingMonopoly = true;  // We're attacking, focus on trade posts
	}
	
	if (gIsKOTHRunning == true)
	{
		if (gKOTHTeam == kbGetPlayerTeam(cMyID))
		defendingKOTH = true;  // We're defending, let's not go launching any attacks
		else
		attackingKOTH = true;  // We're attacking, focus on the hill
	}
	
	//-- get the number of units in our reserve.
	armySizeAuto = aiPlanGetNumberUnits(gLandReservePlan, cUnitTypeLogicalTypeLandMilitary);
	armySizeAlly = armySizeAuto;
	armySizeTrigger = armySizeAlly;
	
	//   aiEcho(" ");
	//   aiEcho("Scoring opportunity "+oppID+", targetID "+target+", location "+location);
	
	// Get target info
	switch(targetType)
	{
		case cOpportunityTargetTypeBase:
		{
			location = kbBaseGetLocation(kbBaseGetOwner(target),target);
			tradePostID = getUnitByLocation(cUnitTypeTradingPost, kbBaseGetOwner(target), cUnitStateAlive, location, 40.0);   
			KOTHID = getUnitByLocation(cUnitTypeypKingsHill, kbBaseGetOwner(target), cUnitStateAlive);//, location, 40.0);   
			radius = 50.0;
			baseOwner = kbBaseGetOwner(target);
			baseEnemyPower = getBaseEnemyStrength(target);  // Calculate "defenses" as enemy units present
			baseAllyPower = getPointAllyStrength(kbBaseGetLocation(kbBaseGetOwner(target),target));
			if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
			else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
            
			baseAssets = getBaseValue(target);  //  Rough value of target
			if ( (gIsMonopolyRunning == true) && (tradePostID >= 0) )
            baseAssets = baseAssets + 10000; // Huge bump if this is a trade post (enemy or ally) and a monopoly is running            
			if ( (gIsKOTHRunning == true) && (KOTHID >= 0) )
            baseAssets = baseAssets + 10000; // Huge bump if this is the hill (enemy or ally) and a timer is running             
			break;
		}
		case cOpportunityTargetTypePointRadius:
		{
			baseEnemyPower = getPointEnemyStrength(location);
			baseAllyPower = getPointAllyStrength(location);
			if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
			else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
            
			baseAssets = getPointValue(location);  //  Rough value of target
			break;
		}
		case cOpportunityTargetTypeVPSite:     // This is only for CLAIM missions.  A VP site that is owned will be a 
		// defend or destroy opportunity.
		{
			location = kbVPSiteGetLocation(target);
			radius = 50.0;
			
			baseEnemyPower = getPointEnemyStrength(location);
			baseAllyPower = getPointAllyStrength(location);
			if ( (baseEnemyPower*0.8) > baseAllyPower)   
            netEnemyPower = baseEnemyPower - baseAllyPower;   // Ally power is less than 80% of enemy
			else
            netEnemyPower = baseEnemyPower * 0.2;  // Ally power is more then 80%, but leave a token enemy rating anyway.
			
			baseAssets = 2000.0;    // Arbitrary...consider a claimable VP Site as worth 2000 resources.
			break;
		}
	}
	
	if (netEnemyPower < 1.0)
	netEnemyPower = 1.0;   // Avoid div 0
	
	oppDistance = distance(location, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	if (oppDistance <= 0.0)
	oppDistance = 1.0;
	if ( kbAreaGroupGetIDByPosition(location) != kbAreaGroupGetIDByPosition(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) )
	sameAreaGroup = false;
	
	
	// Figure which armySize to use.  This currently is a placeholder, we may not need to mess with it.
	armySize = armySizeAuto;   // Default
	
	//   aiEcho("    EnemyPower "+baseEnemyPower+", AllyPower "+baseAllyPower+", NetEnemyPower "+netEnemyPower);
	//   aiEcho("    BaseAssets "+baseAssets+", myArmySize "+armySize);
	
	switch(oppType)
	{
		case cOpportunityTypeDestroy:
		{
			// Check permissions required.
			if(cvOkToAttack == false)
            permission = cOpportunitySourceTrigger;   // Only triggers can make us attack.
			
			if (gDelayAttacks == true)
            permission = cOpportunitySourceTrigger;   // Only triggers can override this difficulty setting.
			
			// Check affordability
			
			if (netEnemyPower < 0.0)
			{
				errorFound = true;
				affordable = 0.0;
			}
			else
			{
				// Set affordability.  Roughly armySize / baseEnemyPower, but broken into ranges.
				// 0.0 is no-can-do, i.e. no troops.  0.8 is "good", i.e. armySize is double baseEnemyPower.  
				// Above a 2.0 ratio, to 5.0, scale this into the 0.8 to 1.0 range.
				// Above 5.0, score it 1.0
				affordRatio = armySize / netEnemyPower;
				if (affordRatio < 2.0)
				affordable = affordRatio / 2.5;  // 0 -> 0.0,  2.0 -> 0.8
				else
				affordable = 0.8 + ((affordRatio - 2.0) / 15.0); // 2.0 -> 0.8 and 5.0 -> 1.0
				if (affordable > 1.0)
				affordable = 1.0;
			}  // Affordability is done
            
			// Check target value, calculate INSTANCE score.
			if (baseAssets < 0.0)
			{
				errorFound = true;
			}
			// Clip base value to range of 100 to 10K for scoring
			if (baseAssets < 100.0)
            baseAssets = 100.0;
			if (baseAssets > 10000.0)
            baseAssets = 10000.0;
			// Start with an "instance" score of 0 to .8 for bases under 2K value.
			instance = (0.8 * baseAssets) / 2000.0;
			// Over 2000, adjust so 2K = 0.8, 30K = 1.0
			if (baseAssets > 2000.0)
            instance = 0.8 + ( (0.2 * (baseAssets - 2000.0)) / 8000.0);
			
			// Instance is now 0..1, adjust for distance. If < 100m, leave as is.  Over 100m to 400m, penalize 10% per 100m.
			float penalty = 0.0;
			if (oppDistance > 100.0)
            penalty = (0.1 * (oppDistance - 100.0)) / 100.0;
			if (penalty > 0.6)
            penalty = 0.6;
			instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.
			if (sameAreaGroup = false)
            instance = instance / 2.0;
			if (targetType == cOpportunityTargetTypeBase)
            if (kbHasPlayerLost(baseOwner) == true)
			instance = -1.0;
			// Illegal if it's over water, i.e. a lone dock
			if (kbAreaGetType(kbAreaGetIDByPosition(location)) == cAreaTypeWater)
            instance = -1.0;
			
			// Check for weak target blocks, which means the content designer is telling us that this target needs its instance score bumped up
			int weakBlockCount = 0;
			int strongBlockCount = 0;
			if ( targetType == cOpportunityTargetTypeBase)
			{
				weakBlockCount = getUnitCountByLocation(cUnitTypeAITargetBlockWeak, cMyID, cUnitStateAlive, kbBaseGetLocation(baseOwner, target), 40.0);
				strongBlockCount = getUnitCountByLocation(cUnitTypeAITargetBlockStrong, cMyID, cUnitStateAlive, kbBaseGetLocation(baseOwner, target), 40.0);
			}
			if ( (targetType == cOpportunityTargetTypeBase) && (weakBlockCount > 0) && (instance >= 0.0) )
			{  // We have a valid instance score, and there is at least one weak block in the area.  For each weak block, move the instance score halfway to 1.0.
				while (weakBlockCount > 0)
				{
					instance = instance + ((1.0-instance) / 2.0);   // halfway up to 1.0
					weakBlockCount--;
				}
			}        
			
			classRating = getClassRating(cOpportunityTypeDestroy);   // 0 to 1.0 depending on how long it's been.
			if ( (gIsMonopolyRunning == true) && (tradePostID < 0) ) // Monopoly, and this is not a trade post site
            classRating = 0.0;
			
			if ( defendingMonopoly == true )
            classRating = 0.0;      // If defending, don't attack other targets
			
			if ( ( attackingMonopoly == true) && (tradePostID >= 0) )  // We're attacking, and this is an enemy trade post...go get it
            classRating = 1.0;
            
			if ( (gIsKOTHRunning == true) && (KOTHID < 0) ) // KOTH, and this is the hill
            classRating = 0.0;
			
			if ( defendingKOTH == true )
            classRating = 0.0;      // If defending, don't attack other targets
			
			if ( ( attackingKOTH == true) && (KOTHID >= 0) )  // We're attacking, and this is an enemy hill...go get it
            classRating = 1.0;
			
			if ( (targetType == cOpportunityTargetTypeBase) && (strongBlockCount > 0) && (classRating >= 0.0) )
			{  // We have a valid instance score, and there is at least one strong block in the area.  For each weak block, move the classRating score halfway to 1.0.
				while (strongBlockCount > 0)
				{
					classRating = classRating + ((1.0-classRating) / 2.0);   // halfway up to 1.0
					strongBlockCount--;
				}
			}
			
			if (aiTreatyActive() == true)
            classRating = 0.0;   // Do not attack anything if under treaty
			
			break;
		}
		case cOpportunityTypeClaim:
		{
			// Check permissions required.
			if( (cvOkToClaimTrade == false) && (kbVPSiteGetType(target) == cVPTrade))
            permission = cOpportunitySourceTrigger;   // Only triggers can let us override this.
			if( (cvOkToAllyNatives == false) && (kbVPSiteGetType(target) == cVPNative) )
            permission = cOpportunitySourceTrigger;   // Only triggers can let us override this.
			if (gDelayAttacks == true)     // Taking trade sites and natives is sort of aggressive, turn it off on easy/sandbox.
            permission = cOpportunitySourceTrigger;   // Only triggers can override this difficulty setting.
			
			// Check affordability.  50-50 weight on military affordability and econ affordability
			float milAfford = 0.0;
			float econAfford = 0.0;
			affordRatio = armySize / netEnemyPower;
            if (affordRatio < 2.0)
			milAfford = affordRatio / 2.5;  // 0 -> 0.0,  2.0 -> 0.8
            else
			milAfford = 0.8 + ((affordRatio - 2.0) / 15.0); // 2.0 -> 0.8 and 5.0 -> 1.0
            if (milAfford > 1.0)
			milAfford = 1.0; 
			affordRatio = (kbEscrowGetAmount(cRootEscrowID, cResourceWood) + kbEscrowGetAmount(cEconomyEscrowID, cResourceWood)) / (1.0 + kbUnitCostPerResource(cUnitTypeTradingPost, cResourceWood));
            if (affordRatio < 1.0)
			econAfford = affordRatio;
            else
			econAfford = 1.0;
            if (econAfford > 1.0)
			econAfford = 1.0;      
            if (econAfford < 0.0)
			econAfford = 0.0;
			affordable = (econAfford + milAfford) / 2.0; // Simple average
			
			// Instance
			instance = 0.8;   // Same for all, unless I prefer to do one type over other (personality)
			penalty = 0.0;
			if (oppDistance > 100.0)
            penalty = (0.1 * (oppDistance - 100.0)) / 100.0;
			if (penalty > 0.6)
            penalty = 0.6;
			instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.         
			if (sameAreaGroup = false)
            instance = instance / 2.0;
			classRating = getClassRating(cOpportunityTypeClaim, target);   // 0 to 1.0 depending on how long it's been.
			break;
		}
		case cOpportunityTypeRaid:
		{
			break;
		}
		case cOpportunityTypeDefend:
		{  		
			// Check affordability
			
			if (netEnemyPower < 0.0)
			{
				errorFound = true;
				affordable = 0.0;
			}
			else
			{
				defendOppId = oppID;
				// Set affordability.  Roughly armySize / netEnemyPower, but broken into ranges.
				// Very different than attack calculations.  Score high affordability if the ally is really 
				// in trouble, especially if my army is large.  Basically...does he need help?  Can I help?
				if (baseAllyPower < 1.0)
				baseAllyPower = 1.0;
				float enemyRatio = baseEnemyPower / baseAllyPower;
				float enemySurplus = baseEnemyPower - baseAllyPower;
				if (enemyRatio < 0.5)   // Enemy very weak, not a good opp.
				{
					affordRatio = enemyRatio;  // Low score, 0 to .5
					if (enemyRatio < 0.2)
					affordRatio = 0.0;
				}
				else
				affordRatio = 0.5 + ( (enemyRatio - 0.5) / 5.0);   // ratio 0.5 scores 0.5, ratio 3.0 scores 1.0
				if ( (affordRatio * 10.0) > enemySurplus )
				affordRatio = enemySurplus / 10.0;  // Cap the afford ratio at 1/10 the enemy surplus, i.e. don't respond if he's just outnumbered 6:5 or something trivial.
				if (enemySurplus < 0)
				affordRatio = 0.0;
				if (affordRatio > 1.0)
				affordRatio = 1.0;
				// AffordRatio now represents how badly I'm needed...now, can I make a difference
				if (armySize < enemySurplus)  // I'm gonna get my butt handed to me
				affordRatio = affordRatio * (armySize / enemySurplus);   // If I'm outnumbered 3:1, divide by 3.
				// otherwise, leave it alone.
				
				affordable = affordRatio;
			}  // Affordability is done
            
			// Check target value, calculate INSTANCE score.
			if (baseAssets < 0.0)
			{
				errorFound = true;
			}
			// Clip base value to range of 100 to 30K for scoring
			if (baseAssets < 100.0)
            baseAssets = 100.0;
			if (baseAssets > 30000.0)
            baseAssets = 30000.0;
			// Start with an "instance" score of 0 to .8 for bases under 2K value.
			instance = (0.8 * baseAssets) / 1000.0;
			// Over 1000, adjust so 1K = 0.8, 30K = 1.0
			if (baseAssets > 1000.0)
            instance = 0.8 + ( (0.2 * (baseAssets - 1000.0)) / 29000.0);
			
			// Instance is now 0..1, adjust for distance. If < 200m, leave as is.  Over 200m to 400m, penalize 10% per 100m.
			penalty = 0.0;
			if (oppDistance > 200.0)
            penalty = (0.1 * (oppDistance - 200.0)) / 100.0;
			if (penalty > 0.6)
            penalty = 0.6;
			instance = instance * (1.0 - penalty); // Apply distance penalty, INSTANCE score is done.
			if (sameAreaGroup == false)
            instance = 0.0;
			if (targetType == cOpportunityTargetTypeBase)
            if (kbHasPlayerLost(baseOwner) == true)
			instance = -1.0;
			
			if ( (defendingMonopoly == true) && (tradePostID >= 0) && (instance > 0.0))
            instance = instance + ((1.0 - instance)/1.2);   // Bump it almost up to 1.0 if we're defending monopoly and this is a trade site.
			if ( (defendingKOTH == true) && (KOTHID >= 0) && (instance > 0.0))
            instance = instance + ((1.0 - instance)/1.2);   // Bump it almost up to 1.0 if we're defending the hill
			classRating = getClassRating(cOpportunityTypeDefend);   // 0 to 1.0 depending on how long it's been.
			if ( (defendingMonopoly == true) && (tradePostID >= 0) ) 
            classRating = 1.0;      // No time delay for 2nd defend mission if we're defending trading posts during monopoly.
			if (attackingMonopoly == true) 
            classRating = 0.0;   // Don't defend anything if we should be attacking a monopoly!
			if ( (defendingKOTH == true) && (KOTHID >= 0) ) 
            classRating = 1.0;      // No time delay for 2nd defend mission if we're defending the hill.
			if (attackingKOTH == true) 
            classRating = 0.0;   // Don't defend anything if we should be attacking the hill!
			break;    
		}
		case cOpportunityTypeRescueExplorer:
		{
			break;
		}
		default:
		{
			//aiEcho("ERROR ERROR ERROR ERROR");
			//aiEcho("scoreOpportunity() failed on opportunity "+oppID);
			//aiEcho("Opportunity Type is "+oppType+" (invalid)");
			break;
		}
	}
	
	score = classRating * instance * affordable;
	//   aiEcho("    Class "+classRating+", Instance "+instance+", affordable "+affordable);
	//   aiEcho("    Final Score: "+score);
	
	switch(oppType)
	{
		case cOpportunityTypeDestroy:  // Aggressive AIs attack more often
		{
			score = score + (0.2 * btOffenseDefense); // If -0.5 -> score - 0.1. If -1.0 -> score - 0.2. If 0.5 -> score + 0.1. If 1.0 -> score + 0.2
		}
	}
	switch(oppType)
	{
		case cOpportunityTypeDefend:  // Defensive AIs defend ally bases
		{
			score = score + (0.2 * btOffenseDefense); // If -0.5 -> score + 0.1. If -1.0 -> score + 0.2. If 0.5 -> score - 0.1. If 1.0 -> score - 0.2
		}
	}
	switch(oppType)
	{
		case cOpportunityTypeClaim:  // Claiming AIs build more Trading Posts
		{
			if (kbVPSiteGetType(target) == cVPTrade) 
			{
				score = score + (0.2 * btBiasTrade); // If -0.5 -> score - 0.1. If -1.0 -> score - 0.2. If 0.5 -> score + 0.1. If 1.0 -> score + 0.2
			}
			if (kbVPSiteGetType(target) == cVPNative) 
			{
				score = score + (0.2 * btBiasNative); // If -0.5 -> score - 0.1. If -1.0 -> score - 0.2. If 0.5 -> score + 0.1. If 1.0 -> score + 0.2
			}
		}
	}
	
	if (score > 1.0)
	score = 1.0;
	if (score < 0.0)
	score = 0.0;
	
	score = score + source; // Add 1 if from ally, 2 if from trigger.
	
	if (permission > source)
	score = -1.0;
	if (errorFound == true)
	score = -1.0;
	if (cvOkToSelectMissions == false)
	score = -1.0;
	
	//updatedOn 2019/05/06 By ageekhere  
	//---------------------------
	//Do not build a cVPTrade or cVPNative untill you have 2 towncenters
	/*
		if ((kbVPSiteGetType(target) == cVPTrade || kbVPSiteGetType(target) == cVPNative) && kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 2) score = -1.0;
		if ((kbVPSiteGetType(target) == cVPTrade || kbVPSiteGetType(target) == cVPNative) && kbGetAge() >= cAge4) 
		{
		score = 1.0;
		permission = 0;
		}
		//check for enemy before building a VP
		if (kbVPSiteGetType(target) == cVPTrade || kbVPSiteGetType(target) == cVPNative)
		{
		int enemyUnit = kbUnitQueryCreate("enemyUnit");
		kbUnitQuerySetPlayerRelation(enemyUnit,cPlayerRelationEnemyNotGaia);
		kbUnitQuerySetUnitType(enemyUnit, cUnitTypeMilitary);
		kbUnitQuerySetPosition(enemyUnit, kbVPSiteGetLocation(target) ); //set the location
		kbUnitQuerySetMaximumDistance(enemyUnit, 25);
		kbUnitQuerySetIgnoreKnockedOutUnits(enemyUnit, true);
		kbUnitQuerySetState(enemyUnit, cUnitStateAlive);
		
		int enemyBuilding = kbUnitQueryCreate("enemyBuilding");
		kbUnitQuerySetPlayerRelation(enemyBuilding,cPlayerRelationEnemyNotGaia);
		kbUnitQuerySetUnitType(enemyBuilding, cUnitTypeBuilding);
		kbUnitQuerySetPosition(enemyBuilding, kbVPSiteGetLocation(target) ); //set the location
		kbUnitQuerySetMaximumDistance(enemyBuilding, 25);
		kbUnitQuerySetIgnoreKnockedOutUnits(enemyBuilding, true);
		kbUnitQuerySetState(enemyBuilding, cUnitStateAlive);
		
		if(kbUnitQueryExecute(enemyUnit) > 5 || kbUnitQueryExecute(enemyBuilding) > 0) 
		{
		score = -1.0;//return;
		}
		
		
		}
	*/
	//---------------------------
	aiSetOpportunityScore(oppID, permission, affordable, classRating, instance, score);
}

//==============================================================================
// Personality and chats
//==============================================================================

rule introChat    // Send a greeting to allies and enemies
inactive
group startup
minInterval 10
{
	xsDisableSelf();
	sendStatement(cPlayerRelationAlly, cAICommPromptToAllyIntro); 
	sendStatement(cPlayerRelationEnemy, cAICommPromptToEnemyIntro);
}

rule IKnowWhereYouLive  // Send a menacing chat when we discover the enemy player's location
inactive
group startup
minInterval 5
{
	static int targetPlayer = -1;
	
	if (targetPlayer < 0)
	{
		targetPlayer = getEnemyPlayerByTeamPosition(getTeamPosition(cMyID));    // Corresponding player on other team
		if (targetPlayer < 0)
		{
			xsDisableSelf();
			//aiEcho("No corresponding player on other team, IKnowWhereYouLive is deactivating.");
			//aiEcho("    My team position is "+getTeamPosition(cMyID));
			return;
		}
		//aiEcho("Rule IKnowWhereYouLive will threaten player #"+targetPlayer); 
	}
	
	if (kbUnitCount(targetPlayer, gTownCenter, cUnitStateAlive) > 0) 
	{  // We see his TC for the first time
		int tc = getUnit(gTownCenter, targetPlayer, cUnitStateAlive);
		if ( tc >= 0)
		{
			if ( getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tc), 50.0) >= 0 )
			{  // I have a unit nearby, presumably I have LOS.
				sendStatement(targetPlayer, cAICommPromptToEnemyISpotHisTC, kbUnitGetPosition(tc)); 
				//aiEcho("Rule IKnowWhereYouLive is threatening player #"+targetPlayer);
			}
		}
		xsDisableSelf();
	}
}

rule tcChats
inactive
group tcComplete
minInterval 10
{  // Send chats about enemy TC placement
	static int tcID1 = -1;  // First enemy TC
	static int tcID2 = -1;  // Second
	static int enemy1 = -1; // ID of owner of first enemy TC.
	static int enemy2 = -1; // Second.
	static int secondTCQuery = -1;
	
	if (tcID1 < 0)
	{  // Look for first enemy TC
		tcID1 = getUnit(gTownCenter, cPlayerRelationEnemy, cUnitStateAlive);
		if (tcID1 >= 0)
		enemy1 = kbUnitGetPlayerID(tcID1);
		return;  // Done for now
	}
	
	// If we get here, we already know about one enemy TC.  Now, find the next closest enemy TC.
	if (secondTCQuery < 0)
	{  //init - find all enemy TC's within 200 meters of first one.
		secondTCQuery = kbUnitQueryCreate("Second enemy TC");
	}
	kbUnitQuerySetPlayerRelation(secondTCQuery, cPlayerRelationEnemy);
	kbUnitQuerySetUnitType(secondTCQuery, gTownCenter);
	kbUnitQuerySetState(secondTCQuery, cUnitStateAlive);
	kbUnitQuerySetPosition(secondTCQuery, kbUnitGetPosition(tcID1));
	kbUnitQuerySetMaximumDistance(secondTCQuery, 500.0);
	
	kbUnitQueryResetResults(secondTCQuery);
	int tcCount = kbUnitQueryExecute(secondTCQuery);
	if (tcCount > 1)  // Found another enemy TC
	{
		tcID2 = kbUnitQueryGetResult(secondTCQuery, 1); // Second unit in list
		enemy2 = kbUnitGetPlayerID(tcID2);
	}
	
	if (tcID2 < 0)
	return;
	
	// We have two TCs.  See if we have a unit in range.  If so, send a taunt if appropriate.  Either way, shut the rule off.
	xsDisableSelf();
	
	if (enemy1 == enemy2)
	return;  // Makes no sense to taunt if the same player owns both...
	
	bool haveLOS = false;
	if (getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tcID1), 50.0) >= 0)
	haveLOS = true;
	if (getUnitByLocation(cUnitTypeUnit, cMyID, cUnitStateAlive, kbUnitGetPosition(tcID2), 50.0) >= 0)
	haveLOS = true;
	
	if (haveLOS == true)
	{
		float d = distance(kbUnitGetPosition(tcID1), kbUnitGetPosition(tcID2));
		if (d < 100.0)
		{  // Close together.  Taunt the two, flaring the other's bases.
			//aiEcho("Enemy TCs are "+d+" meters apart.  Taunting for closeness.");
			sendStatement(enemy1, cAICommPromptToEnemyHisTCNearAlly, kbUnitGetPosition(tcID2)); // Taunt enemy 1 about enemy 2's TC
			sendStatement(enemy2, cAICommPromptToEnemyHisTCNearAlly, kbUnitGetPosition(tcID1)); // Taunt enemy 2 about enemy 1's TC
		}
		if (d > 200.0)
		{  // Far apart.  Taunt.
			//aiEcho("Enemy TCs are "+d+" meters apart.  Taunting for isolation.");
			sendStatement(enemy1, cAICommPromptToEnemyHisTCIsolated, kbUnitGetPosition(tcID2)); // Taunt enemy 1 about enemy 2's TC
			sendStatement(enemy2, cAICommPromptToEnemyHisTCIsolated, kbUnitGetPosition(tcID1)); // Taunt enemy 2 about enemy 1's TC         
		}
		//aiEcho("Enemy TCs are "+d+" meters apart.");
	}  // Otherwise, rule is turned off, we missed our chance.   
	else
	{
		aiEcho("Had no LOS to enemy TCs");
	}
}

rule monitorScores
inactive
minInterval 60
group tcComplete
{
	static int startingScores = -1;  // Array holding initial scores for each player
	static int highScores = -1;      // Array, each player's high-score mark
	static int teamScores = -1;
	int player = -1;
	int teamSize = 0;
	int myTeam = kbGetPlayerTeam(cMyID);
	int enemyTeam = -1;
	int highAllyScore = -1;
	int highAllyPlayer = -1;
	int highEnemyScore = -1;
	int highEnemyPlayer = -1;
	int score = -1;
	int firstHumanAlly = -1;
	
	if (aiGetGameType() != cGameTypeRandom)
	{
		xsDisableSelf();
		return;
	}
	
	if (highScores < 0)
	{
		highScores = xsArrayCreateInt(cNumberPlayers, 1, "High Scores");   // create array, init below.
	}
	if (startingScores < 0)
	{
		if (aiGetNumberTeams() != 3)  // Gaia, plus two
		{
			// Only do this if there are two teams with the same number of players on each team.
			xsDisableSelf();
			return;
		}
		startingScores = xsArrayCreateInt(cNumberPlayers, 1, "Starting Scores");   // init array
		for (player = 1; <cNumberPlayers)
		{
			score = aiGetScore(player);            
			//aiEcho("Starting score for player "+player+" is "+score);
			xsArraySetInt(startingScores, player, score);
			xsArraySetInt(highScores, player, 0);     // High scores will track score actual - starting score, to handle deathmatch better.
		}
	}
	
	teamSize = 0;
	for (player = 1; <cNumberPlayers)
	{
		if (kbGetPlayerTeam(player) == myTeam)
		{
			teamSize = teamSize + 1;
			if ( (kbIsPlayerHuman(player) == true) && (firstHumanAlly < 1) )
            firstHumanAlly = player;
		}
		else
		enemyTeam = kbGetPlayerTeam(player);   // Don't know if team numbers are 0..1 or 1..2, this works either way.
	}
	
	if ( (2 * teamSize) != (cNumberPlayers - 1) )   // Teams aren't equal size
	{
		xsDisableSelf();
		return;
	}
	
	// If we got this far, there are two teams and each has 'teamSize' players.  Otherwise, rule turns off.
	if (teamScores < 0)
	{
		teamScores = xsArrayCreateInt(3, 0, "Team total scores");
	}
	
	if (firstHumanAlly < 0) // No point if we don't have a human ally.
	{
		xsDisableSelf();
		return;
	}
	
	// Update team totals, check for new high scores
	xsArraySetInt(teamScores, myTeam, 0);
	xsArraySetInt(teamScores, enemyTeam, 0);
	highAllyScore = -1;
	highEnemyScore = -1;
	highAllyPlayer = -1;
	highEnemyPlayer = -1;
	int lowestRemainingScore = 100000;   // Very high, will be reset by first real score 
	int lowestRemainingPlayer = -1;
	int highestScore = -1;
	int highestPlayer = -1;
	
	for (player = 1; <cNumberPlayers)
	{
		score = aiGetScore(player) - xsArrayGetInt(startingScores, player);  // Actual score relative to initial score
		if (kbHasPlayerLost(player) == true)
		continue;
		if (score < lowestRemainingScore)
		{
			lowestRemainingScore = score;
			lowestRemainingPlayer = player;
		}
		if (score > highestScore)
		{
			highestScore = score;
			highestPlayer = player;
		}
		if (score > xsArrayGetInt(highScores, player) )   
		xsArraySetInt(highScores, player, score);   // Set personal high score
		if (kbGetPlayerTeam(player) == myTeam)    // Update team scores, check for highs
		{
			xsArraySetInt(teamScores, myTeam, xsArrayGetInt(teamScores, myTeam) + score);
			if (score > highAllyScore)
			{
				highAllyScore = score;
				highAllyPlayer = player;
			}
		}
		else
		{
			xsArraySetInt(teamScores, enemyTeam, xsArrayGetInt(teamScores, enemyTeam) + score);
			if (score > highEnemyScore)
			{
				highEnemyScore = score;
				highEnemyPlayer = player;
			}
		}
	}
	
	// Bools used to indicate chat usage, prevent re-use.
	static bool enemyNearlyDead = false;
	static bool enemyStrong = false;
	static bool losingEnemyStrong = false;
	static bool losingEnemyWeak = false;
	static bool losingAllyStrong = false;
	static bool losingAllyWeak = false;
	static bool winningNormal = false;
	static bool winningAllyStrong = false;
	static bool winningAllyWeak = false;
	
	static int shouldResignCount = 0;   // Set to 1, 2 and 3 as chats are used.
	static int shouldResignLastTime = 420000;   // When did I last suggest resigning?  Consider it again 3 min later.          
	// Defaults to 7 min, so first suggestion won't be until 10 minutes.
	
	// Attempt to fire chats, from most specific to most general.
	// When we chat, mark that one used and exit for now, i.e no more than one chat per rule execution.
	
	// First, check the winning / losing / tie situations.  
	// Bail if earlier than 12 minutes
	if (xsGetTime() < 60*1000*12)
	return;
	
	if (aiTreatyActive() == true)
	return;
	
	bool winning = false;
	bool losing = false;
	losingDigin = false;
	float ourAverageScore = (aiGetScore(cMyID) + aiGetScore(firstHumanAlly)) / 2.0;   
	
	if ( xsArrayGetInt(teamScores, myTeam) > (1.20 * xsArrayGetInt(teamScores, enemyTeam)) )
	{  // We are winning
		winning = true;
		
		// Are we winning because my ally rocks?
		if ( (winningAllyStrong == false) && (firstHumanAlly == highestPlayer) )
		{
			winningAllyStrong = true;
			sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinningHeIsStronger);
			return;
		}
		
		// Are we winning in spite of my weak ally?
		if ( (winningAllyWeak == false) && (cMyID == highestPlayer) )
		{
			winningAllyWeak = true;
			sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinningHeIsWeaker);
			return;
		}     
		
		// OK, we're winning, but neither of us has high score.
		if (winningNormal == false)
		{
			winningNormal = true;
			sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreWinning);
			return;
		}
	}  // End chats while we're winning.
	
	
	if ( xsArrayGetInt(teamScores, myTeam) < (0.70 * xsArrayGetInt(teamScores, enemyTeam)) )
	{  // We are losing
		losing = true;
		losingDigin = true;
		
		// Talk about resigning?
		if ( (shouldResignCount < 3) && ( (xsGetTime() - shouldResignLastTime) > 3*60*1000) )  // Haven't done it 3 times or within 3 minutes
		{
			switch(shouldResignCount)
			{
				case 0:
				{
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign1);
					break;
				}
				case 1:
				{
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign2);
					break;
				}
				case 2:
				{
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeShouldResign3);
					break;
				}
			}
			shouldResignCount = shouldResignCount + 1;
			shouldResignLastTime = xsGetTime();
			return;
		}  // End resign
		
		// Check for "we are losing but let's kill the weakling"
		if ( (losingEnemyWeak == false) && (kbIsPlayerEnemy(lowestRemainingPlayer) == true) )
		{
			switch(kbGetCivForPlayer(lowestRemainingPlayer))
			{
				case cCivRussians:
				{
					losingEnemyWeak = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakRussian);
					return;  
					break;
				}
				case cCivFrench:
				{
					losingEnemyWeak = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakFrench);
					return;
					break;
				}
				case cCivGermans:
				{
					losingEnemyWeak = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakGerman);
					return;  
					break;
				}
				case cCivBritish:
				{
					losingEnemyWeak = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakBritish);
					return;
					break;
				}
				case cCivSpanish:
				{
					losingEnemyWeak = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakSpanish);
					return;  
					break;
				}
				case cCivDutch:
				{
					losingEnemyWeak = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakDutch);
					return;
					break;
				}
				case cCivPortuguese:
				{
					losingEnemyWeak = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakPortuguese);
					return;  
					break;
				}
				case cCivOttomans:
				{
					losingEnemyWeak = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakOttoman);
					return;
					break;
				}
				case cCivJapanese:
				{
					if (civIsAsian() == true) {
						losingEnemyWeak = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakJapanese);
						return;
						break;
					}
				}
				case cCivChinese:
				{
					if (civIsAsian() == true) {
						losingEnemyWeak = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakChinese);
						return;
						break;
					}
				}
				case cCivIndians:
				{
					if (civIsAsian() == true) {
						losingEnemyWeak = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyWeakIndian);
						return;
						break;
					}
				}
				
			}
		}
		
		// Check for losing while enemy player has high score.
		if ( (losingEnemyStrong == false) && (kbIsPlayerEnemy(highestPlayer) == true) )
		{
			switch(kbGetCivForPlayer(highestPlayer))
			{
				case cCivRussians:
				{
					losingEnemyStrong = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongRussian);
					return;  
					break;
				}
				case cCivFrench:
				{
					losingEnemyStrong = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongFrench);
					return;
					break;
				}
				case cCivGermans:
				{
					losingEnemyStrong = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongGerman);
					return;  
					break;
				}
				case cCivBritish:
				{
					losingEnemyStrong = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongBritish);
					return;
					break;
				}
				case cCivSpanish:
				{
					losingEnemyStrong = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongSpanish);
					return;  
					break;
				}
				case cCivDutch:
				{
					losingEnemyStrong = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongDutch);
					return;
					break;
				}
				case cCivPortuguese:
				{
					losingEnemyStrong = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongPortuguese);
					return;  
					break;
				}
				case cCivOttomans:
				{
					losingEnemyStrong = true; // chat used.
					sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongOttoman);
					return;
					break;
				}
				case cCivJapanese:
				{
					if (civIsAsian() == true) {
						losingEnemyStrong = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongJapanese);
						return;
						break;
					}
				}
				case cCivChinese:
				{
					if (civIsAsian() == true) {
						losingEnemyStrong = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongChinese);
						return;
						break;
					}
				}
				case cCivIndians:
				{
					if (civIsAsian() == true) {
						losingEnemyStrong = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingEnemyStrongIndian);
						return;
						break;
					}
				}
			}
		}
		
		// If we're here, we're losing but our team has the high score.  If it's my ally, we're losing because I suck.
		if ( (losingAllyStrong == false) && (firstHumanAlly == highestPlayer) )
		{
			losingAllyStrong = true;
			sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingHeIsStronger);
			return;
		}
		if ( (losingAllyWeak == false) && (cMyID == highestPlayer) )
		{
			losingAllyWeak = true;
			sendStatement(firstHumanAlly, cAICommPromptToAllyWeAreLosingHeIsWeaker);
			return;
		}      
	}  // End chats while we're losing.
	
	if ( (winning == false) && (losing == false) )
	{  // Close game
		
		// Check for a near-death enemy
		if ( (enemyNearlyDead == false) && (kbIsPlayerEnemy(lowestRemainingPlayer) == true) )// Haven't used this chat yet
		{
			if ( (lowestRemainingScore * 2) < xsArrayGetInt(highScores, lowestRemainingPlayer) )   // He's down to half his high score.
			{
				switch(kbGetCivForPlayer(lowestRemainingPlayer))
				{
					case cCivRussians:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadRussian);
						return;  
						break;
					}
					case cCivFrench:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadFrench);
						return;
						break;
					}
					case cCivBritish:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadBritish);
						return;
						break;
					}
					case cCivSpanish:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadSpanish);
						return;
						break;
					}
					case cCivGermans:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadGerman);
						return;
						break;
					}
					case cCivOttomans:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadOttoman);
						return;
						break;
					}
					case cCivDutch:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadDutch);
						return;
						break;
					}
					case cCivPortuguese:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadPortuguese);
						return;
						break;
					}
					case cCivJapanese:
					{
						if (civIsAsian() == true) {
							enemyNearlyDead = true; // chat used.
							sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadJapanese);
							return;
							break;
						}
					}
					case cCivChinese:
					{
						if (civIsAsian() == true) {
							enemyNearlyDead = true; // chat used.
							sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadChinese);
							return;
							break;
						}
					}
					case cCivIndians:
					{
						if (civIsAsian() == true) {
							enemyNearlyDead = true; // chat used.
							sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyNearlyDeadIndian);
							return;
							break;
						}
					}
				}
			}
		}
		
		// Check for very strong enemy
		if ( (enemyStrong == false) && (kbIsPlayerEnemy(highestPlayer) == true) )
		{
			if ( (ourAverageScore * 1.5) < highestScore) 
			{  // Enemy has high score, it's at least 50% above our average.
				switch(kbGetCivForPlayer(highestPlayer))
				{
					case cCivRussians:
					{
						enemyStrong = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongRussian);
						return;  
						break;
					}
					case cCivFrench:
					{
						enemyStrong = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongFrench);
						return;
						break;
					}
					case cCivBritish:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongBritish);
						return;
						break;
					}
					case cCivSpanish:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongSpanish);
						return;
						break;
					}
					case cCivGermans:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongGerman);
						return;
						break;
					}
					case cCivOttomans:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongOttoman);
						return;
						break;
					}
					case cCivDutch:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongDutch);
						return;
						break;
					}
					case cCivPortuguese:
					{
						enemyNearlyDead = true; // chat used.
						sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongPortuguese);
						return;
						break;
					}
					case cCivJapanese:
					{
						if (civIsAsian() == true) {
							enemyNearlyDead = true; // chat used.
							sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongJapanese);
							return;
							break;
						}
					}
					case cCivChinese:
					{
						if (civIsAsian() == true) {
							enemyNearlyDead = true; // chat used.
							sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongChinese);
							return;
							break;
						}
					}
					case cCivIndians:
					{
						if (civIsAsian() == true) {
							enemyNearlyDead = true; // chat used.
							sendStatement(firstHumanAlly, cAICommPromptToAllyEnemyStrongIndian);
							return;
							break;
						}
					}
				}
			}
		}        
	}  // End chats for close game 
}

rule firstEnemyUnitSpotted
inactive
group startup
minInterval 5
{
	static int targetPlayer = -1;
	
	if (targetPlayer < 0)
	{
		targetPlayer = getEnemyPlayerByTeamPosition(getTeamPosition(cMyID));    // Corresponding player on other team
		if (targetPlayer < 0)
		{
			xsDisableSelf();
			//aiEcho("No corresponding player on other team, firstEnemyUnitSpotted is deactivating.");
			//aiEcho("    My team position is "+getTeamPosition(cMyID));
			return;
		}
		//aiEcho("Rule firstEnemyUnitSpotted will watch for player #"+targetPlayer); 
	}
	
	if (kbUnitCount(targetPlayer, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive) > 0) 
	{  // We see one of this player's units for the first time...let's do some analysis on it
		int unitID = getUnit(cUnitTypeLogicalTypeLandMilitary, targetPlayer, cUnitStateAlive); // Get the (or one of the) enemy units
		if (unitID < 0)
		{
			//aiEcho("kbUnitCount said there are enemies, but getUnit finds nothing.");
			return;
		}
		
		//aiEcho("Enemy unit spotted at "+kbUnitGetPosition(unitID));
		//aiEcho("My base is at "+kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
		//aiEcho("Distance is "+distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(unitID)));
		//aiEcho("Unit ID is "+unitID);
		// Three tests in priority order....anything near my town, an explorer anywhere, or default.
		// In my town?
		if ( distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(unitID)) < 60.0 )
		{
			sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisFirstMilitaryMyTown, kbUnitGetPosition(unitID));
			//aiEcho("Spotted a unit near my town, so I'm threatening player #"+targetPlayer);
			xsDisableSelf();         
			return;
		}
		// Is it an explorer?
		if ( kbUnitIsType(unitID, cUnitTypeExplorer) == true )
		{
			sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisExplorerFirstTime, kbUnitGetPosition(unitID));
			//aiEcho("Spotted an enemy explorer, so I'm threatening player #"+targetPlayer);
			xsDisableSelf();         
			return;
		}
		// Generic
		if (getUnitByLocation(gTownCenter, cPlayerRelationAny, cUnitStateAlive, kbUnitGetPosition(unitID), 70.0) < 0)   
		{  // No TCs nearby
			sendStatement(targetPlayer, cAICommPromptToEnemyISeeHisFirstMilitary, kbUnitGetPosition(unitID));
			//aiEcho("Spotted an enemy military unit for the first time, so I'm threatening player #"+targetPlayer);
		}
		xsDisableSelf();         
		return;
	}
}

rule waitForStartup
inactive
minInterval 1
{
	if (kbUnitCount(cMyID, cUnitTypeAIStart, cUnitStateAny) < 1) return;
	xsDisableSelf();
	
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0)
	{
		//aiEcho("Start mode:  Scenario TC.");
		gStartMode = cStartModeScenarioTC;
	}
	else
	{
		if (kbUnitCount(cMyID, gCoveredWagonUnit, cUnitStateAlive) > 0)
		{
			//aiEcho("Start mode:  Scenario wagon.");
			gStartMode = cStartModeScenarioWagon;
		}
		else
		{
			//aiEcho("Start mode:  Scenario, no TC.");
			gStartMode = cStartModeScenarioNoTC;
		}
	}
	if (cvInactiveAI == false) transportArrive();
}

void testHandler(int parm=-1)
{
	aiEcho("StateChanged EventHandlerCalled with PlanID " + parm);
}


//==============================================================================
// RULE fillInWallGaps
//==============================================================================
rule fillInWallGaps
minInterval 30
inactive
{
	if(baseRelocateEver == true || kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) == 0) return;
	if (gBuildWalls == false)
	{
		xsDisableSelf();
		return;
	}
	//If we already have a build wall plan, don't make another one.
	if (aiPlanGetIDByTypeAndVariableType(cPlanBuildWall, cBuildWallPlanWallType, cBuildWallPlanWallTypeRing, true) >= 0)
	return;
	
	int wallPlanID = aiPlanCreate("FillInWallGaps", cPlanBuildWall);
	//updatedOn 2019/03/29 By ageekhere  
	//---------------------------
	if (wallPlanID != -1)
	{
		if (wallPosition == cInvalidVector) wallPosition = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
		aiPlanSetVariableInt(wallPlanID, cBuildWallPlanWallType, 0, cBuildWallPlanWallTypeRing);
		aiPlanAddUnitType(wallPlanID, gEconUnit, 1, 1, 1);
		aiPlanSetVariableVector(wallPlanID, cBuildWallPlanWallRingCenterPoint, 0, wallPosition);
		aiPlanSetVariableFloat(wallPlanID, cBuildWallPlanWallRingRadius, 0, wallSize);
		aiPlanSetVariableInt(wallPlanID, cBuildWallPlanNumberOfGates, 0, 8);
		aiPlanSetBaseID(wallPlanID, kbBaseGetMainID(cMyID));
		aiPlanSetEscrowID(wallPlanID, cEconomyEscrowID);
		aiPlanSetDesiredPriority(wallPlanID, 40);
		aiPlanSetActive(wallPlanID, true);
	}
	//---------------------------
}

void monopolyStartHandler(int teamID=-1)
{
	//aiEcho("     ");
	//aiEcho("     ");
	//aiEcho("     ");
	//aiEcho("MonopolyStartHandler:  Team "+teamID);
	if (teamID < 0)
	return;
	
	// If this is my team, congratulate teammates and taunt enemies
	if ( kbGetPlayerTeam(cMyID) == teamID)
	{
		sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenWeGetMonopoly, cInvalidVector);
		sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyWhenWeGetMonopoly, cInvalidVector);
	}
	else // Otherwise, snide comment to enemies and condolences to partners
	{
		sendStatement(cPlayerRelationAlly, cAICommPromptToAllyWhenEnemiesGetMonopoly, cInvalidVector);
		sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyWhenTheyGetMonopoly, cInvalidVector);
	}      
	gIsMonopolyRunning = true;
	gMonopolyTeam = teamID;
	gMonopolyEndTime = xsGetTime() + 5*60*1000; 
	xsEnableRule("monopolyTimer");
}

void monopolyEndHandler(int teamID=-1)
{
	//aiEcho("     ");
	//aiEcho("     ");
	///aiEcho("     ");
	//aiEcho("MonopolyEndHandler:  Team "+teamID);
	if (teamID < 0)
	return;
	// If this is my team, console partners, and send defiant message to enemies
	if ( kbGetPlayerTeam(cMyID) == teamID)
	{
		sendStatement(cPlayerRelationAlly, cAICommPromptToAllyEnemyDestroyedMonopoly, cInvalidVector);
		sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyTheyDestroyedMonopoly, cInvalidVector);
	}
	else // Otherwise, gloat at enemies
	{
		sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemyIDestroyedMonopoly, cInvalidVector);
	}         
	gIsMonopolyRunning = false;
	gMonopolyTeam = -1;
	gMonopolyEndTime = -1;
	xsDisableRule("monopolyTimer");
}

rule monopolyTimer
inactive
minInterval 5
{
	if ((gIsMonopolyRunning == false) || (gMonopolyEndTime < 0))
	{
		xsDisableSelf();
		return;
	}
	if (xsGetTime() > gMonopolyEndTime)
	{
		// If this is my team, congratulate teammates and taunt enemies
		if ( kbGetPlayerTeam(cMyID) == gMonopolyTeam)
		{
			sendStatement(cPlayerRelationAlly, cAICommPromptToAlly1MinuteLeftOurMonopoly, cInvalidVector);
			sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemy1MinuteLeftOurMonopoly, cInvalidVector);
		}
		else // Otherwise, snide comment to enemies and panic to partners
		{
			sendStatement(cPlayerRelationAlly, cAICommPromptToAlly1MinuteLeftEnemyMonopoly, cInvalidVector);
			sendStatement(cPlayerRelationEnemyNotGaia, cAICommPromptToEnemy1MinuteLeftEnemyMonopoly, cInvalidVector);
		}       
		xsDisableSelf();
		return;
	}
}

rule monopolyManager
minInterval 21
inactive
group tcComplete
{
	if (aiTreatyActive() == true)
	{
		//aiEcho("    Monopoly delayed because treaty is active.");
		return;
	}
	if ( aiIsMonopolyAllowed() == false )
	{
		//aiEcho("    Monopoly not allowed, terminating rule.");
		xsDisableSelf();
	}
	if ( kbUnitCount(cMyID, cUnitTypeTradingPost, cUnitStateAlive) < 1)
	return;     // Not allowed to research without a building...
	
	if( aiReadyForTradeMonopoly() == true)
	{
		//aiEcho("      Trade monopoly is available.");
		if (kbResourceGet(cResourceGold) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceGold) && 
			kbResourceGet(cResourceFood) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceFood) &&
			kbResourceGet(cResourceWood) >= kbTechCostPerResource(cTechTradeMonopoly, cResourceWood)
		)
		{
			//aiEcho("    Attempting trade monopoly");
			if (aiDoTradeMonopoly() == true)
            kbEscrowAllocateCurrentResources();
		}
		else
		{
			aiEcho("    ....but I can't afford it.");
		}
	}
}

void KOTHVictoryStartHandler(int teamID=-1)
{
	int newOppID = -1;
	
	//aiEcho("     ");
	//aiEcho("     ");
	//aiEcho("     ");
	//aiEcho("KOTHStartHandler:  Team "+teamID);
	if (teamID < 0)
	return;
	
	gIsKOTHRunning = true;
	gKOTHTeam = teamID;
}

void KOTHVictoryEndHandler(int teamID=-1)
{
	//aiEcho("     ");
	//aiEcho("     ");
	//aiEcho("     ");
	//aiEcho("KOTHEndHandler:  Team "+teamID);
	if (teamID < 0)
	return;
	
	gIsKOTHRunning = false;
	gKOTHTeam = -1;
}


//==============================================================================
// New rules for the Draugur AI
//==============================================================================

//==============================================================================
// scoutMonitor
// updatedOn 2020/03/06
//==============================================================================
rule scoutMonitor
active
minInterval 10
{ //make scouts for scouting
	int scoutUnit = -1; //scout unit
	int scoutAvailable = -1; //scout available	
	scoutAvailable = kbProtoUnitAvailable(cUnitTypeEnvoy); //check Envoy unit
	if(scoutAvailable == 1) scoutUnit = cUnitTypeEnvoy; //set scout
	if(scoutAvailable == 0)
	{
		scoutAvailable = kbProtoUnitAvailable(cUnitTypeNativeScout); //check Native unit
		if(scoutAvailable == 1) scoutUnit = cUnitTypeNativeScout; 
	}
	if(scoutAvailable == 0)
	{
		scoutAvailable = kbProtoUnitAvailable(cUnitTypeypMongolScout); //check Mongol unit
		if(scoutAvailable == 1) scoutUnit = cUnitTypeypMongolScout; 
	}
	int scoutCount = 1;//kbGetBuildLimit(cMyID, scoutUnit); //get max build limit
	switch(kbGetAge())
	{ //set limit per age
		case cAge1:{scoutCount = 1; break;}
		case cAge2:{scoutCount = 2; break;}
		case cAge3:{scoutCount = 0; break;}
		case cAge4:{scoutCount = 0; break;}
		case cAge5:{scoutCount = 0; break;}
	} //end switch
	if (kbUnitCount(cMyID, scoutUnit, cUnitStateABQ) < scoutCount && kbUnitCount(cMyID, gEconUnit, cUnitStateABQ) > 5 ) aiTaskUnitTrain(getUnit(gTownCenter), scoutUnit); //train when under limit
	static int scoutExplore = -1;
	if(scoutExplore == -1)
	{ // Create explore plan for each scout
		for(i = 0; < kbGetBuildLimit(cMyID, scoutUnit))
		{ //for each envo
			scoutExplore = aiPlanCreate("Envoy Explore", cPlanExplore);
			aiPlanSetDesiredPriority(scoutExplore, 100);
			aiPlanAddUnitType(scoutExplore, scoutUnit, 1, 1, 1);
			aiPlanSetEscrowID(scoutExplore, cEconomyEscrowID);
			aiPlanSetBaseID(scoutExplore, kbBaseGetMainID(cMyID));
			aiPlanSetVariableBool(scoutExplore, cExplorePlanDoLoops, 0, false);
			aiPlanSetActive(scoutExplore);
		}//end for
	} //end if     
} //end envoyMonitor

rule envoyMonitor
inactive
minInterval 10
{
	xsDisableSelf(); 
	return;
	static int envoyPlan = -1;
	
	// Create maintain plan
	if (envoyPlan < 0)
	{
		envoyPlan = createSimpleMaintainPlan(cUnitTypeEnvoy, 1, false, kbBaseGetMainID(cMyID));
	}
	
	// Create explore plan
	int envoyExplore = aiPlanCreate("Envoy Explore", cPlanExplore);
	aiPlanSetDesiredPriority(envoyExplore, 99);
	aiPlanAddUnitType(envoyExplore, cUnitTypeEnvoy, 1, 1, 1);
	aiPlanSetEscrowID(envoyExplore, cEconomyEscrowID);
	aiPlanSetBaseID(envoyExplore, kbBaseGetMainID(cMyID));
	aiPlanSetVariableBool(envoyExplore, cExplorePlanDoLoops, 0, false);
	aiPlanSetActive(envoyExplore);
	
	// Disable rule
	xsDisableSelf();      
}

rule nativeScoutMonitor
active
minInterval 10
{
	xsDisableSelf(); 
	return;
	static int nativeScoutPlan = -1;
	
	// Create maintain plan
	if (nativeScoutPlan < 0)
	{
		nativeScoutPlan = createSimpleMaintainPlan(cUnitTypeNativeScout, 1, false, kbBaseGetMainID(cMyID));
	}
	
	// Create explore plan
	int nativeExplore = aiPlanCreate("Native Explore", cPlanExplore);
	aiPlanSetDesiredPriority(nativeExplore, 99);
	aiPlanAddUnitType(nativeExplore, cUnitTypeNativeScout, 1, 1, 1);
	aiPlanSetEscrowID(nativeExplore, cEconomyEscrowID);
	aiPlanSetBaseID(nativeExplore, kbBaseGetMainID(cMyID));
	aiPlanSetVariableBool(nativeExplore, cExplorePlanDoLoops, 0, false);
	aiPlanSetActive(nativeExplore);
	
	// Disable rule
	xsDisableSelf();      
}

rule mongolScoutMonitor
inactive
minInterval 10
{
	xsDisableSelf(); 
	return;
	static int mongolPlan = -1;
	
	// Create maintain plan
	if (mongolPlan < 0)
	{
		mongolPlan = createSimpleMaintainPlan(cUnitTypeypMongolScout, 1, false, kbBaseGetMainID(cMyID));
	}
	
	// Create explore plan
	int mongolExplore = aiPlanCreate("Mongol Explore", cPlanExplore);
	aiPlanSetDesiredPriority(mongolExplore, 99);
	aiPlanAddUnitType(mongolExplore, cUnitTypeypMongolScout, 1, 1, 1);
	aiPlanSetEscrowID(mongolExplore, cEconomyEscrowID);
	aiPlanSetBaseID(mongolExplore, kbBaseGetMainID(cMyID));
	aiPlanSetVariableBool(mongolExplore, cExplorePlanDoLoops, 0, false);
	aiPlanSetActive(mongolExplore);
	
	// Disable rule
	xsDisableSelf();      
}

rule churchUpgradeMonitor
inactive
minInterval 60
{
	int upgradePlanID = -1;
	
	// Disable rule for native or Asian civs
	if ((civIsNative() == true) || (civIsAsian() == true))
	{
		xsDisableSelf();
		return;
	}
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechChurchTownWatch) == cTechStatusActive) &&
		(kbTechGetStatus(cTechChurchGasLighting) == cTechStatusActive) &&
		(kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusActive) &&
	(kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Get upgrades one at a time as they become available
	if (kbTechGetStatus(cTechChurchTownWatch) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTownWatch);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChurchTownWatch, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGasLighting);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChurchGasLighting, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMassCavalry);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChurchMassCavalry, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStandingArmy);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChurchStandingArmy, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
		return;
	}
}

rule churchUpgradeAsianMonitor
inactive
minInterval 60
{
	int upgradePlanID = -1;
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechChurchTownWatch) == cTechStatusActive) &&
		(kbTechGetStatus(cTechChurchGasLighting) == cTechStatusActive) &&
		(kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusActive) &&
	(kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there is no special church built from a wagon araound
	if (kbUnitCount(cMyID, cUnitTypeypChurch, cUnitStateAlive) < 1)
	{
		return;
	}
	
	// Get upgrades one at a time as they become available
	if (kbTechGetStatus(cTechChurchTownWatch) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTownWatch);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChurchTownWatch, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechChurchGasLighting) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGasLighting);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChurchGasLighting, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechChurchMassCavalry) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchMassCavalry);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChurchMassCavalry, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechChurchStandingArmy) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStandingArmy);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChurchStandingArmy, getUnit(cUnitTypeypChurch), cMilitaryEscrowID, 50);
		return;
	}
}

rule royalDecreeMonitor
inactive
minInterval 45
{
	int decreePlanID = -1;
	
	// Disable rule for native or Asian civs
	if ((civIsNative() == true) || (civIsAsian() == true))
	{
		xsDisableSelf();
		return;
	}
	
	switch(kbGetCiv())
	{
		case cCivBritish:
		{
			// Disable rule once all upgrades are available
			if ((kbTechGetStatus(cTechChurchThinRedLine) == cTechStatusActive) &&
				(kbTechGetStatus(cTechChurchBlackWatch) == cTechStatusActive) &&
			(kbTechGetStatus(cTechChurchRogersRangers) == cTechStatusActive))
			{
				xsDisableSelf();
				return;
			}
			
			// Get upgrades/troops as they become available
			if (kbTechGetStatus(cTechChurchThinRedLine) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchThinRedLine);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchThinRedLine, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchBlackWatch) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBlackWatch);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchBlackWatch, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchRogersRangers) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchRogersRangers);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchRogersRangers, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			break;
		}
		case cCivDutch:
		{
			// Disable rule once all upgrades are available
			if ((kbTechGetStatus(cTechChurchCoffeeTrade) == cTechStatusActive) &&
				(kbTechGetStatus(cTechChurchWaardgelders) == cTechStatusActive) &&
			(kbTechGetStatus(cTechChurchStadholders) == cTechStatusActive))
			{
				xsDisableSelf();
				return;
			}
			
			// Get upgrades/troops as they become available
			if (kbTechGetStatus(cTechChurchCoffeeTrade) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCoffeeTrade);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchCoffeeTrade, getUnit(cUnitTypeChurch), cEconomyEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchWaardgelders) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWaardgelders);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchWaardgelders, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchStadholders) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchStadholders);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchStadholders, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			break;
		}
		case cCivFrench:
		{
			// Disable rule once all upgrades are available
			if ((kbTechGetStatus(cTechChurchCodeNapoleon) == cTechStatusActive) &&
				(kbTechGetStatus(cTechChurchGardeImperial1) == cTechStatusActive) &&
				(kbTechGetStatus(cTechChurchGardeImperial2) == cTechStatusActive) &&
			(kbTechGetStatus(cTechChurchGardeImperial3) == cTechStatusActive))
			{
				xsDisableSelf();
				return;
			}
			
			// Get upgrades/troops as they become available
			if ((kbTechGetStatus(cTechChurchCodeNapoleon) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCodeNapoleon);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchCodeNapoleon, getUnit(cUnitTypeChurch), cEconomyEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchGardeImperial1) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial1);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchGardeImperial1, getUnit(cUnitTypeChurch), cEconomyEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchGardeImperial2) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial2);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchGardeImperial2, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchGardeImperial3) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchGardeImperial3);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchGardeImperial3, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			break;
		}
		case cCivGermans:
		{
			// Disable rule once all upgrades are available
			if ((kbTechGetStatus(cTechChurchTillysDiscipline) == cTechStatusActive) &&
			(kbTechGetStatus(cTechChurchZweihander) == cTechStatusActive))
			{
				xsDisableSelf();
				return;
			}
			
			// Get upgrades/troops as they become available
			if (kbTechGetStatus(cTechChurchTillysDiscipline) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTillysDiscipline);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchTillysDiscipline, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchZweihander) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchZweihander);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchZweihander, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			break;
		}
		case cCivOttomans:
		{
			// Disable rule once all upgrades are available
			if ((kbTechGetStatus(cTechChurchTufanciCorps) == cTechStatusActive) &&
			(kbTechGetStatus(cTechChurchTopcuCorps) == cTechStatusActive))
			{
				xsDisableSelf();
				return;
			}
			
			// Get upgrades/troops as they become available
			if (kbTechGetStatus(cTechChurchTufanciCorps) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTufanciCorps);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchTufanciCorps, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchTopcuCorps) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTopcuCorps);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchTopcuCorps, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			break;
		}
		case cCivPortuguese:
		{
			// Disable rule once all upgrades are available
			if ((kbTechGetStatus(cTechChurchBestieros) == cTechStatusActive) &&
			(kbTechGetStatus(cTechChurchTowerAndSword) == cTechStatusActive))
			{
				xsDisableSelf();
				return;
			}
			
			// Get upgrades/troops as they become available
			if (kbTechGetStatus(cTechChurchBestieros) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBestieros);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchBestieros, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchTowerAndSword) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchTowerAndSword);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchTowerAndSword, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			break;
		}
		case cCivRussians:
		{
			// Disable rule once all upgrades are available
			if ((kbTechGetStatus(cTechChurchWesternization) == cTechStatusActive) &&
				(kbTechGetStatus(cTechChurchPetrineReforms) == cTechStatusActive) &&
				(kbTechGetStatus(cTechChurchKalmucks) == cTechStatusActive) &&
			(kbTechGetStatus(cTechChurchBashkirPonies) == cTechStatusActive))
			{
				xsDisableSelf();
				return;
			}
			
			// Get upgrades/troops as they become available
			if (kbTechGetStatus(cTechChurchWesternization) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWesternization);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchWesternization, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchPetrineReforms) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchPetrineReforms);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchPetrineReforms, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchKalmucks) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchKalmucks);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchKalmucks, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchBashkirPonies) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchBashkirPonies);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchBashkirPonies, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			break;
		}
		case cCivSpanish:
		{
			// Disable rule once all upgrades are available
			if ((kbTechGetStatus(cTechChurchCorsolet) == cTechStatusActive) &&
				(kbTechGetStatus(cTechChurchQuatrefage) == cTechStatusActive) &&
			(kbTechGetStatus(cTechChurchWildGeeseSpanish) == cTechStatusActive))
			{
				xsDisableSelf();
				return;
			}
			
			// Get upgrades/troops as they become available
			if (kbTechGetStatus(cTechChurchCorsolet) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchCorsolet);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchCorsolet, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchQuatrefage) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchQuatrefage);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchQuatrefage, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			if (kbTechGetStatus(cTechChurchWildGeeseSpanish) == cTechStatusObtainable)
			{
				decreePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChurchWildGeeseSpanish);
				if (decreePlanID >= 0)
				aiPlanDestroy(decreePlanID);
				createSimpleResearchPlan(cTechChurchWildGeeseSpanish, getUnit(cUnitTypeChurch), cMilitaryEscrowID, 50);
			}
			break;
		}
	}
}

rule rescueExplorer
inactive
minInterval 60
{
	static int rescuePlan = -1;
	
	// Disable rule for native civs
	if (civIsNative() == true)
	{
		xsDisableSelf();
		return;
	}
	
	// Destroy old rescue plan (if any)
	if (rescuePlan >= 0)
	{
		aiPlanDestroy(rescuePlan);
		rescuePlan = -1;
		//aiEcho("Killing old rescue plan");
	}
	
	// Use only in Age 2 and above
	if ((kbGetAge() < cAge2) || (aiGetFallenExplorerID() < 0))
	{
		//aiEcho("No explorer to rescue");
		return;
	}
	
	// Use only when explorer is strong enough
	if (kbUnitGetHealth(aiGetFallenExplorerID()) < 0.3)
	{
		//aiEcho("Explorer too weak to be rescued");
		return;
	}
	
	// Decide on which unit type to use for rescue attempt
	// If possible, converted guardians or cheap infantry units are used
	int scoutType = -1;
	if (kbUnitCount(cMyID, cUnitTypeGuardian, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeGuardian;
	else if (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeCrossbowman;
	else if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypePikeman;
	else if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeStrelet;
	else if (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeLongbowman;
	else if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeMusketeer;
	else if (kbUnitCount(cMyID, cUnitTypexpWarrior, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarrior;
	else if (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpAenna;
	else if (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpTomahawk;
	else if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpMacehualtin;
	else if (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpPumaMan;
	else if (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarBow;
	else if (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 1)
	scoutType = cUnitTypexpWarClub;
	else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawPistol, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeSaloonOutlawPistol;
	else if (kbUnitCount(cMyID, cUnitTypeSaloonOutlawRifleman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeSaloonOutlawRifleman;
	else if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeJanissary;
	else if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypQiangPikeman;
	else if (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypChuKoNu;
	else if (kbUnitCount(cMyID, cUnitTypeypMonkDisciple, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypMonkDisciple;
	else if (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypArquebusier;
	else if (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypChangdao;
	else if (kbUnitCount(cMyID, cUnitTypeypSepoy, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypSepoy;
	else if (kbUnitCount(cMyID, cUnitTypeypNatMercGurkha, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypNatMercGurkha;
	else if (kbUnitCount(cMyID, cUnitTypeypRajput, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypRajput;
	else if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypYumi;
	else if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypAshigaru;
	else if (kbUnitCount(cMyID, cUnitTypeEnvoy, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeEnvoy;
	else if (kbUnitCount(cMyID, cUnitTypeNativeScout, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeNativeScout;
	else if (kbUnitCount(cMyID, cUnitTypeypMongolScout, cUnitStateAlive) >= 1)
	scoutType = cUnitTypeypMongolScout;
	else
	scoutType = cUnitTypeLogicalTypeValidSharpshoot;
	
	
	// Get position of fallen explorer and send scout unit there
	vector fallenExplorerLocation = kbUnitGetPosition(aiGetFallenExplorerID());
	rescuePlan = aiPlanCreate("Rescue Explorer", cPlanExplore);
	if (rescuePlan >= 0)
	{
		aiPlanAddUnitType(rescuePlan, scoutType, 1, 1, 1);
		aiPlanAddWaypoint(rescuePlan, fallenExplorerLocation);
		aiPlanSetVariableBool(rescuePlan, cExplorePlanDoLoops, 0, false);
		aiPlanSetVariableBool(rescuePlan, cExplorePlanAvoidingAttackedAreas, 0, false);
		aiPlanSetVariableInt(rescuePlan, cExplorePlanNumberOfLoops, 0, -1);
		aiPlanSetRequiresAllNeedUnits(rescuePlan, true);
		aiPlanSetDesiredPriority(rescuePlan, 42);
		aiPlanSetActive(rescuePlan);
		//aiEcho("Trying to rescue explorer");
	}
}

rule defendBase
inactive
group tcComplete
minInterval 60
{
	static int baseDefendPlan = -1;
	int baseDefensePop = 0;
	int ownMilitaryCount = 0;
	
	// Number of units for base defend plan, 25% of army
	ownMilitaryCount = kbUnitCount(cMyID, cUnitTypeLogicalTypeLandMilitary, cUnitStateAlive);
	if (ownMilitaryCount > 0)
	{
		baseDefensePop = ownMilitaryCount / 4;
	}
	else
	{
		baseDefensePop = 0;
	}
	
	switch (gForwardBaseState)
	{
		case cForwardBaseStateNone:
		{
			if (baseDefendPlan >= 0)
			{
				aiPlanDestroy(baseDefendPlan);
				baseDefendPlan = 0;
				//aiEcho("Forward base destroyed, additional defend plan deleted");
			}
			else
			{
				aiEcho("No forward base found, no additional defend plan for main base");
			}
			break;
		}
		case cForwardBaseStateActive:
		{
			if (baseDefendPlan < 0)
			{
				baseDefendPlan = aiPlanCreate("Base Defend", cPlanDefend);
				aiPlanAddUnitType(baseDefendPlan, cUnitTypeLogicalTypeLandMilitary , baseDefensePop, baseDefensePop, baseDefensePop); 
				
				aiPlanSetVariableVector(baseDefendPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
				aiPlanSetVariableFloat(baseDefendPlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
				aiPlanSetVariableFloat(baseDefendPlan, cDefendPlanGatherDistance, 0, cvDefenseReflexRadiusActive - 10.0);
				aiPlanSetVariableBool(baseDefendPlan, cDefendPlanPatrol, 0, false);
				aiPlanSetVariableFloat(baseDefendPlan, cDefendPlanGatherDistance, 0, 20.0);
				aiPlanSetInitialPosition(baseDefendPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
				aiPlanSetUnitStance(baseDefendPlan, cUnitStanceDefensive);
				aiPlanSetVariableInt(baseDefendPlan, cDefendPlanRefreshFrequency, 0, 5);
				aiPlanSetVariableInt(baseDefendPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);
				aiPlanSetDesiredPriority(baseDefendPlan, 95);  // High priority to keep units from being drafted into attack plans
				aiPlanSetActive(baseDefendPlan); 
				//aiEcho("Creating base defend plan, "+baseDefensePop+" units assigned");
			}
			else
			{
				aiPlanAddUnitType(baseDefendPlan, cUnitTypeLogicalTypeLandMilitary , baseDefensePop, baseDefensePop, baseDefensePop); 
				//aiEcho("Updating base defend plan, "+baseDefensePop+" units assigned");
			}
			break;
		}
		default: // cForwardBaseStateBuilding
		{
			//aiEcho("Forward base being built, wait with additional defend plan for main base");
			break;
		}
	}
	
	//xsEnableRule("call_levies");
}

//==============================================================================
// tradeRouteFinder
/*
Stores all the trade post socket sites into there correct trade roots	
*/
// updatedOn 2021/06/25 By ageekhere
//==============================================================================
extern int tradeRoot1 = -1; //Trade Root 1 Array
extern int tradeRoot2 = -1; //Trade Root 2 Array
extern int tradeRoomCheckNumber = 2; //Trade Root 2 Array
extern int tradeRootArrayLength = 11; //Trade Root 2 Array
extern bool tradeRouteFinderDone = false; //Finder done
rule tradeRouteFinder
active
minInterval 2
{ //Finds all the trade post sockets
	kbLookAtAllUnitsOnMap(); //Needed for seeing all the trade post sockets
		if (cRandomMapName == "silkroad") 
	{
		xsDisableSelf();
		return;
	}																							 
	if (kbUnitCount(0, cUnitTypeTravois, cUnitStateAlive) == 0)
	{ //Check if the map has any Travois
		xsDisableSelf();
		return;
	} //end if
	static bool inarray = false; //A check to see if VP site is in an array
	static int numberFound = -1; //Number of Travois found
	static int travoisQuery = -1; //The id holder for Travois
	static int travoisID = -1; //The Trade Query ID
	static int tradeRootNum = -1; //Current trade root
	static int socketCount = 0; //Count number of trade root sockets
	static int VPadded = 0; //Couting Added VP sites
	static int socketQuery = -1; //socket Query
	static int socketID = -1; //VP id 	
	if (tradeRoot1 == -1)
	{ //Create a new Array for holding all the VP sites for each root
		tradeRoot1 = xsArrayCreateInt(tradeRootArrayLength, -1, "Trade root 1 sockets"); //Trade root 1
		tradeRoot2 = xsArrayCreateInt(tradeRootArrayLength, -1, "Trade root 2 sockets"); //Trade root 2
	} //end if
	if (socketQuery == -1)
	{ //new socket Query
		socketQuery = kbUnitQueryCreate("socketQuery"); //Create a new TradePost Socket unit Query
		kbUnitQuerySetPlayerID(socketQuery, 0); //set player to 0
		kbUnitQuerySetUnitType(socketQuery, cUnitTypeTradePostSocket); //find unit
		kbUnitQuerySetState(socketQuery, cUnitStateAny); //set state
		//kbUnitQueryResetResults(socketQuery); //reset the results
		for (j = 0; < kbUnitQueryExecute(socketQuery))
		{ //Loop through all the sockets	
			//socketID = kbUnitQueryGetResult(socketQuery, j); //get socket ID
			if (kbGetProtoUnitName(kbUnitGetProtoUnitID(kbUnitQueryGetResult(socketQuery, j))) == "SocketTradeRoute") socketCount++; //Check if the socket has a name of SocketTradeRoute and update the socket count
		} //end for j
	} //end if
	if (travoisQuery == -1) travoisQuery = kbUnitQueryCreate("travoisQuery"); //Create a new Travois unit Query
	kbUnitQuerySetPlayerID(travoisQuery, 0); //set player to 0
	kbUnitQuerySetUnitType(travoisQuery, cUnitTypeTravois); //find unit
	kbUnitQuerySetState(travoisQuery, cUnitStateAny); //set state
	kbUnitQueryResetResults(travoisQuery); //reset the results
	numberFound = kbUnitQueryExecute(travoisQuery); //store the number found, each unit should be a new root
	for (i = 0; < kbUnitQueryExecute(travoisQuery))
	{ //Loop through all the found Travois 		
		travoisID = kbUnitQueryGetResult(travoisQuery, i); //get the id of the Travois
		if (kbUnitGetPosition(travoisID) == cInvalidVector) continue; //Check if the Travois has a vaild location		
		for (j = 0; < kbUnitQueryExecute(socketQuery))
		{ //Loop through all the socket sites	
			inarray = false; //Set the inarray flag
			socketID = kbUnitQueryGetResult(socketQuery, j); //get the id of the socket
			if (kbGetProtoUnitName(kbUnitGetProtoUnitID(socketID)) != "SocketTradeRoute") continue; //Check if the socket has a name of SocketTradeRoute
			if (distance(kbUnitGetPosition(travoisID), kbUnitGetPosition(socketID)) < 30)
			{ //Check if the distance of the travois and socket is less then 30
				for (k = 0; < numberFound)
				{ //Loop through all the Travois
					if (k == 0) tradeRootNum = tradeRoot1; //Socket site will be added to root 1
					if (k == 1) tradeRootNum = tradeRoot2; //Socket site will be added to root 2
					if (i == k)
					{ //Assign root
						for (l = 0; < xsArrayGetSize(tradeRootNum))
						{ //Loop through the trade root array
							if (xsArrayGetInt(tradeRootNum, l) == socketID)
							{ //Check if the socket site is allready in the Array 
								inarray = true; //Yes it is in the array
								break;
							} //end if	
						} //end for
						if (inarray == false)
						{ //Check to see if the socket site should be added to the array
							for (m = 0; < xsArrayGetSize(tradeRootNum))
							{ //Loop through the trade root array
								if (xsArrayGetInt(tradeRootNum, m) == -1)
								{ //Check for a blank spot
									//aiChat(1, "added to " + tradeRootNum + " vp id " + socketID + " m " + m + "position " + kbUnitGetPosition(socketID));
									xsArraySetInt(tradeRootNum, m, socketID); //add socket id to trade root array
									VPadded++; //Up the add counter
									break;
								} //end if
							} //end for k
						} //end if
					} //end if
				} //end for m
			} //end if			
		} //enf for j	
	} //end for i		
	if (VPadded == socketCount || xsGetTime() > 600000)
	{ //Check if all sockets have been added to the array, there is a timer if something goes wrong
		tradeRouteFinderDone = true; //Done
		xsDisableSelf(); //Disable the rule when the added count is == to the number of VP sites
	} //end if
} //end tradeRouteFinder

//==============================================================================
// tradeRouteUpgradeMonitor
/*
Monitors Trading Post Site and researches upgrades when appropriate. 
NOTES
1. Need to test when a trade post is destroyed while it is upgrading/researching does it kill the plan
2. more logic is needed for when there is more than 1 ai upgrading the same trade root
*/
// updatedOn 2021/06/25 By ageekhere
//==============================================================================
rule tradeRouteUpgradeMonitor
inactive
group tcComplete
minInterval 60
{
	if (tradeRouteFinderDone == false || kbGetAge() < cAge2) return;
	static int tradeRouteUpgradePlan1ID = -1; //stores the Trade Route Plan ID 
	static int tradeRouteUpgradePlan2ID = -1; //stores the Trade Route Plan ID 
	static int tradeRouteUpgradePlanID = -1; //stores the Trade Route Plan ID 
	static int tradeRouteUpgradeTechID = -1; //stores the Trade Route Tech ID 
	static int ownTPList = -1; //stores the VP Site Query ID
	static int tradeRouteUpgradeUnitID = -1; //stores the Trade Route Upgrade Unit ID
	static vector siteLocation1 = cInvalidVector; //stoes the site locaiton
	static vector siteLocation2 = cInvalidVector; //stoes the site locaiton
	static int tradeRouteUpgrade1Type = -1; //level 1 TradeRouteUpgrade1 
	static int tradeRouteUpgrade2Type = -1; //level 2 TradeRouteUpgrade1 
	//static int socketID = -1;
	static vector siteLocation = cInvalidVector;
	static bool disableRoot1 = false;
	static bool disableRoot2 = false;
	static int upgradeCountRoot1 = 0;
	static int upgradeCountRoot2 = 0;
	static int upgradeTechRoot1 = -1;
	static int upgradeTechRoot2 = -1;
	static int ownTradePost = -1;
	static int techUpgradeType1 = -1;
	static int techUpgradeType2 = -1;
	static bool emptyTradeRoot = false;
	static int rootId = -1;
	if (upgradeTechRoot1 == -1)
	{ //set the current root Tech upgrade and iron horse upgrade	
		if (kbTechGetStatus(cTechTradeRouteUpgrade1) == 1)
		{ //Check Tech status
			upgradeTechRoot1 = cTechTradeRouteUpgrade1; //root 1
			upgradeTechRoot2 = cTechTradeRouteUpgrade1; //root 2
			techUpgradeType1 = cTechTradeRouteUpgrade1; //Tech upgrade 1
			techUpgradeType2 = cTechTradeRouteUpgrade2; //Tech upgrade 2
		} //end if
		else if (kbTechGetStatus(cTechypTradeRouteUpgrade1) == 1)
		{ //Check Tech status
			upgradeTechRoot1 = cTechypTradeRouteUpgrade1; //root 1
			upgradeTechRoot2 = cTechypTradeRouteUpgrade1; //root 2
			techUpgradeType1 = cTechypTradeRouteUpgrade1; //Tech upgrade 1
			techUpgradeType2 = cTechypTradeRouteUpgrade2; //Tech upgrade 2
		} //end else if
		else if (kbTechGetStatus(cTechypTradeRouteUpgradeIndia1) == 1)
		{ //Check Tech status
			upgradeTechRoot1 = cTechypTradeRouteUpgradeIndia1; //root 1
			upgradeTechRoot2 = cTechypTradeRouteUpgradeIndia1; //root 2
			techUpgradeType1 = cTechypTradeRouteUpgradeIndia1; //Tech upgrade 1
			techUpgradeType2 = cTechypTradeRouteUpgradeIndia2; //Tech upgrade 2
		} //end else if
		else
		{ //error
			aiEcho("Debug: Cannot find Trade Route Upgrade 1 Tech  Time " + xsGetTime());
		} //end else
		for (i = 0; < tradeRoomCheckNumber)
		{ //Check for empty Trade Roots
			emptyTradeRoot = true; //reset 
			if (i == 0) rootId = tradeRoot1; //root 1
			else rootId = tradeRoot2; //root 2
			for (j = 0; < xsArrayGetSize(rootId))
			{ //Loop through root array
				if (xsArrayGetInt(rootId, j) != -1)
				{ //trade root found
					emptyTradeRoot = false; //not empty
					break;
				} //end if
			} //end for j
			if (emptyTradeRoot == true)
			{ //was it empty
				if (i == 0) disableRoot1 = true; //disable root 1
				else disableRoot2 = true; //disable root 2
			} //end if
		} //end for i
	} //end if
	siteLocation = cInvalidVector; //default site location
	siteLocation1 = cInvalidVector; //site location root 1
	siteLocation2 = cInvalidVector; //site location root 2
	if (ownTradePost == -1) ownTradePost = kbUnitQueryCreate("ownTradePost"); //Create a new Trade unit Query
	kbUnitQuerySetPlayerID(ownTradePost, cMyID); //set player
	kbUnitQuerySetUnitType(ownTradePost, cUnitTypeTradingPost); //find unit
	kbUnitQuerySetState(ownTradePost, cUnitStateAlive); //set state
	kbUnitQueryResetResults(ownTradePost); //reset the results
	for (i = 0; < kbUnitQueryExecute(ownTradePost))
	{ //Loop through all the own Tradingpost
		//socketID = kbUnitQueryGetResult(ownTradePost, i); //get id of TP
		if (kbUnitGetPosition(kbUnitQueryGetResult(ownTradePost, i)) == cInvalidVector) continue; //check if location is a valid location, may be not be needed
		for (j = 0; < xsArrayGetSize(tradeRoot1))
		{ //Loop through tradeRoot1 Array
			if (xsArrayGetInt(tradeRoot1, j) == -1 || kbUnitGetPosition(xsArrayGetInt(tradeRoot1, j)) == cInvalidVector) continue; //check for invaild ID and location of tradeRoot1
			if (distance(kbUnitGetPosition(xsArrayGetInt(tradeRoot1, j)), kbUnitGetPosition(kbUnitQueryGetResult(ownTradePost, i))) < 10)
			{ //Check if the location from the owned TP socket is in about the same location as the tradeRoot1 socket 	
				if(getUnitByLocation(cUnitTypeMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, kbUnitGetPosition(xsArrayGetInt(tradeRoot1, j)), 20.0) > 3)continue; //Check to see if the Tradepost is safe to upgrade from
				siteLocation1 = kbUnitGetPosition(xsArrayGetInt(tradeRoot1, j)); //set site 1 upgrade location
				break; //found upgrade site, exit (NOTE: more logic could be added to check if this site is safe from enemy) 
			} //end if 
		} //end for j
		for (j = 0; < xsArrayGetSize(tradeRoot2))
		{ //Loop through tradeRoot2 Array
			if (xsArrayGetInt(tradeRoot2, j) == -1 || kbUnitGetPosition(xsArrayGetInt(tradeRoot2, j)) == cInvalidVector) continue;
			if (distance(kbUnitGetPosition(xsArrayGetInt(tradeRoot2, j)), kbUnitGetPosition(kbUnitQueryGetResult(ownTradePost, i))) < 10)
			{ //Check if the location from the owned TP socket is in about the same location as the tradeRoot2 socket 
				if(getUnitByLocation(cUnitTypeMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, kbUnitGetPosition(xsArrayGetInt(tradeRoot1, j)), 20.0) > 3)continue; //Check to see if the Tradepost is safe to upgrade from
				siteLocation2 = kbUnitGetPosition(xsArrayGetInt(tradeRoot2, j)); //set site 2 upgrade location
				break; //found upgrade site, exit (NOTE: more logic could be added to check if this site is safe from enemy) 
			} //end if
		} //end for
	} //end for
	for (i = 0; < 2)
	{ //Begin the tradingpost update check
		if (i == 0) siteLocation = siteLocation1; //0 is for root 1
		if (i == 1) siteLocation = siteLocation2; //1 is for root 2
		if (siteLocation != cInvalidVector)
		{ //check if a valid site location has been found
			if (i == 0 && disableRoot1 == true) continue; //Check if root 1 has been disabled
			if (i == 1 && disableRoot2 == true) continue; //Check if root 2 has been disabled
			if (i == 0)
			{ //root 1
				tradeRouteUpgradeTechID = upgradeTechRoot1; //set the tech  
				upgradeTechRoot1 = techUpgradeType2; //update the tech to research
				upgradeCountRoot1++; //update root1 upgrade count
			} //end if
			if (i == 1)
			{ //root 2
				tradeRouteUpgradeTechID = upgradeTechRoot2; //set the tech 
				upgradeTechRoot2 = techUpgradeType2; //update the tech to research
				upgradeCountRoot2++; //update root2 upgrade count
			} //end if
			if (tradeRouteUpgradeTechID == techUpgradeType1 && kbGetAge() < cAge2) continue; //If the ai is in age 1, do not upgrade to stagecoach
			if (tradeRouteUpgradeTechID == techUpgradeType2 && kbGetAge() < cAge4) continue; //If the ai is not in age 4, do not upgrade to iron horse
			tradeRouteUpgradeUnitID = getUnitByLocation(cUnitTypeVictoryPointBuilding, cMyID, cUnitStateAlive, siteLocation, 10.0); //get the unit id of the tradepost at the site location   
			if (i == 0)
			{ //root 1
				tradeRouteUpgradePlan1ID = aiPlanCreate("Trade Route Upgrade Plan", cPlanResearch); //set root1 plan id
				tradeRouteUpgradePlanID = tradeRouteUpgradePlan1ID; //set plan
			} //end if
			if (i == 1)
			{ //root 2
				tradeRouteUpgradePlan2ID = aiPlanCreate("Trade Route Upgrade Plan", cPlanResearch); //set root2 plan id
				tradeRouteUpgradePlanID = tradeRouteUpgradePlan2ID; //set plan
			} //end if
			aiPlanSetDesiredPriority(tradeRouteUpgradePlanID, 100); //set Priority
			aiPlanSetEscrowID(tradeRouteUpgradePlanID, cEmergencyEscrowID); //set Escrow ID
			aiPlanSetVariableInt(tradeRouteUpgradePlanID, cResearchPlanBuildingTypeID, 0, kbUnitGetProtoUnitID(tradeRouteUpgradeUnitID)); //add building type to plan
			aiPlanSetVariableInt(tradeRouteUpgradePlanID, cResearchPlanBuildingID, 0, tradeRouteUpgradeUnitID); //add build ID to plan
			aiPlanSetVariableInt(tradeRouteUpgradePlanID, cResearchPlanTechID, 0, tradeRouteUpgradeTechID); //add Tech id to plan
			aiPlanSetActive(tradeRouteUpgradePlanID, true); //start plan  
			if (upgradeCountRoot1 == 2) disableRoot1 = true; //disable root 1 upgrades
			if (upgradeCountRoot2 == 2) disableRoot2 = true; //disable root 2 upgrades
		} //end if
	} //end for i
	if (disableRoot1 == true && disableRoot2 == true)
	{
		xsDisableSelf();
	}
} //end tradeRouteUpgradeMonitor	

rule ransomExplorer
inactive
minInterval 60
{
	// Disable rule for native or Asian civs
	if (civIsNative() == true)
	{
		xsDisableSelf();
		return;
	}
	
	// Use only in Age 2 and above
	if ((kbGetAge() < cAge2) || (aiGetFallenExplorerID() < 0))
	{
		return;
	}
	else
	if(aiGetFallenExplorerID() >= 0)
	{
		aiTaskUnitTrain(getUnit(gTownCenter), kbUnitGetProtoUnitID(aiGetFallenExplorerID()));
	}
}

rule localNuggetGathering
inactive
minInterval 30
{
	static int localNuggetPlanStartTime = 0;
	if (localNuggetPlanStartTime == 0)
	{
		localNuggetPlanStartTime = xsGetTime(); // set time and quit when rule is called for the first time
		return;
	}
	
	static int localNuggetPlan = -1;
	vector homeBaseVec = cInvalidVector;
	
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0)
	{
		homeBaseVec = kbUnitGetPosition(getUnit(gTownCenter, cMyID)); // use random own TC position as basis for plans
	}
	else
	{
		return; // quit if there is no TC
	}
	
	// If there already is a plan destroy it, re-initialize explorer control plan, and wait for next call
	if (localNuggetPlan >= 0)
	{
		aiPlanDestroy(localNuggetPlan);
		localNuggetPlan = -1;
		
		// Re-initialize explorer control plan
		if (gExplorerControlPlan < 0)
		{
			gExplorerControlPlan = aiPlanCreate("Explorer control plan", cPlanDefend);
			switch(kbGetCiv())
			{
				case cCivXPAztec:
				{
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
					break;
				}
				case cCivXPIroquois:
				{
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
					break;
				}
				case cCivXPSioux:
				{
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
					break;
				}
				case cCivChinese:
				{
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkChinese, 1, 1, 1);
					break;
				}
				case cCivIndians:
				{
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian, 1, 1, 1);
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
					break;
				}
				case cCivJapanese:
				{
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
					break;
				}
				default:
				{
					aiPlanAddUnitType(gExplorerControlPlan, cUnitTypeExplorer, 1, 1, 1);
					break;
				}
			}
			aiPlanSetVariableVector(gExplorerControlPlan, cDefendPlanDefendPoint, 0, homeBaseVec);
			aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanEngageRange, 0, 20.0);    // Tight
			aiPlanSetVariableBool(gExplorerControlPlan, cDefendPlanPatrol, 0, false);
			aiPlanSetVariableFloat(gExplorerControlPlan, cDefendPlanGatherDistance, 0, 20.0);
			aiPlanSetInitialPosition(gExplorerControlPlan, homeBaseVec);
			aiPlanSetUnitStance(gExplorerControlPlan, cUnitStanceDefensive);
			aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanRefreshFrequency, 0, 30);
			aiPlanSetVariableInt(gExplorerControlPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit); // Only units
			aiPlanSetDesiredPriority(gExplorerControlPlan, 90);    // Quite high, don't suck him into routine attack plans, etc.
			aiPlanSetActive(gExplorerControlPlan);      
		}
		return;
	}
	
	// Quit if no local nuggets are around, if nugget gathering is not allowed, if explorer is ko, 
	// or if the last plan was created less than 3 minutes ago
	int localNuggetCount = getUnitCountByLocation(cUnitTypeAbstractNugget, cPlayerRelationAny, cUnitStateABQ, homeBaseVec, 75.0);
	
	if ((localNuggetCount == 0) || 
		(cvOkToGatherNuggets == false) || 
		(aiGetFallenExplorerID() >= 0) ||
	(xsGetTime() - localNuggetPlanStartTime < 180000))
	{
		return;
	}
	else   
	{
		// Destroy explorer control plan
		aiPlanDestroy(gExplorerControlPlan);
		gExplorerControlPlan = -1;
		
		// Find a random local nugget
		int localNugget = getUnitByLocation(cUnitTypeAbstractNugget, cPlayerRelationAny, cUnitStateABQ, homeBaseVec, 75.0);
		vector localNuggetVec = kbUnitGetPosition(localNugget);
		
		// Create temporary explore plan to gather local nuggets
		localNuggetPlan = aiPlanCreate("Local Nuggets", cPlanExplore);
		aiPlanSetDesiredPriority(localNuggetPlan, 75);
		aiPlanSetInitialPosition(localNuggetPlan, localNuggetVec);
		switch(kbGetCiv())
		{
			case cCivXPAztec:
			{
				aiPlanAddUnitType(localNuggetPlan, cUnitTypexpAztecWarchief, 1, 1, 1);
				break;
			}
			case cCivXPIroquois:
			{
				aiPlanAddUnitType(localNuggetPlan, cUnitTypexpIroquoisWarChief, 1, 1, 1);
				break;
			}
			case cCivXPSioux:
			{
				aiPlanAddUnitType(localNuggetPlan, cUnitTypexpLakotaWarchief, 1, 1, 1);
				break;
			}
			case cCivChinese:
			{
				aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkChinese, 1, 1, 1);
				break;
			}
			case cCivIndians:
			{
				aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkIndian, 1, 1, 1);
				aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkIndian2, 1, 1, 1);
				break;
			}
			case cCivJapanese:
			{
				aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkJapanese, 1, 1, 1);
				aiPlanAddUnitType(localNuggetPlan, cUnitTypeypMonkJapanese2, 1, 1, 1);
				break;
			}
			default:
			{
				aiPlanAddUnitType(localNuggetPlan, cUnitTypeExplorer, 1, 1, 1);
				break;
			}
		}
		aiPlanSetVariableBool(localNuggetPlan, cExplorePlanOkToGatherNuggets, 0, true);
		aiPlanSetEscrowID(localNuggetPlan, cMilitaryEscrowID);
		aiPlanSetBaseID(localNuggetPlan, kbBaseGetMainID(cMyID));
		aiPlanSetVariableBool(localNuggetPlan, cExplorePlanDoLoops, 0, false);
		aiPlanSetActive(localNuggetPlan);
		
		// Set start time
		localNuggetPlanStartTime = xsGetTime();
	}
}

rule navyUpgradeMonitor
inactive
minInterval 90
{
	// Disable rule for native civs
	if (civIsNative() == true)
	{
		xsDisableSelf();
		return;
	}
	
	// Quit and disable immediately if we're not on a water map
	if (gNavyMap == false)
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there are not enough warships to make upgrades worthwhile
	int navySize = kbUnitCount(cMyID, cUnitTypeLogicalTypeNavalMilitary, cUnitStateAlive);
	if (navySize < 4)
	{
		return;
	}
	
	// Disable rule once all three upgrades are available
	// (Percussion Lock is not researched as the AI never fires broadsides)
	if ((kbTechGetStatus(cTechCarronade) == cTechStatusActive) &&
		(kbTechGetStatus(cTechArmorPlating) == cTechStatusActive) &&
	(kbTechGetStatus(cTechShipHowitzers) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Get Cannonade and Armor Plating upgrades one at a time as they become available,
	// and the Ship's Howitzers upgrade if there is at least one monitor available
	int upgradePlanID = -1;
	if (kbTechGetStatus(cTechCarronade) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCarronade);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechCarronade, getUnit(gDockUnit), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechArmorPlating) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechArmorPlating);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechArmorPlating, getUnit(gDockUnit), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechShipHowitzers) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) >= 1))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechShipHowitzers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechShipHowitzers, getUnit(gDockUnit), cMilitaryEscrowID, 50);
		return;
	}
}

rule healerMonitor
inactive
minInterval 30
{
	static int healerPlan = -1;
	
	int priestCount = kbUnitCount(cMyID, cUnitTypePriest, cUnitStateAlive);
	int missionaryCount = kbUnitCount(cMyID, cUnitTypeMissionary, cUnitStateAlive);
	int surgeonCount = kbUnitCount(cMyID, cUnitTypeSurgeon, cUnitStateAlive);
	int imamCount = kbUnitCount(cMyID, cUnitTypeImam, cUnitStateAlive);
	int natMedicineManCount = kbUnitCount(cMyID, cUnitTypeNatMedicineMan, cUnitStateAlive);
	int xpMedicineManCount = kbUnitCount(cMyID, cUnitTypexpMedicineMan, cUnitStateAlive);
	int xpMedicineManAztecCount = kbUnitCount(cMyID, cUnitTypexpMedicineManAztec, cUnitStateAlive);
	
	
	if (healerPlan < 0)
	{
		healerPlan = aiPlanCreate("Healer Control Plan", cPlanDefend);
		
		aiPlanAddUnitType(healerPlan, cUnitTypePriest, priestCount, priestCount, priestCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypeMissionary, missionaryCount, missionaryCount, missionaryCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypeSurgeon, surgeonCount, surgeonCount, surgeonCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypeImam, imamCount, imamCount, imamCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypeNatMedicineMan, natMedicineManCount, natMedicineManCount, natMedicineManCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineMan, xpMedicineManCount, xpMedicineManCount, xpMedicineManCount); 
		if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1) // Add warrior priest only if there is no fire pit to dance at
		{
			aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, xpMedicineManAztecCount, xpMedicineManAztecCount, xpMedicineManAztecCount); 
		}
		else
		{
			aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, 0, 0, 0); 
		}
		
		aiPlanSetVariableVector(healerPlan, cDefendPlanDefendPoint, 0, kbBaseGetMilitaryGatherPoint(cMyID, kbBaseGetMainID(cMyID)));
		aiPlanSetVariableFloat(healerPlan, cDefendPlanEngageRange, 0, cvDefenseReflexRadiusActive);  
		aiPlanSetVariableBool(healerPlan, cDefendPlanPatrol, 0, false);
		aiPlanSetVariableFloat(healerPlan, cDefendPlanGatherDistance, 0, 10.0);
		aiPlanSetInitialPosition(healerPlan, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
		aiPlanSetUnitStance(healerPlan, cUnitStanceDefensive);
		aiPlanSetVariableInt(healerPlan, cDefendPlanRefreshFrequency, 0, 5);
		aiPlanSetVariableInt(healerPlan, cDefendPlanAttackTypeID, 0, cUnitTypeUnit);
		aiPlanSetDesiredPriority(healerPlan, 95);  // High priority to keep units from being sucked into other plans
		aiPlanSetActive(healerPlan); 
		//aiEcho("Creating healer plan");
	}
	else
	{
		aiPlanAddUnitType(healerPlan, cUnitTypePriest, priestCount, priestCount, priestCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypeMissionary, missionaryCount, missionaryCount, missionaryCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypeSurgeon, surgeonCount, surgeonCount, surgeonCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypeImam, imamCount, imamCount, imamCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypeNatMedicineMan, natMedicineManCount, natMedicineManCount, natMedicineManCount); 
		aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineMan, xpMedicineManCount, xpMedicineManCount, xpMedicineManCount); 
		if (kbUnitCount(cMyID, cUnitTypeFirePit, cUnitStateABQ) < 1) // Add warrior priest only if there is no fire pit to dance at
		{
			aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, xpMedicineManAztecCount, xpMedicineManAztecCount, xpMedicineManAztecCount); 
		}
		else
		{
			aiPlanAddUnitType(healerPlan, cUnitTypexpMedicineManAztec, 0, 0, 0); 
		}
		//aiEcho("Updating healer plan");
	}
}

rule useWarParties
inactive
group tcComplete
minInterval 10
{
	// Check to see if town is being overrun. If so, generate a plan
	// to research available war party. 
	
	// Disable rule for non-native civs
	if (civIsNative() == false)
	{
		xsDisableSelf();
		return;
	}
	
	static int partyPlan = -1;
	vector mainBaseVec = cInvalidVector;
	
	mainBaseVec =  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, mainBaseVec, 40.0);
	int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, mainBaseVec, 40.0);
	
	if (enemyCount >= (allyCount+6)) // We're behind by 6 or more
	{
		//aiEcho("***** Starting a party plan, there are "+enemyCount+" enemy units in my base against "+allyCount+" friendlies.");
		if (cMyCiv == cCivXPAztec)
		{
			if(kbTechGetStatus(cTechBigAztecScoutingParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigAztecScoutingParty, getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
			else if(kbTechGetStatus(cTechBigAztecRaidingParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigAztecRaidingParty, getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
			else if(kbTechGetStatus(cTechBigAztecWarParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigAztecWarParty, getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
		}
		else if (cMyCiv == cCivXPIroquois)
		{
			if(kbTechGetStatus(cTechBigIroquoisScoutingParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigIroquoisScoutingParty, getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
			else if(kbTechGetStatus(cTechBigIroquoisRaidingParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigIroquoisRaidingParty, getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
			else if(kbTechGetStatus(cTechBigIroquoisWarParty) == cTechStatusObtainable)
            partyPlan = createSimpleResearchPlan(cTechBigIroquoisWarParty, getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
		}
		else // cMyCiv == cCivXPSioux
		{
			if(xsGetTime() > 20*60*1000) // Use only after at least 20 minutes of game time (i.e. 7 units)
            partyPlan = createSimpleResearchPlan(cTechBigSiouxDogSoldiers, getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, mainBaseVec, 40.0), cMilitaryEscrowID, 99);     // Extreme priority
		}
	}
}

rule minorTribeTechMonitor
inactive
minInterval 90
{
	int techPlanID = -1;
	
	// Get techs from different minor tribes one at a time as they become available
	// Unavailable tribes and techs are simply ignored
	// Research plans are "blindly" tried at different trading posts as there is no way to 
	// identify specific trading posts in the AI script
	
	// Apache techs
	if (kbTechGetStatus(cTechNatXPApacheCactus) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheCactus);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPApacheCactus, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatXPApacheRaiding) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheRaiding);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPApacheRaiding, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatXPApacheEndurance) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPApacheEndurance);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPApacheEndurance, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Carib techs
	if ((kbTechGetStatus(cTechNatCeremonialFeast) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatBlowgunAmbusher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlowgunWarrior, cUnitStateAlive) >= 10))
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCeremonialFeast);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatCeremonialFeast, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatKasiriBeer) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatKasiriBeer);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatKasiriBeer, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatCeremonialFeast) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCeremonialFeast);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatCeremonialFeast, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Cherokee techs
	if (kbTechGetStatus(cTechNatBasketweaving) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatBasketweaving);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatBasketweaving, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatSequoyahSyllabary) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatSequoyahSyllabary);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatSequoyahSyllabary, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatWarDance) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatWarDance);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatWarDance, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Cheyenne techs
	if (kbTechGetStatus(cTechNatXPCheyenneHuntingGrounds) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneHuntingGrounds);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPCheyenneHuntingGrounds, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatXPCheyenneHorseTrading) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneHorseTrading);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPCheyenneHorseTrading, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatXPCheyenneFury) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPCheyenneFury);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPCheyenneFury, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Comanche techs
	if (kbTechGetStatus(cTechNatTradeLanguage) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTradeLanguage);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatTradeLanguage, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatHorseBreeding) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatHorseBreeding);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatHorseBreeding, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatMustangs) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatMustangs);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatMustangs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Cree techs
	if (kbTechGetStatus(cTechNatTextileCraftsmanship) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTextileCraftsmanship);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatTextileCraftsmanship, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatTanning) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatTanning);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatTanning, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Huron techs
	if ((kbTechGetStatus(cTechNatXPHuronTradeMonopoly) == cTechStatusObtainable) &&
	(xsGetTime() > 20*60*1000)) // Use only after at least 20 minutes of game time (i.e. 10 units)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPHuronTradeMonopoly);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPHuronTradeMonopoly, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	
	// Inca techs
	if (kbTechGetStatus(cTechNatMetalworking) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatMetalworking);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatMetalworking, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatChasquisMessengers) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatChasquisMessengers);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatChasquisMessengers, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatRoadbuilding) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatRoadbuilding);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatRoadbuilding, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Klamath techs
	if (kbTechGetStatus(cTechNatXPKlamathWorkEthos) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathWorkEthos);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPKlamathWorkEthos, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatXPKlamathStrategy) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathStrategy);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPKlamathStrategy, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechNatXPKlamathHuckleberryFeast) == cTechStatusObtainable) &&
	(xsGetTime() > 21*60*1000)) // Use only after at least 21 minutes of game time (i.e. 7 crates)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPKlamathHuckleberryFeast);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPKlamathHuckleberryFeast, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	
	// Mapuche techs
	if (kbTechGetStatus(cTechNatXPMapucheTactics) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheTactics);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPMapucheTactics, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatXPMapucheAdMapu) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheAdMapu);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPMapucheAdMapu, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechNatXPMapucheTreatyOfQuillin) == cTechStatusObtainable) &&
	(xsGetTime() > 20*60*1000)) // Use only after at least 20 minutes of game time (i.e. 10 crates)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPMapucheTreatyOfQuillin);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPMapucheTreatyOfQuillin, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	
	// Maya techs
	if (kbTechGetStatus(cTechNatCalendar) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCalendar);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatCalendar, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatCottonArmor) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatCottonArmor);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatCottonArmor, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Navajo techs
	if (kbTechGetStatus(cTechNatXPNavajoCraftsmanship) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPNavajoCraftsmanship);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPNavajoCraftsmanship, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	
	// Seminole techs
	if (kbTechGetStatus(cTechNatBowyery) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatBowyery);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatBowyery, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	
	// Tupi techs
	if (kbTechGetStatus(cTechNatPoisonArrowFrogs) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatPoisonArrowFrogs);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatPoisonArrowFrogs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatForestBurning) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatForestBurning);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatForestBurning, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	
	// Zapotec techs
	if (kbTechGetStatus(cTechNatXPZapotecCultOfTheDead) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecCultOfTheDead);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPZapotecCultOfTheDead, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechNatXPZapotecFoodOfTheGods) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecFoodOfTheGods);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPZapotecFoodOfTheGods, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechNatXPZapotecCloudPeople) == cTechStatusObtainable) &&
	(xsGetTime() > 20*60*1000)) // Use only after at least 20 minutes of game time (i.e. 10 crates)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechNatXPZapotecCloudPeople);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechNatXPZapotecCloudPeople, getUnit(cUnitTypeTradingPost), cEconomyEscrowID, 50);
		return;
	}
}

rule minorAsianTribeTechMonitor
inactive
minInterval 90
{
	int techPlanID = -1;
	
	// Get techs from different minor Asian tribes one at a time as they become available
	// Unavailable tribes and techs are simply ignored
	// Research plans are "blindly" tried at different trading posts as there is no way to 
	// identify specific trading posts in the AI script
	
	// Bhakti techs
	if (kbTechGetStatus(cTechYPNatBhaktiYoga) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatBhaktiYoga);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatBhaktiYoga, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPNatBhaktiReinforcedGuantlets) == cTechStatusObtainable) && (kbGetAge() > cAge3) && (kbUnitCount(cMyID, cUnitTypeypNatTigerClaw, cUnitStateAlive) >= 10)) 
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatBhaktiReinforcedGuantlets);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatBhaktiReinforcedGuantlets, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	
	// Jesuit techs
	if (kbTechGetStatus(cTechYPNatJesuitSmokelessPowder) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatJesuitSmokelessPowder);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatJesuitSmokelessPowder, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechYPNatJesuitFlyingButtress) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatJesuitFlyingButtress);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatJesuitFlyingButtress, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	
	// Shaolin techs
	if (kbTechGetStatus(cTechYPNatShaolinWoodClearing) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinWoodClearing);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatShaolinWoodClearing, getUnit(cUnitTypeypTradingPostAsian), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechYPNatShaolinClenchedFist) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinClenchedFist);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatShaolinClenchedFist, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPNatShaolinDimMak) == cTechStatusObtainable) && (kbGetAge() > cAge3) && (kbUnitCount(cMyID, cUnitTypeypNatRattanShield, cUnitStateAlive) >= 10)) 
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatShaolinDimMak);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatShaolinDimMak, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	
	// Sufi techs
	if (kbTechGetStatus(cTechYPNatSufiFasting) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatSufiFasting);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatSufiFasting, getUnit(cUnitTypeypTradingPostAsian), cEconomyEscrowID, 50);
		return;
	}
	
	// Udasi techs
	if (kbTechGetStatus(cTechYPNatUdasiNewYear) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiNewYear);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatUdasiNewYear, getUnit(cUnitTypeypTradingPostAsian), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechYPNatUdasiGurus) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiGurus);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatUdasiGurus, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPNatUdasiArmyOfThePure) == cTechStatusObtainable) && (kbGetAge() > cAge3) && (kbUnitCount(cMyID, cUnitTypeypNatChakram, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercChakram, cUnitStateAlive) >= 10)) 
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatUdasiArmyOfThePure);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatUdasiArmyOfThePure, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	
	// Zen techs
	if (kbTechGetStatus(cTechYPNatZenMasterLessons) == cTechStatusObtainable)
	{
		techPlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPNatZenMasterLessons);
		if (techPlanID >= 0)
		aiPlanDestroy(techPlanID);
		createSimpleResearchPlan(cTechYPNatZenMasterLessons, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
}

rule balloonMonitor
inactive
minInterval 10
{
	// Create plan only when balloon available and exploring allowed
	if ((kbUnitCount(cMyID, cUnitTypexpAdvancedBalloon) == 0) || (cvOkToExplore == false))
	{
		return;
	}
	
	// Create explore plan
	int balloonExplore = aiPlanCreate("Balloon Explore", cPlanExplore);
	aiPlanSetDesiredPriority(balloonExplore, 99);
	aiPlanAddUnitType(balloonExplore, cUnitTypexpAdvancedBalloon, 1, 1, 1);
	aiPlanSetEscrowID(balloonExplore, cEconomyEscrowID);
	aiPlanSetBaseID(balloonExplore, kbBaseGetMainID(cMyID));
	aiPlanSetVariableBool(balloonExplore, cExplorePlanDoLoops, 0, false);
	aiPlanSetActive(balloonExplore);
	
	// Disable rule
	xsDisableSelf();   
}

rule aztecWarhutUpgradeMonitor
inactive
minInterval 90
{
	int aztecWarhutUpgradePlan = -1;
	
	// Disable rule for anyone but Aztecs
	if (kbGetCiv() != cCivXPAztec)
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if no fortifications are allowed
	if (cvOkToFortify == false)
	{
		return; 
	}
	
	// Disable rule once both upgrades are available
	if ((kbTechGetStatus(cTechStrongWarHut) == cTechStatusActive) &&
	(kbTechGetStatus(cTechMightyWarHut) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Research both upgrades as they become available, but only if there are enough war huts around
	if ((kbTechGetStatus(cTechStrongWarHut) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) >= 3))
	{
		aztecWarhutUpgradePlan = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechStrongWarHut);
		if (aztecWarhutUpgradePlan >= 0)
		aiPlanDestroy(aztecWarhutUpgradePlan);
		createSimpleResearchPlan(cTechStrongWarHut, -1, cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechMightyWarHut) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateABQ) >= 5))
	{
		aztecWarhutUpgradePlan = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechMightyWarHut);
		if (aztecWarhutUpgradePlan >= 0)
		aiPlanDestroy(aztecWarhutUpgradePlan);
		createSimpleResearchPlan(cTechMightyWarHut, -1, cMilitaryEscrowID, 50);
		return;
	}
}

rule settlerUpgradeMonitor
inactive
minInterval 180 // research to be started 3 minutes into Age 2
{
	int upgradePlanID = -1;
	
	// Disable rule once the upgrades are available
	if (civIsNative() == true)
	{
		if (kbTechGetStatus(cTechSpiritMedicine) == cTechStatusActive)
		{
			xsDisableSelf();
			return;
		}
	}
	else if (civIsAsian() == true)
	{
		if (kbTechGetStatus(cTechypMarketSpiritMedicine) == cTechStatusActive)
		{
			xsDisableSelf();
			return;
		}
	}
	else
	{
		if (kbTechGetStatus(cTechFrontierTraining) == cTechStatusActive)
		{
			xsDisableSelf();
			return;
		}
	}
	
	// Get upgrades one at a time
	if (kbTechGetStatus(cTechSpiritMedicine) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechSpiritMedicine);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechSpiritMedicine, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechypMarketSpiritMedicine) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypMarketSpiritMedicine);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypMarketSpiritMedicine, getUnit(cUnitTypeypTradeMarketAsian), cEconomyEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechFrontierTraining) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFrontierTraining);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechFrontierTraining, getUnit(cUnitTypeMarket), cEconomyEscrowID, 50);
		return;
	}
}

rule arsenalUpgradeMonitor
inactive
minInterval 60
{
	int upgradePlanID = -1;
	
	// Disable rule for native or Asian civs
	if ((civIsNative() == true) || (civIsAsian() == true))
	{
		xsDisableSelf();
		return;
	}
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechRifling) == cTechStatusActive) &&
		(kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
		(kbTechGetStatus(cTechBayonet) == cTechStatusActive) &&
		(kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
		(kbTechGetStatus(cTechCaracole) == cTechStatusActive) &&
		(kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusActive) &&
	((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (getUnit(cUnitTypeHomeCityWaterSpawnFlag) <= 0)))
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there is no arsenal
	if (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateAlive) < 1)
	{
		return;
	}
	
	// Get 'Heated Shot' upgrade on water maps
	if ((kbTechGetStatus(cTechHeatedShot) == cTechStatusObtainable) && (getUnit(cUnitTypeHomeCityWaterSpawnFlag) > 0))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeatedShot);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechHeatedShot, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
	
	// Get other upgrades one at the time, provided a sufficient number of units to be improved are available
	if ((kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGunnersQuadrant);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGunnersQuadrant, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRifling) == cTechStatusObtainable) && 
		(kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeMercJaeger, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) +
		kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 12))
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRifling);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechRifling, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
			return;
		}
		if ((kbTechGetStatus(cTechBayonet) == cTechStatusObtainable) && 
			(kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeMercHighlander, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeMercFusilier, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypConsulateGuerreiros, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeypConsulateStadhouders, cUnitStateAlive) >= 12))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBayonet);
				if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
				createSimpleResearchPlan(cTechBayonet, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
				return;
			}
			if ((kbTechGetStatus(cTechCaracole) == cTechStatusObtainable) && 
			(kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCaracole);
				if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
				createSimpleResearchPlan(cTechCaracole, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
				return;
			}
			if ((kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable) && 
			(kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);
				if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
				createSimpleResearchPlan(cTechCavalryCuirass, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
				return;
			}
			if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable) && 
				(kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeypShinobiHorse, cUnitStateAlive) +
					kbUnitCount(cMyID, cUnitTypeypConsulateShinobi, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypConsulateBestieros, cUnitStateAlive) >= 12))
				{
					upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);
					if (upgradePlanID >= 0)
					aiPlanDestroy(upgradePlanID);
					createSimpleResearchPlan(cTechInfantryBreastplate, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
					return;
				}
}

rule arsenalUpgradeAsianMonitor
inactive
minInterval 60
{
	int upgradePlanID = -1;
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
		(kbTechGetStatus(cTechBayonet) == cTechStatusActive) &&
		(kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
		(kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusActive) &&
	((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (getUnit(cUnitTypeHomeCityWaterSpawnFlag) <= 0)))
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there is no special arsenal built from a wagon around
	if (kbUnitCount(cMyID, cUnitTypeypArsenalAsian, cUnitStateAlive) < 1)
	{
		return;
	}
	
	// Get 'Heated Shot' upgrade on water maps
	if ((kbTechGetStatus(cTechHeatedShot) == cTechStatusObtainable) && (getUnit(cUnitTypeHomeCityWaterSpawnFlag) > 0))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeatedShot);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechHeatedShot, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
		return;
	}
	
	// Get other upgrades one at the time, provided a sufficient number of units to be improved are available
	if ((kbTechGetStatus(cTechGunnersQuadrant) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGunnersQuadrant);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGunnersQuadrant, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechBayonet) == cTechStatusObtainable) && 
		(kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeMercHighlander, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeMercFusilier, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeypConsulateGuerreiros, cUnitStateAlive) +
		kbUnitCount(cMyID, cUnitTypeypConsulateStadhouders, cUnitStateAlive) >= 12))
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechBayonet);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechBayonet, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
			return;
		}
		if ((kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable) && 
		(kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12))
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechCavalryCuirass, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
			return;
		}
		if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable) && 
			(kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypShinobiHorse, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypConsulateShinobi, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeypConsulateBestieros, cUnitStateAlive) >= 12))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);
				if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
				createSimpleResearchPlan(cTechInfantryBreastplate, getUnit(cUnitTypeypArsenalAsian), cMilitaryEscrowID, 50);
				return;
			}
}

rule advancedArsenalUpgradeMonitor
inactive
minInterval 60
{
	int upgradePlanID = -1;
	
	// Disable rule for native or Asian civs
	if ((civIsNative() == true) || (civIsAsian() == true))
	{
		xsDisableSelf();
		return;
	}
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusActive) &&
		(kbTechGetStatus(cTechFlintlock) == cTechStatusActive) &&
		(kbTechGetStatus(cTechMilitaryDrummers) == cTechStatusActive) &&
		(kbTechGetStatus(cTechProfessionalGunners) == cTechStatusActive) &&
		(kbTechGetStatus(cTechTrunion) == cTechStatusActive) &&
		(kbTechGetStatus(cTechPillage) == cTechStatusActive) &&
	(kbTechGetStatus(cTechIncendiaryGrenades) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there is no arsenal
	if (kbUnitCount(cMyID, cUnitTypeArsenal, cUnitStateAlive) < 1)
	{
		return;
	}
	
	// Get upgrades one at the time, provided a sufficient number of units to be improved are available
	if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPaperCartridge);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechPaperCartridge, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechFlintlock) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFlintlock);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechFlintlock, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechMilitaryDrummers) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechMilitaryDrummers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechMilitaryDrummers, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechProfessionalGunners) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechProfessionalGunners);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechProfessionalGunners, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechTrunion) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechTrunion);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechTrunion, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechPillage) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPillage);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechPillage, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechIncendiaryGrenades) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechIncendiaryGrenades);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechIncendiaryGrenades, getUnit(cUnitTypeArsenal), cMilitaryEscrowID, 50);
		return;
	}
}

rule goldenPavillionUpgradeMonitor
inactive
minInterval 60
{
	int upgradePlanID = -1;
	int pavillionType = -1;
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusActive) &&
		(kbTechGetStatus(cTechFlintlock) == cTechStatusActive) &&
		(kbTechGetStatus(cTechProfessionalGunners) == cTechStatusActive) &&
	(kbTechGetStatus(cTechPillage) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Check for golden pavillion
	if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion2, cUnitStateAlive) > 0)
	{
		pavillionType = cUnitTypeypWJGoldenPavillion2;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion3, cUnitStateAlive) > 0)
	{
		pavillionType = cUnitTypeypWJGoldenPavillion3;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion4, cUnitStateAlive) > 0)
	{
		pavillionType = cUnitTypeypWJGoldenPavillion4;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion5, cUnitStateAlive) > 0)
	{
		pavillionType = cUnitTypeypWJGoldenPavillion5;
	}
	
	// Quit if there is no golden pavillion
	if (pavillionType < 0)
	{
		return;
	}
	
	// Get upgrades one at the time, provided a sufficient number of units to be improved are available
	if ((kbTechGetStatus(cTechPaperCartridge) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPaperCartridge);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechPaperCartridge, getUnit(pavillionType), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechFlintlock) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFlintlock);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechFlintlock, getUnit(pavillionType), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechProfessionalGunners) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechProfessionalGunners);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechProfessionalGunners, getUnit(pavillionType), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechPillage) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPillage);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechPillage, getUnit(pavillionType), cMilitaryEscrowID, 50);
		return;
	}
}

rule newWayIroquoisMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechRifling) == cTechStatusActive) &&
		(kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
		(kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
		(kbTechGetStatus(cTechCaracole) == cTechStatusActive) &&
	((kbTechGetStatus(cTechHeatedShot) == cTechStatusActive) || (getUnit(cUnitTypeHomeCityWaterSpawnFlag) <= 0)))
	{
		xsDisableSelf();
		return;
	}
	
	// Get 'Heated Shot' upgrade on water maps
	if ((kbTechGetStatus(cTechHeatedShot) == cTechStatusObtainable) && (getUnit(cUnitTypeHomeCityWaterSpawnFlag) > 0))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeatedShot);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechHeatedShot, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
		return;
	}
	
	// Get other upgrades one at the time, provided a sufficient number of units to be improved are available
	if ((kbTechGetStatus(cTechRifling) == cTechStatusObtainable) && 
		(kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeMercJaeger, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) +
		kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 12))
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRifling);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechRifling, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
			return;
		}
		if ((kbTechGetStatus(cTechCaracole) == cTechStatusObtainable) && 
		(kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12))
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCaracole);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechCaracole, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
			return;
		}
		if ((kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable) && 
		(kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12))
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechCavalryCuirass, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
			return;
		}
		if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable) && 
			(kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypShinobiHorse, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypConsulateShinobi, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeypConsulateBestieros, cUnitStateAlive) >= 12))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);
				if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
				createSimpleResearchPlan(cTechInfantryBreastplate, getUnit(cUnitTypeLonghouse), cMilitaryEscrowID, 50);
				return;
			}
}

rule newWaySiouxMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechRifling) == cTechStatusActive) &&
		(kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusActive) &&
		(kbTechGetStatus(cTechCavalryCuirass) == cTechStatusActive) &&
		(kbTechGetStatus(cTechCaracole) == cTechStatusActive) &&
	(kbTechGetStatus(cTechPillage) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Get upgrades one at the time, provided a sufficient number of units to be improved are available
	if ((kbTechGetStatus(cTechCaracole) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCaracole);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechCaracole, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechPillage) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechPillage);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechPillage, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechCavalryCuirass) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechCavalryCuirass);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechCavalryCuirass, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRifling) == cTechStatusObtainable) && 
		(kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeMercJaeger, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) +
		kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 12))
		{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRifling);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechRifling, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
			return;
		}
		if ((kbTechGetStatus(cTechInfantryBreastplate) == cTechStatusObtainable) && 
			(kbUnitCount(cMyID, cUnitTypeAbstractHandInfantry, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypShinobiHorse, cUnitStateAlive) +
				kbUnitCount(cMyID, cUnitTypeypConsulateShinobi, cUnitStateAlive) +
			kbUnitCount(cMyID, cUnitTypeypConsulateBestieros, cUnitStateAlive) >= 12))
			{
				upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechInfantryBreastplate);
				if (upgradePlanID >= 0)
				aiPlanDestroy(upgradePlanID);
				createSimpleResearchPlan(cTechInfantryBreastplate, getUnit(cUnitTypeTeepee), cMilitaryEscrowID, 50);
				return;
			}
}

rule veteranUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule for native or Asian civs
	if ((civIsNative() == true) || (civIsAsian() == true))
	{
		xsDisableSelf();
		return;
	}
	
	// Disable rule for Russians who will use the 'Westernization' upgrade
	if (kbGetCiv() == cCivRussians)
	{
		xsDisableSelf();
		return;
	}
	
	// Get veteran upgrades one at the time, provided a sufficient number of units to be improved are available
	
	// Stable units
	if ((kbTechGetStatus(cTechVeteranHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranHussars);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechVeteranUhlans) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeUhlan, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranUhlans);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranUhlans, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	
	// Artillery depot units
	if ((kbTechGetStatus(cTechVeteranAbusGuns) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranAbusGuns);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranAbusGuns, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechVeteranGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranGrenadiers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	
	// Barracks units
	if ((kbTechGetStatus(cTechVeteranMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranMusketeers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechVeteranJanissaries) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranJanissaries);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranJanissaries, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechVeteranLongbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranLongbowmen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranLongbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechVeteranDopplesoldners) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDopplesoldner, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranDopplesoldners);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranDopplesoldners, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechVeteranRodeleros) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeRodelero, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranRodeleros);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranRodeleros, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechVeteranCrossbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranCrossbowmen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranCrossbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechVeteranPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechVeteranPikemen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechVeteranPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
}

rule guardUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule for native or Asian civs
	if ((civIsNative() == true) || (civIsAsian() == true))
	{
		xsDisableSelf();
		return;
	}
	
	// Disable rule for Russians who will use the 'Petrine Reforms' upgrade
	if (kbGetCiv() == cCivRussians)
	{
		xsDisableSelf();
		return;
	}
	
	// Get guard upgrades one at the time, provided a sufficient number of units to be improved are available
	
	// Stable units
	if ((kbTechGetStatus(cTechGuardWarWagons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeWarWagon, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardWarWagons);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardWarWagons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardDragoons) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardDragoons);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardDragoons, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHussars);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardCavalryArchers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardCavalryArchers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardCavalryArchers, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	
	// Artillery depot units
	if ((kbTechGetStatus(cTechGuardAbusGuns) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardAbusGuns);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardAbusGuns, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardGrenadiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardGrenadiers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardGrenadiers, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	
	// Barracks units
	if ((kbTechGetStatus(cTechGuardMusketeers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardMusketeers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardMusketeers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardSkirmishers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardSkirmishers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardSkirmishers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardJanissaries) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardJanissaries);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardJanissaries, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardCacadores) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardCacadores);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardCacadores, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardLongbowmen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardLongbowmen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardLongbowmen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardDopplesoldners) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDopplesoldner, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardDopplesoldners);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardDopplesoldners, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardHalberdiers) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardHalberdiers);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardHalberdiers, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGuardPikemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGuardPikemen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGuardPikemen, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
}

rule royalGuardUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule for native or Asian civs
	if ((civIsNative() == true) || (civIsAsian() == true))
	{
		xsDisableSelf();
		return;
	}
	
	// Disable rule for Russians who will use the 'Petrine Reforms' upgrade
	if (kbGetCiv() == cCivRussians)
	{
		xsDisableSelf();
		return;
	}
	
	// Get royal guard upgrades one at the time, provided a sufficient number of units to be improved are available
	
	// Stable units
	if ((kbTechGetStatus(cTechRGGendarmes) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCuirassier, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGGendarmes);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGGendarmes, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGGarrochista) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeLancer, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGGarrochista);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGGarrochista, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGCarabineer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeRuyter, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGCarabineer);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGCarabineer, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGJinetes) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGJinetes);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGJinetes, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGLifeGuardHussars) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGLifeGuardHussars);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGLifeGuardHussars, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGGardener) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGGardener);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGGardener, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGCzapkaUhlans) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeUhlan, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGCzapkaUhlans);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGCzapkaUhlans, getUnit(cUnitTypeStable), cMilitaryEscrowID, 50);
		return;
	}
	
	// Artillery depot units
	if ((kbTechGetStatus(cTechRGBaratcuCorps) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGBaratcuCorps);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGBaratcuCorps, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	
	// Barracks units
	if ((kbTechGetStatus(cTechRGRedcoats) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGRedcoats);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGRedcoats, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGGuerreiros) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGGuerreiros);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGGuerreiros, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGVoltigeur) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGVoltigeur);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGVoltigeur, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGPrussianNeedleGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGPrussianNeedleGun);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGPrussianNeedleGun, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGNassausLinearTactics) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGNassausLinearTactics);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGNassausLinearTactics, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGEspadachins) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeRodelero, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGEspadachins);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGEspadachins, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRGTercio) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRGTercio);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRGTercio, getUnit(cUnitTypeBarracks), cMilitaryEscrowID, 50);
		return;
	}
}

rule artilleryUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule for Asians, Aztecs and Sioux 
	if ((civIsAsian() == true) || (kbGetCiv() == cCivXPAztec) || (kbGetCiv() == cCivXPSioux))
	{
		xsDisableSelf();
		return;
	}
	
	// Get artillery upgrades one at the time, provided a sufficient number of units to be improved are available
	if ((kbTechGetStatus(cTechFieldGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldGun);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechFieldGun, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechGrapeShot) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechGrapeShot);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechGrapeShot, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechHeavyHorseArtillery) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHeavyHorseArtillery);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechHeavyHorseArtillery, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechRabauld) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeOrganGun, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRabauld);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRabauld, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechHowitzer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechHowitzer);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechHowitzer, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechFieldCannon) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpLightCannon, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFieldCannon);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechFieldCannon, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
}

rule eliteUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule for non-native civs
	if (civIsNative() == false)
	{
		xsDisableSelf();
		return;
	}
	
	// Get elite upgrades one at the time, provided a sufficient number of units to be improved are available
	
	// Corral units
	if ((kbTechGetStatus(cTechEliteHorsemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteHorsemen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteHorsemen, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechEliteAxeRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAxeRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteAxeRiders);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteAxeRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechEliteBowRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpBowRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteBowRider);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteBowRider, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	
	// War hut units
	if ((kbTechGetStatus(cTechEliteAennas) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteAennas);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteAennas, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechEliteTomahawks) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteTomahawks);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteTomahawks, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechEliteWarBows) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteWarBows);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteWarBows, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechEliteWarClubs) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteWarClubs);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteWarClubs, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechEliteCoyotemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteCoyotemen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteCoyotemen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechEliteMacehualtins) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechEliteMacehualtins);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechEliteMacehualtins, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechElitePumaMen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechElitePumaMen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechElitePumaMen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
}

rule championUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule for non-native civs
	if (civIsNative() == false)
	{
		xsDisableSelf();
		return;
	}
	
	// Get champion upgrades one at the time, provided a sufficient number of units to be improved are available
	
	// Corral units
	if ((kbTechGetStatus(cTechChampionMusketRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMusketRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMusketRiders);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionMusketRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionRifleRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpRifleRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionRifleRiders);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionRifleRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionHorsemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionHorsemen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionHorsemen, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionAxeRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAxeRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionAxeRiders);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionAxeRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionBowRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpBowRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionBowRider);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionBowRider, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionCoupRiders) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpCoupRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCoupRiders);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionCoupRiders, getUnit(cUnitTypeCorral), cMilitaryEscrowID, 50);
		return;
	}
	
	// War hut units
	if ((kbTechGetStatus(cTechChampionWarRifles) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionWarRifles);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionWarRifles, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionMusketWarriors) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMusketWarriors);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionMusketWarriors, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionAennas) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionAennas);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionAennas, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionTomahawk) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionTomahawk);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionTomahawk, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionWarBows) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionWarBows);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionWarBows, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionWarClubs) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionWarClubs);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionWarClubs, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionCoyotemen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCoyotemen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionCoyotemen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionMacehualtins) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMacehualtins);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionMacehualtins, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionPumaMen) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionPumaMen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionPumaMen, getUnit(cUnitTypeWarHut), cMilitaryEscrowID, 50);
		return;
	}
	
	// Artillery depot units
	if ((kbTechGetStatus(cTechChampionMantlets) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpMantlet, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMantlets);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionMantlets, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionRams) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpRam, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionRams);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionRams, getUnit(cUnitTypeArtilleryDepot), cMilitaryEscrowID, 50);
		return;
	}
	
	// Nobles hut units
	if ((kbTechGetStatus(cTechChampionJaguarKnight) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpJaguarKnight, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionJaguarKnight);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionJaguarKnight, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionArrowKnight) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionArrowKnight);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionArrowKnight, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionEagleKnight) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionEagleKnight);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionEagleKnight, getUnit(cUnitTypeNoblesHut), cMilitaryEscrowID, 50);
		return;
	}
}

rule disciplinedUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule for non-Asian civs
	if (civIsAsian() == false)
	{
		xsDisableSelf();
		return;
	}
	
	// Get disciplined upgrades one at the time, provided a sufficient number of units to be improved are available
	
	// War academy units
	if ((kbTechGetStatus(cTechYPDisciplinedChuKoNu) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedChuKoNu);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedChuKoNu, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedQiangPikeman) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedQiangPikeman);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedQiangPikeman, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedSteppeRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedSteppeRider);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedSteppeRider, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedKeshik) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedKeshik);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedKeshik, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	
	// Caravanserai units
	if ((kbTechGetStatus(cTechYPDisciplinedCamel) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedCamel);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedCamel, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedCamelGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedCamelGun);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedCamelGun, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
		return;
	}
	
	// Stable units
	if ((kbTechGetStatus(cTechYPDisciplinedNaginataRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedNaginataRider);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedNaginataRider, getUnit(cUnitTypeypStableJapanese), cMilitaryEscrowID, 50);
		return;
	}
	
	// Indian barracks units
	if ((kbTechGetStatus(cTechYPDisciplinedSepoy) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSepoy, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedSepoy);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedSepoy, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedGurkha) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractGurkha, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedGurkha);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedGurkha, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedRajput) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractRajput, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedRajput);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedRajput, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
		return;
	}
	
	// Japanese barracks units
	if ((kbTechGetStatus(cTechYPDisciplinedAshigaru) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedAshigaru);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedAshigaru, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedYumi) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedYumi);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedYumi, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedSamurai) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedSamurai);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedSamurai, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
		return;
	}
	
	// Castle units
	if ((kbTechGetStatus(cTechYPDisciplinedFlameThrower) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedFlameThrower);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedFlameThrower, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPDisciplinedFlailElephant) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPDisciplinedFlailElephant);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPDisciplinedFlailElephant, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
		return;
	}
}

rule honoredUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule for non-Asian civs
	if (civIsAsian() == false)
	{
		xsDisableSelf();
		return;
	}
	
	// Get honored upgrades one at the time, provided a sufficient number of units to be improved are available
	
	// War academy units
	if ((kbTechGetStatus(cTechYPHonoredIronFlail) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypIronFlail, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredIronFlail);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredIronFlail, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredMeteorHammer) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypMeteorHammer, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredMeteorHammer);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredMeteorHammer, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredArquebusier) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypArquebusier, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredArquebusier);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredArquebusier, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredChangdao) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypChangdao, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredChangdao);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredChangdao, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredChuKoNu) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredChuKoNu);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredChuKoNu, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredQiangPikeman) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredQiangPikeman);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredQiangPikeman, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredSteppeRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredSteppeRider);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredSteppeRider, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredKeshik) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredKeshik);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredKeshik, getUnit(cUnitTypeypWarAcademy), cMilitaryEscrowID, 50);
		return;
	}
	
	// Caravanserai units
	if ((kbTechGetStatus(cTechYPHonoredCamel) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredCamel);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredCamel, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredCamelGun) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredCamelGun);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredCamelGun, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredMahout) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractMahout, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredMahout);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredMahout, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredHowdah) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractHowdah, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredHowdah);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredHowdah, getUnit(cUnitTypeypCaravanserai), cMilitaryEscrowID, 50);
		return;
	}
	
	// Stable units
	if ((kbTechGetStatus(cTechYPHonoredNaginataRider) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredNaginataRider);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredNaginataRider, getUnit(cUnitTypeypStableJapanese), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredYabusame) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypYabusame, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredYabusame);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredYabusame, getUnit(cUnitTypeypStableJapanese), cMilitaryEscrowID, 50);
		return;
	}
	
	// Indian barracks units
	if ((kbTechGetStatus(cTechYPHonoredSepoy) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSepoy, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredSepoy);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredSepoy, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredGurkha) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractGurkha, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredGurkha);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredGurkha, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredRajput) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractRajput, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredRajput);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredRajput, getUnit(cUnitTypeYPBarracksIndian), cMilitaryEscrowID, 50);
		return;
	}
	
	// Japanese barracks units
	if ((kbTechGetStatus(cTechYPHonoredAshigaru) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredAshigaru);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredAshigaru, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredYumi) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 12))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredYumi);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredYumi, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredSamurai) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) >= 8))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredSamurai);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredSamurai, getUnit(cUnitTypeypBarracksJapanese), cMilitaryEscrowID, 50);
		return;
	}
	
	// Castle units
	if ((kbTechGetStatus(cTechYPHonoredFlameThrower) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredFlameThrower);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredFlameThrower, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredHandMortar) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypHandMortar, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredHandMortar);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredHandMortar, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredFlailElephant) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredFlailElephant);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredFlailElephant, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredSiegeElephant) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeAbstractSiegeElephant, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredSiegeElephant);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredSiegeElephant, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredFlamingArrow) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypFlamingArrow, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredFlamingArrow);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredFlamingArrow, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechYPHonoredMorutaru) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeypMorutaru, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechYPHonoredMorutaru);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechYPHonoredMorutaru, getUnit(cUnitTypeypCastle), cMilitaryEscrowID, 50);
		return;
	}
}

rule warriorSocietyUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Get warrior society upgrades one at the time, provided a sufficient number of units to be improved are available
	// Research plans are "blindly" tried at different trading posts as there is no way to identify specific trading posts in the AI script
	
	if ((kbTechGetStatus(cTechWarriorSocietyAztecs) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatJaguarWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatEagleWarrior, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyAztecs);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyAztecs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyCaribs) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatBlowgunAmbusher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlowgunWarrior, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyCaribs);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyCaribs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyCherokee) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyCherokee);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyCherokee, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyComanche) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatHorseArcher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercHorseArcher, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyComanche);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyComanche, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyCree) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyCree);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyCree, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyInca) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatHuaminca, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyInca);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyInca, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyIroquois) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatTomahawk, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMantlet, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyIroquois);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyIroquois, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
	}
	if ((kbTechGetStatus(cTechWarriorSocietyLakota) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatAxeRider, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyLakota);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyLakota, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyMaya) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatHolcanSpearman, cUnitStateAlive)+ kbUnitCount(cMyID, cUnitTypeNatMercHolcanSpearman, cUnitStateAlive)  >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyMaya);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyMaya, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyNootka) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatClubman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercClubman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyNootka);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyNootka, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietySeminoles) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietySeminoles);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietySeminoles, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyTupi) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyTupi);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyTupi, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyHuron) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatHuronMantlet, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercHuronMantlet, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyHuron);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyHuron, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyZapotec) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatLightningWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercLightningWarrior, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyZapotec);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyZapotec, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyKlamath) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyKlamath);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyKlamath, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
	}
	if ((kbTechGetStatus(cTechWarriorSocietyApache) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatApacheCavalry, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyApache);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyApache, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyNavajo) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyNavajo);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyNavajo, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyCheyenne) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatCheyenneRider, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercCheyenneRider, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyCheyenne);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyCheyenne, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechWarriorSocietyMapuche) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatMapucheClubman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechWarriorSocietyMapuche);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechWarriorSocietyMapuche, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
}

rule minorNativeChampionUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Get minor native champion upgrades one at the time, provided a sufficient number of units to be improved are available
	// Research plans are "blindly" tried at different trading posts as there is no way to identify specific trading posts in the AI script
	
	if ((kbTechGetStatus(cTechChampionAztecs) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatJaguarWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatEagleWarrior, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionAztecs);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionAztecs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionCaribs) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatBlowgunWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatBlowgunAmbusher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlowgunWarrior, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCaribs);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionCaribs, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionCherokee) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatRifleman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercRifleman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCherokee);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionCherokee, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionComanche) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatHorseArcher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercHorseArcher, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionComanche);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionComanche, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionCree) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatTracker, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercTracker, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCree);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionCree, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionInca) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatBolasWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatHuaminca, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionInca);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionInca, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionIroquois) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeNatTomahawk, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMantlet, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionIroquois);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionIroquois, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionLakota) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatAxeRider, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionLakota);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionLakota, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionMaya) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatHolcanSpearman, cUnitStateAlive)+ kbUnitCount(cMyID, cUnitTypeNatMercHolcanSpearman, cUnitStateAlive)  >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMaya);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionMaya, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionNootka) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatClubman, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercClubman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionNootka);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionNootka, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionSeminoles) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatSharktoothBowman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionSeminoles);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionSeminoles, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionTupi) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatBlackwoodArcher, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercBlackwoodArcher, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionTupi);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionTupi, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionHuron) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatHuronMantlet, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercHuronMantlet, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionHuron);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionHuron, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionZapotec) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatLightningWarrior, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercLightningWarrior, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionZapotec);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionZapotec, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionKlamath) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatKlamathRifleman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionKlamath);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionKlamath, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionApache) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatApacheCavalry, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionApache);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionApache, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionNavajo) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatNavajoRifleman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionNavajo);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionNavajo, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionCheyenne) == cTechStatusObtainable) &&
	(kbUnitCount(cMyID, cUnitTypeNatCheyenneRider, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeNatMercCheyenneRider, cUnitStateAlive) >= 6))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionCheyenne);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionCheyenne, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechChampionMapuche) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeNatMapucheClubman, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechChampionMapuche);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechChampionMapuche, getUnit(cUnitTypeTradingPost), cMilitaryEscrowID, 50);
		return;
	}
}

rule minorAsianDisciplinedUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Get disciplined upgrades for minor Asian civilizations one at the time, provided a sufficient number of units to be improved are available
	// Research plans are "blindly" tried at different trading posts as there is no way to identify specific trading posts in the AI script
	
	if ((kbTechGetStatus(cTechypNatDisciplinedBhakti) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatTigerClaw, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercTigerClaw, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedBhakti);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatDisciplinedBhakti, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatDisciplinedJesuit) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatConquistador, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercConquistador, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedJesuit);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatDisciplinedJesuit, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatDisciplinedShaolin) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatRattanShield, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercRattanShield, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedShaolin);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatDisciplinedShaolin, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatDisciplinedSufi) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatWarElephant, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercWarElephant, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedSufi);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatDisciplinedSufi, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatDisciplinedUdasi) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatChakram, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercChakram, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedUdasi);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatDisciplinedUdasi, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatDisciplinedZen) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatSohei, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercSohei, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatDisciplinedZen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatDisciplinedZen, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
}

rule minorAsianHonoredUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Get honored upgrades for minor Asian civilizations one at the time, provided a sufficient number of units to be improved are available
	// Research plans are "blindly" tried at different trading posts as there is no way to identify specific trading posts in the AI script
	
	if ((kbTechGetStatus(cTechypNatHonoredBhakti) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatTigerClaw, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercTigerClaw, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredBhakti);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatHonoredBhakti, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatHonoredJesuit) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatConquistador, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercConquistador, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredJesuit);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatHonoredJesuit, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatHonoredShaolin) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatRattanShield, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercRattanShield, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredShaolin);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatHonoredShaolin, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatHonoredSufi) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatWarElephant, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercWarElephant, cUnitStateAlive) >= 4))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredSufi);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatHonoredSufi, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatHonoredUdasi) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatChakram, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercChakram, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredUdasi);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatHonoredUdasi, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
	if ((kbTechGetStatus(cTechypNatHonoredZen) == cTechStatusObtainable) && 
	(kbUnitCount(cMyID, cUnitTypeypNatSohei, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypeypNatMercSohei, cUnitStateAlive) >= 10))
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypNatHonoredZen);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypNatHonoredZen, getUnit(cUnitTypeypTradingPostAsian), cMilitaryEscrowID, 50);
		return;
	}
}

rule maintainCreeCoureurs
inactive
mininterval 30
{
	static int creePlan = -1;
	int limit = 0;
	
	// Check build limit, exit if no cree coureurs are available
	limit = kbGetBuildLimit(cMyID, cUnitTypeCoureurCree);
	if (limit < 1)
	return;
	
	// Create/update maintain plan
	if (creePlan < 0)
	{
		creePlan = createSimpleMaintainPlan(cUnitTypeCoureurCree, limit, true, kbBaseGetMainID(cMyID), 1);
	}
	else
	{
		aiPlanSetVariableInt(creePlan, cTrainPlanNumberToMaintain, 0, limit);
	}
}

rule fortUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	
	// Disable rule once both upgrades are available
	if ((kbTechGetStatus(cTechRevetment) == cTechStatusActive) &&
	(kbTechGetStatus(cTechStarFort) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there is no fort
	if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) < 1)
	{
		return;
	}
	
	// Get upgrades one at a time as they become available
	if (kbTechGetStatus(cTechRevetment) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechRevetment);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechRevetment, getUnit(cUnitTypeFortFrontier), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechStarFort) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechStarFort);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechStarFort, getUnit(cUnitTypeFortFrontier), cMilitaryEscrowID, 50);
		return;
	}
}

rule agraFortUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	int agraFortType = -1;
	
	// Disable rule once both upgrades are available
	if ((kbTechGetStatus(cTechypFrontierAgra) == cTechStatusActive) &&
	(kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Check for agra fort
	if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort2, cUnitStateAlive) > 0)
	{
		agraFortType = cUnitTypeypWIAgraFort2;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort3, cUnitStateAlive) > 0)
	{
		agraFortType = cUnitTypeypWIAgraFort3;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort4, cUnitStateAlive) > 0)
	{
		agraFortType = cUnitTypeypWIAgraFort4;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWIAgraFort5, cUnitStateAlive) > 0)
	{
		agraFortType = cUnitTypeypWIAgraFort5;
	}
	
	// Quit if there is no agra fort
	if (agraFortType < 0)
	{
		return;
	}
	
	// Get upgrades one at a time as they become available
	if (kbTechGetStatus(cTechypFrontierAgra) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypFrontierAgra);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypFrontierAgra, getUnit(agraFortType), cMilitaryEscrowID, 50);
		return;
	}
	if (kbTechGetStatus(cTechypFortifiedAgra) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypFortifiedAgra);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypFortifiedAgra, getUnit(agraFortType), cMilitaryEscrowID, 50);
		return;
	}
}

rule shrineUpgradeMonitor
inactive
minInterval 90
{
	int upgradePlanID = -1;
	int limit = 0;
	
	// Disable rule once the upgrade is available
	if (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusActive) 
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there are not at least 16 shrines, or a toshogu shrine and at least 10 normal ones
	if ((kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine2, cUnitStateAlive) > 0) ||
		(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine3, cUnitStateAlive) > 0) ||
		(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine4, cUnitStateAlive) > 0) ||
	(kbUnitCount(cMyID, cUnitTypeypWJToshoguShrine5, cUnitStateAlive) > 0))
	{
		limit = 10;
	}
	else
	{
		limit = 16;
	}
	if (kbUnitCount(cMyID, cUnitTypeypShrineJapanese, cUnitStateAlive) < limit)
	{
		return;
	}
	
	// Get upgrade
	/*
		if (kbTechGetStatus(cTechypShrineFortressUpgrade) == cTechStatusObtainable)
		{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypShrineFortressUpgrade);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypShrineFortressUpgrade, getUnit(cUnitTypeypShrineJapanese), cEconomyEscrowID, 50);
		return;
		}
	*/
}

rule dojoUpgradeMonitor
inactive
minInterval 60
{
	int upgradePlanID = -1;
	
	// Disable rule once the upgrade is available
	if (kbTechGetStatus(cTechypDojoUpgrade1) == cTechStatusActive) 
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there is no dojo
	if (kbUnitCount(cMyID, cUnitTypeypDojo, cUnitStateAlive) < 1)
	{
		return;
	}
	
	// Get upgrade
	if (kbTechGetStatus(cTechypDojoUpgrade1) == cTechStatusObtainable)
	{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypDojoUpgrade1);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypDojoUpgrade1, getUnit(cUnitTypeypDojo), cMilitaryEscrowID, 50);
		return;
	}
}

rule villageUpgradeMonitor
inactive
group tcComplete
minInterval 15
{
	int upgradePlanID = -1;
	
	// Disable rule for anybody but Chinese
	if ((cMyCiv != cCivChinese) && (cMyCiv != cCivSPCChinese))
	{
		xsDisableSelf();
		return;
	}
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechypVillagePopCapIncrease) == cTechStatusActive) &&
		(kbTechGetStatus(cTechypVillagePopCapIncrease2) == cTechStatusActive) &&
		(kbTechGetStatus(cTechypVillagePopCapIncrease3) == cTechStatusActive) &&
	(kbTechGetStatus(cTechypVillagePopCapIncrease4) == cTechStatusActive))
	{
		xsDisableSelf();
		return;
	}
	
	// Quit if there is no village around
	if (kbUnitCount(cMyID, cUnitTypeypVillage, cUnitStateAlive) < 1)
	{
		return;
	}
	/*
		// Get upgrades one at a time upon advancing in age
		if ((kbTechGetStatus(cTechypVillagePopCapIncrease) == cTechStatusObtainable) && (kbGetAge() >= cAge2))
		{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypVillagePopCapIncrease, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 85);
		return;
		}
		if ((kbTechGetStatus(cTechypVillagePopCapIncrease2) == cTechStatusObtainable) && (kbGetAge() >= cAge3))
		{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease2);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypVillagePopCapIncrease2, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 85);
		return;
		}
		if ((kbTechGetStatus(cTechypVillagePopCapIncrease3) == cTechStatusObtainable) && (kbGetAge() >= cAge4))
		{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease3);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypVillagePopCapIncrease3, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 50);
		return;
		}
		if ((kbTechGetStatus(cTechypVillagePopCapIncrease4) == cTechStatusObtainable) && (kbGetAge() >= cAge5))
		{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypVillagePopCapIncrease4);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypVillagePopCapIncrease4, getUnit(cUnitTypeypVillage), cEconomyEscrowID, 50);
		return;
		}
	*/
}

rule factoryUpgradeMonitor
inactive
minInterval 45
{
	int upgradePlanID = -1;
	
	// Quit if there is no factory around
	if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) < 1)
	{
		return;
	}
	
	// Disable rule once all upgrades are available
	if ((kbTechGetStatus(cTechFactorySteamPower) == cTechStatusActive) &&
		(kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusActive) &&
		((kbTechGetStatus(cTechImperialBombard) == cTechStatusActive) ||
			(kbTechGetStatus(cTechImperialCannon) == cTechStatusActive) ||
		(kbTechGetStatus(cTechImperialRocket) == cTechStatusActive)))
		{
			xsDisableSelf();
			return;
		}
		/*
			// Get upgrades as they become useful
			if (kbTechGetStatus(cTechFactoryMassProduction) == cTechStatusObtainable)
			{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactoryMassProduction);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechFactoryMassProduction, getUnit(cUnitTypeFactory), cMilitaryEscrowID, 85);
			return;
			}
			if ((kbTechGetStatus(cTechFactorySteamPower) == cTechStatusObtainable) && (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 1))
			{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechFactorySteamPower);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechFactorySteamPower, getUnit(cUnitTypeFactory), cEconomyEscrowID, 85);
			return;
			}
			if ((kbTechGetStatus(cTechImperialBombard) == cTechStatusObtainable) && 
			(kbCanAffordTech(cTechImperialBombard, cMilitaryEscrowID) == true) && 
			(kbUnitCount(cMyID, cUnitTypeGreatBombard, cUnitStateAlive) >= 4))
			{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialBombard);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechImperialBombard, getUnit(cUnitTypeFactory), cMilitaryEscrowID, 50);
			return;
			}
			if ((kbTechGetStatus(cTechImperialCannon) == cTechStatusObtainable) && 
			(kbCanAffordTech(cTechImperialCannon, cMilitaryEscrowID) == true) && 
			(kbUnitCount(cMyID, cUnitTypeCannon, cUnitStateAlive) >= 4))
			{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialCannon);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechImperialCannon, getUnit(cUnitTypeFactory), cMilitaryEscrowID, 50);
			return;
			}
			if ((kbTechGetStatus(cTechImperialRocket) == cTechStatusObtainable) && 
			(kbCanAffordTech(cTechImperialRocket, cMilitaryEscrowID) == true) && 
			(kbUnitCount(cMyID, cUnitTypeRocket, cUnitStateAlive) >= 4))
			{
			upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechImperialRocket);
			if (upgradePlanID >= 0)
			aiPlanDestroy(upgradePlanID);
			createSimpleResearchPlan(cTechImperialRocket, getUnit(cUnitTypeFactory), cMilitaryEscrowID, 50);
			return;
			}
		*/
}

rule sacredFieldMonitor
inactive
minInterval 60
{
	
	static int cowPlan = -1;
	int numHerdables = 0;
	int numCows = 0;
	
	// Build a sacred field if there is none
	if (kbUnitCount(cMyID, cUnitTypeypSacredField, cUnitStateAlive) < 1)
	{
		createSimpleBuildPlan(cUnitTypeypSacredField, 1, 50, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1);
		return;
	}
	
	// Check number of captured herdables, add sacred cows as necessary to bring total number to 10
	numHerdables = kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive) - kbUnitCount(cMyID, cUnitTypeypSacredCow, cUnitStateAlive);
	if (numHerdables < 0)
	numHerdables = 0;
	numCows = 10 - numHerdables;
	if (numCows > 0)
	{
		// Create/update maintain plan
		if (cowPlan < 0)
		{
			cowPlan = createSimpleMaintainPlan(cUnitTypeypSacredCow, numCows, true, kbBaseGetMainID(cMyID), 1);
		}
		else
		{
			aiPlanSetVariableInt(cowPlan, cTrainPlanNumberToMaintain, 0, numCows);
		}
	}
	
	int upgradePlanID = -1;
	/*
		// Get XP upgrade
		if (kbTechGetStatus(cTechypLivestockHoliness) == cTechStatusObtainable)
		{
		upgradePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypLivestockHoliness);
		if (upgradePlanID >= 0)
		aiPlanDestroy(upgradePlanID);
		createSimpleResearchPlan(cTechypLivestockHoliness, getUnit(cUnitTypeypSacredField), cMilitaryEscrowID, 50);
		return;
		}
	*/
}

rule wagonMonitor
inactive
group tcComplete
minInterval 20
{
	int planID = -1;

	if (kbUnitCount(cMyID, cUnitTypexpBuilderStart, cUnitStateAlive) > 0)
	{
		//planID = createSimpleBuildPlan(gFarmUnit, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		planID = createLocationBuildPlan(gFarmUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
		aiPlanAddUnitType(planID, cUnitTypexpBuilderStart, 1, 1, 1);
	}
	
	if (kbUnitCount(cMyID, cUnitTypexpBuilder, cUnitStateAlive) > 0)
	{
		//planID = createSimpleBuildPlan(gFarmUnit, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		planID = createLocationBuildPlan(gPlantationUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
		aiPlanAddUnitType(planID, cUnitTypexpBuilder, 1, 1, 1);
	}
	if (kbUnitCount(cMyID, cUnitTypexpBuilderWar, cUnitStateAlive) > 0)
	{
		planID = createLocationBuildPlan(gStableUnit, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
		aiPlanAddUnitType(planID, cUnitTypexpBuilderWar, 1, 1, 1);
	}
	
	
	
	if ((kbUnitCount(cMyID, cUnitTypeYPVillageWagon, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypVillage) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeypVillage, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeYPVillageWagon, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeYPGroveWagon, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypGroveBuilding) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeypGroveBuilding, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeYPGroveWagon, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeypArsenalWagon, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypArsenalAsian) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeypArsenalAsian, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeypArsenalWagon, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeypBankWagon, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypBankAsian) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeypBankAsian, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeypBankWagon, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeypChurchWagon, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeypChurch) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeypChurch, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeypChurchWagon, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeypBlockhouseWagon, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeBlockhouse) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeBlockhouse, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeypBlockhouseWagon, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeFarmTravois, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFarm) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeFarm, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeFarmTravois, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeWarHutTravois, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeWarHut) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeWarHut, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeWarHutTravois, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeNoblesHutTravois, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeNoblesHut) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeNoblesHut, 1, 75, true, cMilitaryEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeNoblesHutTravois, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeWagonBuildings, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gHouseUnit) < 0))
	{
		planID = createSimpleBuildPlan(gHouseUnit, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeWagonBuildings, 1, 1, 1);
	}
	if ((kbUnitCount(cMyID, cUnitTypeLumberWagon, cUnitStateAlive) > 0) &&
	(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeLumberCamp) < 0))
	{
		planID = createSimpleBuildPlan(cUnitTypeLumberCamp, 1, 75, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 0);
		aiPlanAddUnitType(planID, cUnitTypeLumberWagon, 1, 1, 1);
	}
}

/*
	rule upgradetocivilization
	inactive
	minInterval 30
	{
	if (kbTechGetStatus(cTechImpImmigrants) == cTechStatusActive)
	{
	xsDisableSelf();
	return;
	}
	int TownCenter = getUnit(gTownCenter, cMyID, cUnitStateAlive);
	if (TownCenter >= 0)
	{
	createSimpleResearchPlan(cTechImpImmigrants,TownCenter,cEconomyEscrowID, 80);
	xsDisableSelf();
	
	}
	}
*/
/*
	rule upgradetocivilizationnative
	inactive
	minInterval 30
	{
	if (kbTechGetStatus(cTechImpImmigrantsNative) == cTechStatusActive)
	{
	xsDisableSelf();
	return;
	}
	int TownCenter = getUnit(gTownCenter, cMyID, cUnitStateAlive);
	if (TownCenter >= 0)
	{
	createSimpleResearchPlan(cTechImpImmigrantsNative,TownCenter,cEconomyEscrowID, 80);
	xsDisableSelf();
	
	}
	}
*/
/*
	rule upgradetocivilizationchinese
	inactive
	minInterval 30
	{
	if (kbTechGetStatus(cTechImpImmigrantsAsian) == cTechStatusActive)
	{
	xsDisableSelf();
	return;
	}
	int TownCenter = getUnit(gTownCenter, cMyID, cUnitStateAlive);
	if (TownCenter >= 0)
	{
	createSimpleResearchPlan(cTechImpImmigrantsAsian,TownCenter,cEconomyEscrowID, 80);
	xsDisableSelf();
	
	}
	}
*/
/*
	rule upgradetoconfederacy
	inactive
	minInterval 30
	{
	
	if (kbTechGetStatus(cTechConSupport) == cTechStatusActive)
	{
	xsDisableSelf();
	return;
	}
	int NativeEmbassy = getUnit(cUnitTypeNativeEmbassy, cMyID, cUnitStateAlive);
	if (NativeEmbassy >= 0)
	{
	createSimpleResearchPlan(cTechConSupport,NativeEmbassy,cEconomyEscrowID, 80);
	xsDisableSelf();
	
	}
	}
*/

/*
	rule morebanks
	inactive
	minInterval 30
	{
	if (kbTechGetStatus(cTechImpExcessiveTaxationD) == cTechStatusActive)
	{
	xsDisableSelf();
	return;
	}
	int Bank = getUnit(cUnitTypeBank, cMyID, cUnitStateAlive);
	if (Bank >= 0)
	{
	createSimpleResearchPlan(cTechImpExcessiveTaxationD,Bank,cEconomyEscrowID, 80);
	xsDisableSelf();
	
	}
	}
*/

rule brigadeMonitor
inactive
minInterval 120
{
	// Quit if there is no consulate
	if (kbUnitCount(cMyID, cUnitTypeypConsulate, cUnitStateAlive) < 1)
	{
		return;
	}
	
	// Research brigade technologies
	// Unavailable ones are simply ignored
	int brigadePlanID = -1;
	
	// British brigade
	if (kbTechGetStatus(cTechypConsulateBritishBrigade) == cTechStatusObtainable)
	{
		brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateBritishBrigade);
		if (brigadePlanID >= 0)
		aiPlanDestroy(brigadePlanID);
		createSimpleResearchPlan(cTechypConsulateBritishBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// Dutch brigade
	// (skipped to avoid mortars)
	
	// French brigade
	if (kbTechGetStatus(cTechypConsulateFrenchBrigade) == cTechStatusObtainable)
	{
		brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateFrenchBrigade);
		if (brigadePlanID >= 0)
		aiPlanDestroy(brigadePlanID);
		createSimpleResearchPlan(cTechypConsulateFrenchBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// German brigade
	if (kbTechGetStatus(cTechypConsulateGermansBrigade) == cTechStatusObtainable)
	{
		brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateGermansBrigade);
		if (brigadePlanID >= 0)
		aiPlanDestroy(brigadePlanID);
		createSimpleResearchPlan(cTechypConsulateGermansBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// Ottoman brigade
	if (kbTechGetStatus(cTechypConsulateOttomansBrigade) == cTechStatusObtainable)
	{
		brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateOttomansBrigade);
		if (brigadePlanID >= 0)
		aiPlanDestroy(brigadePlanID);
		createSimpleResearchPlan(cTechypConsulateOttomansBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// Portuguese brigade
	if (kbTechGetStatus(cTechypConsulatePortugueseBrigade) == cTechStatusObtainable)
	{
		brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulatePortugueseBrigade);
		if (brigadePlanID >= 0)
		aiPlanDestroy(brigadePlanID);
		createSimpleResearchPlan(cTechypConsulatePortugueseBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// Russian brigade
	if (kbTechGetStatus(cTechypConsulateRussianBrigade) == cTechStatusObtainable)
	{
		brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateRussianBrigade);
		if (brigadePlanID >= 0)
		aiPlanDestroy(brigadePlanID);
		createSimpleResearchPlan(cTechypConsulateRussianBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
	
	// Spanish brigade
	if (kbTechGetStatus(cTechypConsulateSpanishBrigade) == cTechStatusObtainable)
	{
		brigadePlanID = aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, cTechypConsulateSpanishBrigade);
		if (brigadePlanID >= 0)
		aiPlanDestroy(brigadePlanID);
		createSimpleResearchPlan(cTechypConsulateSpanishBrigade, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 50);
		return;
	}
}

rule consulateLevy
inactive
minInterval 10
{
	// Check to see if town is being overrun. If so, generate a plan
	// to research Ottoman levy at the consulate. 
	
	int levyPlan = -1;
	vector mainBaseVec = cInvalidVector;
	
	mainBaseVec =  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	int enemyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, mainBaseVec, 40.0);
	int allyCount = getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationAlly, cUnitStateAlive, mainBaseVec, 40.0);
	
	if (enemyCount >= (allyCount+6)) // We're behind by 6 or more
	{
		//aiEcho("***** Starting consulate levy plan, there are "+enemyCount+" enemy units in my base against "+allyCount+" friendlies.");
		if (kbTechGetStatus(cTechypConsulateOttomansSettlerCombat) == cTechStatusObtainable)
		levyPlan = createSimpleResearchPlan(cTechypConsulateOttomansSettlerCombat, getUnit(cUnitTypeypConsulate), cMilitaryEscrowID, 99); // Extreme priority
	}
}

rule porcelainTowerTacticMonitor
inactive
group tcComplete
mininterval 60
{
	// Disable rule for anybody but Chinese
	if (kbGetCiv() != cCivChinese)
	{
		xsDisableSelf();
		return;
	}
	
	int porcelainTowerType = -1;
	static int resourceType = -1;
	
	// Check for porcelain tower
	if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower2, cUnitStateAlive) > 0)
	{
		porcelainTowerType = cUnitTypeypWCPorcelainTower2;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower3, cUnitStateAlive) > 0)
	{
		porcelainTowerType = cUnitTypeypWCPorcelainTower3;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower4, cUnitStateAlive) > 0)
	{
		porcelainTowerType = cUnitTypeypWCPorcelainTower4;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWCPorcelainTower5, cUnitStateAlive) > 0)
	{
		porcelainTowerType = cUnitTypeypWCPorcelainTower5;
	}
	
	if (porcelainTowerType > 0)
	{
		int porcelainTowerQueryID = -1;
		porcelainTowerQueryID = kbUnitQueryCreate("porcelainTowerQueryID");
		kbUnitQuerySetIgnoreKnockedOutUnits(porcelainTowerQueryID, true);
		if (porcelainTowerQueryID != -1)
		{
			kbUnitQuerySetPlayerRelation(porcelainTowerQueryID, -1);
			kbUnitQuerySetPlayerID(porcelainTowerQueryID, cMyID);
			kbUnitQuerySetUnitType(porcelainTowerQueryID, porcelainTowerType);
			kbUnitQuerySetState(porcelainTowerQueryID, cUnitStateAlive);
			kbUnitQueryResetResults(porcelainTowerQueryID);
			int numberFound = kbUnitQueryExecute(porcelainTowerQueryID);
			
			// Cycle resource generation through all three resources
			// (resources types are 0 - food, 1 - wood, 2 - coin)
			if (numberFound > 0)
			{
				resourceType = resourceType + 1;
				if (resourceType > 2)
				resourceType = 0;
				switch (resourceType)
				{
					case 0:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, 0), cTacticWonderFood);
						break;
					}
					case 1:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, 0), cTacticWonderWood);
						break;
					}
					case 2:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, 0), cTacticWonderCoin);
						break;
					}
					default: // catch-all, should never happen
					{
						aiUnitSetTactic(kbUnitQueryGetResult(porcelainTowerQueryID, 0), cTacticWonderRainbow);
						break;
					}
				}
			}
		}
	}
}

rule summerPalaceTacticMonitor
inactive
mininterval 10
{
	int summerPalaceType = -1;
	int randomizer = -1;
	
	// Check for summer palace
	if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace2, cUnitStateAlive) > 0)
	{
		summerPalaceType = cUnitTypeypWCSummerPalace2;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace3, cUnitStateAlive) > 0)
	{
		summerPalaceType = cUnitTypeypWCSummerPalace3;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace4, cUnitStateAlive) > 0)
	{
		summerPalaceType = cUnitTypeypWCSummerPalace4;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWCSummerPalace5, cUnitStateAlive) > 0)
	{
		summerPalaceType = cUnitTypeypWCSummerPalace5;
	}
	
	if (summerPalaceType > 0)
	{
		int summerPalaceQueryID = -1;
		summerPalaceQueryID = kbUnitQueryCreate("summerPalaceQueryID");
		kbUnitQuerySetIgnoreKnockedOutUnits(summerPalaceQueryID, true);
		if (summerPalaceQueryID != -1)
		{
			kbUnitQuerySetPlayerRelation(summerPalaceQueryID, -1);
			kbUnitQuerySetPlayerID(summerPalaceQueryID, cMyID);
			kbUnitQuerySetUnitType(summerPalaceQueryID, summerPalaceType);
			kbUnitQuerySetState(summerPalaceQueryID, cUnitStateAlive);
			kbUnitQueryResetResults(summerPalaceQueryID);
			int numberFound = kbUnitQueryExecute(summerPalaceQueryID);
			
			// In Age 3 and above, spawn either territorial, forbidden or imperial army
			// In Age 2, stay with standard army (default)
			if ((numberFound > 0) && (kbGetAge() >= cAge3))
			{
				randomizer = aiRandInt(3);
				switch (randomizer)
				{
					case 0:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(summerPalaceQueryID, 0), cTacticTerritorialArmy);
						break;
					}
					case 1:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(summerPalaceQueryID, 0), cTacticForbiddenArmy);
						break;
					}
					default:
					{
						aiUnitSetTactic(kbUnitQueryGetResult(summerPalaceQueryID, 0), cTacticImperialArmy);
						break;
					}
				}
				
				// Disable rule once a new tactic has been set
				xsDisableSelf();
			}
		}
	}
}

rule goldenPavillionTacticMonitor
inactive
group tcComplete
mininterval 60
{
	// Disable rule for anybody but Japanese
	if (kbGetCiv() != cCivJapanese)
	{
		xsDisableSelf();
		return;
	}
	
	int goldenPavillionType = -1;
	
	// Check for golden pavillion
	if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion2, cUnitStateAlive) > 0)
	{
		goldenPavillionType = cUnitTypeypWJGoldenPavillion2;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion3, cUnitStateAlive) > 0)
	{
		goldenPavillionType = cUnitTypeypWJGoldenPavillion3;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion4, cUnitStateAlive) > 0)
	{
		goldenPavillionType = cUnitTypeypWJGoldenPavillion4;
	}
	else if (kbUnitCount(cMyID, cUnitTypeypWJGoldenPavillion5, cUnitStateAlive) > 0)
	{
		goldenPavillionType = cUnitTypeypWJGoldenPavillion5;
	}
	
	if (goldenPavillionType > 0)
	{
		int goldenPavillionQueryID = -1;
		goldenPavillionQueryID = kbUnitQueryCreate("goldenPavillionQueryID");
		kbUnitQuerySetIgnoreKnockedOutUnits(goldenPavillionQueryID, true);
		if (goldenPavillionQueryID != -1)
		{
			kbUnitQuerySetPlayerRelation(goldenPavillionQueryID, -1);
			kbUnitQuerySetPlayerID(goldenPavillionQueryID, cMyID);
			kbUnitQuerySetUnitType(goldenPavillionQueryID, goldenPavillionType);
			kbUnitQuerySetState(goldenPavillionQueryID, cUnitStateAlive);
			kbUnitQueryResetResults(goldenPavillionQueryID);
			int numberFound = kbUnitQueryExecute(goldenPavillionQueryID);
			
			// Activate land military hitpoint bonus and disable rule
			if (numberFound > 0)
			{
				aiUnitSetTactic(kbUnitQueryGetResult(goldenPavillionQueryID, 0), cTacticUnitHitpoints);
				xsDisableSelf();
			}
		}
	}
}

rule dojoTacticMonitor
inactive
minInterval 10
{
	int randomizer = -1;
	static int dojoTactic1 = -1;
	static int dojoTactic2 = -1;
	
	// Randomize unit generation option for first dojo
	if (dojoTactic1 < 0)
	{
		randomizer = aiRandInt(5);
		switch (randomizer)
		{
			case 0:
			{
				dojoTactic1 = cTacticYumi;
				break;
			}
			case 1:
			{
				dojoTactic1 = cTacticAshigaru;
				break;
			}
			case 2:
			{
				dojoTactic1 = cTacticSamurai;
				break;
			}
			case 3:
			{
				dojoTactic1 = cTacticNaginataRider;
				break;
			}
			default:
			{
				dojoTactic1 = cTacticYabusame;
				break;
			}
		}
	}
	
	// Randomize unit generation option for second dojo
	if (dojoTactic2 < 0)
	{
		randomizer = aiRandInt(5);
		switch (randomizer)
		{
			case 0:
			{
				dojoTactic2 = cTacticYumi;
				break;
			}
			case 1:
			{
				dojoTactic2 = cTacticAshigaru;
				break;
			}
			case 2:
			{
				dojoTactic2 = cTacticSamurai;
				break;
			}
			case 3:
			{
				dojoTactic2 = cTacticNaginataRider;
				break;
			}
			default:
			{
				dojoTactic2 = cTacticYabusame;
				break;
			}
		}
	}
	
	// Define a query to get all matching units
	int dojoQueryID=-1;
	dojoQueryID=kbUnitQueryCreate("dojoGetUnitQuery");
	kbUnitQuerySetIgnoreKnockedOutUnits(dojoQueryID, true);
	if (dojoQueryID != -1)
	{
		kbUnitQuerySetPlayerRelation(dojoQueryID, -1);
		kbUnitQuerySetPlayerID(dojoQueryID, cMyID);
		kbUnitQuerySetUnitType(dojoQueryID, cUnitTypeypDojo);
		kbUnitQuerySetState(dojoQueryID, cUnitStateAlive);
		kbUnitQueryResetResults(dojoQueryID);
		int numberFound=kbUnitQueryExecute(dojoQueryID);
		if (numberFound == 1)
		{
			aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 0), dojoTactic1);
		}
		else if (numberFound == 2)
		{
			aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 0), dojoTactic1);
			aiUnitSetTactic(kbUnitQueryGetResult(dojoQueryID, 1), dojoTactic2);
			xsDisableSelf();
		}
	}
}
//==============================================================================
/* factoryTacticMonitor
	updatedOn 2020/02/02 By ageekhere  
*/
//==============================================================================
rule factoryTacticMonitor
inactive
minInterval 10
{
	// Define a query to get all matching units
	static int factoryQueryID=-1;
	
	if (factoryQueryID==-1)
	{
		factoryQueryID=kbUnitQueryCreate("factoryGetUnitQuery");
		kbUnitQuerySetIgnoreKnockedOutUnits(factoryQueryID, true);
		kbUnitQuerySetPlayerRelation(factoryQueryID, -1);
		kbUnitQuerySetPlayerID(factoryQueryID, cMyID, false);
		kbUnitQuerySetUnitType(factoryQueryID, cUnitTypeFactory);
		kbUnitQuerySetState(factoryQueryID, cUnitStateAlive);
	}
	
	int setTatic = cTacticWood;
	if(kbResourceGet(cResourceWood) > 1000)
	{
		if(kbResourceGet(cResourceGold) > kbResourceGet(cResourceFood)) setTatic = cTacticFood;	  
		if(kbResourceGet(cResourceGold) < kbResourceGet(cResourceFood)) setTatic = cTacticCoin;	  
	}
	
	if (factoryQueryID != -1)
	{
		kbUnitQueryResetResults(factoryQueryID);
		int numberFound=kbUnitQueryExecute(factoryQueryID);
		if (numberFound == 1)
		{
			aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, 0), setTatic);
		}
		else if (numberFound > 1)
		{
			aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, 0), setTatic);
			aiUnitSetTactic(kbUnitQueryGetResult(factoryQueryID, 1), setTatic);
			xsDisableSelf();
			kbUnitQueryDestroy(factoryQueryID);
		}
	}
}



rule mansabdarMonitor
inactive
minInterval 10
{
	static int mansabdarRajputPlan = -1;
	static int mansabdarSepoyPlan = -1;
	static int mansabdarGurkhaPlan = -1;
	static int mansabdarSowarPlan = -1;
	static int mansabdarZamburakPlan = -1;
	
	int numRajputs = -1;
	int numSepoys = -1;
	int numGurkhas = -1;
	int numSowars = -1;
	int numZamburaks = -1;
	
	// Check number of rajputs, maintain mansabdar rajput as long as there are at least 10
	numRajputs = kbUnitCount(cMyID, cUnitTypeypRajput, cUnitStateAlive);
	if (numRajputs >= 10)
	{
		// Create/update maintain plan
		if (mansabdarRajputPlan < 0)
		{
			mansabdarRajputPlan = createSimpleMaintainPlan(cUnitTypeypRajputMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
		}
		else
		{
			aiPlanSetVariableInt(mansabdarRajputPlan , cTrainPlanNumberToMaintain, 0, 1);
		}
	}
	else
	{
		// Update maintain plan, provided it exists
		if (mansabdarRajputPlan >= 0)
		{
			aiPlanSetVariableInt(mansabdarRajputPlan , cTrainPlanNumberToMaintain, 0, 0);
		}
	}
	// Check number of sepoys, maintain mansabdar sepoy as long as there are at least 10
	numSepoys = kbUnitCount(cMyID, cUnitTypeypSepoy, cUnitStateAlive);
	if (numSepoys >= 10)
	{
		// Create/update maintain plan
		if (mansabdarSepoyPlan < 0)
		{
			mansabdarSepoyPlan = createSimpleMaintainPlan(cUnitTypeypSepoyMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
		}
		else
		{
			aiPlanSetVariableInt(mansabdarSepoyPlan , cTrainPlanNumberToMaintain, 0, 1);
		}
	}
	else
	{
		// Update maintain plan, provided it exists
		if (mansabdarSepoyPlan >= 0)
		{
			aiPlanSetVariableInt(mansabdarSepoyPlan , cTrainPlanNumberToMaintain, 0, 0);
		}
	}
	// Check number of gurkhas, maintain mansabdar gurkha as long as there are at least 10
	numGurkhas = kbUnitCount(cMyID, cUnitTypeypNatMercGurkha, cUnitStateAlive);
	if (numGurkhas >= 10)
	{
		// Create/update maintain plan
		if (mansabdarGurkhaPlan < 0)
		{
			mansabdarGurkhaPlan = createSimpleMaintainPlan(cUnitTypeypNatMercGurkhaJemadar, 1, false, kbBaseGetMainID(cMyID), 1);
		}
		else
		{
			aiPlanSetVariableInt(mansabdarGurkhaPlan , cTrainPlanNumberToMaintain, 0, 1);
		}
	}
	else
	{
		// Update maintain plan, provided it exists
		if (mansabdarGurkhaPlan >= 0)
		{
			aiPlanSetVariableInt(mansabdarGurkhaPlan , cTrainPlanNumberToMaintain, 0, 0);
		}
	}
	// Check number of sowars, maintain mansabdar sowar as long as there are at least 10
	numSowars = kbUnitCount(cMyID, cUnitTypeypSowar, cUnitStateAlive);
	if (numSowars >= 10)
	{
		// Create/update maintain plan
		if (mansabdarSowarPlan < 0)
		{
			mansabdarSowarPlan = createSimpleMaintainPlan(cUnitTypeypSowarMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
		}
		else
		{
			aiPlanSetVariableInt(mansabdarSowarPlan , cTrainPlanNumberToMaintain, 0, 1);
		}
	}
	else
	{
		// Update maintain plan, provided it exists
		if (mansabdarSowarPlan >= 0)
		{
			aiPlanSetVariableInt(mansabdarSowarPlan , cTrainPlanNumberToMaintain, 0, 0);
		}
	}
	// Check number of zamburaks, maintain mansabdar zamburak as long as there are at least 10
	numZamburaks = kbUnitCount(cMyID, cUnitTypeypZamburak, cUnitStateAlive);
	if (numZamburaks >= 10)
	{
		// Create/update maintain plan
		if (mansabdarZamburakPlan < 0)
		{
			mansabdarZamburakPlan = createSimpleMaintainPlan(cUnitTypeypZamburakMansabdar, 1, false, kbBaseGetMainID(cMyID), 1);
		}
		else
		{
			aiPlanSetVariableInt(mansabdarZamburakPlan , cTrainPlanNumberToMaintain, 0, 1);
		}
	}
	else
	{
		// Update maintain plan, provided it exists
		if (mansabdarZamburakPlan >= 0)
		{
			aiPlanSetVariableInt(mansabdarZamburakPlan , cTrainPlanNumberToMaintain, 0, 0);
		}
	}
}
/*
	rule MercantilismMonitor
	inactive
	minInterval 10
	{
	if (kbTechGetStatus(cTechChurchMercantilism) == cTechStatusActive)
	{
	xsDisableSelf();
	return;
	}
	int Church = getUnit(cUnitTypeChurch, cMyID, cUnitStateAlive);
	if (Church >= 0)
	{
	createSimpleResearchPlan(cTechChurchMercantilism,Church,cEconomyEscrowID, 99);
	xsDisableSelf();	
	}
	}
*/

//==============================================================================
/* researchCheck, replaces old upgeade rules
	updatedOn 2019/10/11 By ageekhere  
*/
//==============================================================================

int createSimpleResearchPlanTest(int techID=-1, int buildingID=-1, int escrowID=cRootEscrowID, int pri = 50)
{
	
	if(aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, techID) != -1)
	{
		return (-1);
	}
	
	int planID=aiPlanCreate("Research "+kbGetTechName(techID), cPlanResearch);
	if (planID < 0)
	aiEcho("Failed to create simple research plan for "+techID);													  
	else
	{
		aiPlanSetVariableInt(planID, cResearchPlanTechID, 0, techID);
		aiPlanSetVariableInt(planID, cResearchPlanBuildingID, 0, buildingID);
		aiPlanSetDesiredPriority(planID, pri);
		aiPlanSetEscrowID(planID, escrowID);
		aiPlanSetActive(planID);
	}
	
	return(planID);
}


void researchCheck(int rTech = -1, int pri = -1, int buildingId = -1,int escrowID = -1)
{ //Checks to see if a new Research Plan can be made
	if(aiPlanGetIDByTypeAndVariableType(cPlanResearch, cResearchPlanTechID, rTech) != -1) return; //Check if there is allready a research plan
	if(kbTechGetStatus(rTech) == cTechStatusActive || kbTechGetStatus(rTech) != cTechStatusObtainable) return; // Disable rule once upgraded or tech is unobtainable
	if(kbUnitCount(cMyID,buildingId, cUnitStateAlive) < 1) return;
	createSimpleResearchPlanTest(rTech, getUnit(buildingId), escrowID, pri);
	
}



void researchTech()
{
	researchCheck(cTechHuntingDogs, 50, cUnitTypeMarket, cEconomyEscrowID);
	researchCheck(cTechypMarketBerryDogs, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
	researchCheck(cTechypMarketHuntingDogs, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);	
	researchCheck(cTechGangsaw, 50, cUnitTypeMarket, cEconomyEscrowID);
	researchCheck(cTechypMarketGangsaw, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
	researchCheck(cTechLumberCeremony, 50, cUnitTypeMarket, cEconomyEscrowID);		
	researchCheck(cTechPlacerMines, 50, cUnitTypeMarket, cEconomyEscrowID);
	researchCheck(cTechypMarketPlacerMines, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
	researchCheck(cTechSpiritMedicine, 50, cUnitTypeMarket, cEconomyEscrowID);	
	researchCheck(cTechypMarketSpiritMedicine, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);	
	researchCheck(cTechypMarketWheelbarrow, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
	researchCheck(cTechFrontierTraining, 50, cUnitTypeMarket, cEconomyEscrowID);
	if (kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive) >= 10) researchCheck(cTechSelectiveBreeding, 50, gFarmUnit, cEconomyEscrowID);
	if (kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive) >= 10) researchCheck(cTechSelectiveBreeding, 50, gHouseUnit, cEconomyEscrowID);
	if (kbUnitCount(cMyID, cUnitTypeypGoat, cUnitStateAlive) >= 10) researchCheck(cTechSelectiveBreeding, 50, gHouseUnit, cEconomyEscrowID);
	if (kbUnitCount(cMyID, cUnitTypeypGoat, cUnitStateAlive) >= 10) researchCheck(cTechSelectiveBreeding, 50, gHouseUnit, cEconomyEscrowID);
	if (kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive) >= 7) researchCheck(cTechGillNets, 50, gDockUnit, cEconomyEscrowID);	
	if(xsGetTime() > 1800000) researchCheck(cTechBigLonghouseWoodlandDwellers, 50, gHouseUnit, cEconomyEscrowID);		
	if(xsGetTime() > 1800000) researchCheck(cTechBigFarmStrawberry, 50, gFarmUnit, cEconomyEscrowID);	
	if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) >= 10) researchCheck(cTechBigFarmHorsemanship, 50, gFarmUnit, cEconomyEscrowID);					
	researchCheck(cTechGreatFeast, 50, gFarmUnit, cEconomyEscrowID);
	researchCheck(cTechGreatFeast, 50, gFarmUnit, cEconomyEscrowID);			
	researchCheck(cTechypLivestockHoliness, 50, cUnitTypeypSacredField, cEconomyEscrowID);
	researchCheck(cTechypMonasteryPetAura, 50, cUnitTypeypMonastery, cEconomyEscrowID);
	researchCheck(cTechypMonasteryDiscipleAura, 50, cUnitTypeypMonastery, cEconomyEscrowID);
	
	if (kbGetAge() >= cAge2)
	{
		researchCheck(cTechSteelTraps, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechLogFlume, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechAmalgamation, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechForestPeopleCeremony, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechNativeMarketGold, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechForestPeopleCeremony, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechNativeMarketGold, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechypMarketCircularSaw, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypMarketSteelTraps, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypMarketWheelbarrow2, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypMarketAmalgamation, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypMarketBerryTraps, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypMarketLogFlume, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);	
		researchCheck(cTechSeedDrill, 50, cUnitTypeMill, cEconomyEscrowID);
		researchCheck(cTechHarvestCeremony, 50, gFarmUnit, cEconomyEscrowID);
		researchCheck(cTechEarthCeremony, 50, cUnitTypePlantation, cEconomyEscrowID);		
		researchCheck(cTechEarthGiftCeremony, 50, cUnitTypePlantation, cEconomyEscrowID);
		researchCheck(cTechEarthCeremony, 50, cUnitTypePlantation, cEconomyEscrowID);
		researchCheck(cTechBigPlantationGunTrade, 50, cUnitTypePlantation, cEconomyEscrowID);
		if (xsGetTime() > 1800000) researchCheck(cTechBigPlantationMapleFestival, 50, cUnitTypePlantation, cEconomyEscrowID);
		researchCheck(cTechypCultivateWasteland, 50, cUnitTypeypRicePaddy, cEconomyEscrowID);
		researchCheck(cTechypCropMarket, 50, cUnitTypeypRicePaddy, cEconomyEscrowID);
		if ((kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypexpRifleRider, cUnitStateAlive)) > 12) researchCheck(cTechBigPlantationGunTrade, 50, cUnitTypePlantation, cEconomyEscrowID);
		if (xsGetTime() > 1800000) researchCheck(cTechBigDeer, 50, gLivestockPenUnit, cEconomyEscrowID);
		if (xsGetTime() > 1800000) researchCheck(cTechBigBisons, 50, gLivestockPenUnit, cEconomyEscrowID);	
		if (kbUnitCount(cMyID, cUnitTypeMissionary, cUnitStateAlive) > 4) researchCheck(cTechChurchMissionFervor, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePriest, cUnitStateAlive) > 4) researchCheck(cTechChurchMissionFervor, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeImam, cUnitStateAlive) > 4) researchCheck(cTechChurchMissionFervor, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbGetPop() > 100) researchCheck(cTechChurchGasLighting, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchMilletSystem, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchKopruluViziers, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchAbbassidMarket, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 18) researchCheck(cTechChurchGalataTowerDistrict, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechypMonasteryImprovedHealing, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechypMonasteryShaolinWarrior, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechypMonasteryJapaneseHealing, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechypMonasteryJapaneseCombat, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechGreatCoatUS, 50, cUnitTypeSPCFortCenter, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 50) researchCheck(cTechBigWarHutLacrosse, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (xsGetTime() > 1800000) researchCheck(cTechBigWarHutBarometz, 50, cUnitTypeWarHut, cEconomyEscrowID);		
		if ((kbUnitCount(cMyID, cUnitTypexpMusketRider, cUnitStateAlive) + kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive)) >= 25) researchCheck(cTechBigCorralHorseSecrets, 50, cUnitTypeCorral, cMilitaryEscrowID);
		//researchCheck(BigFirepitSecretSociety, 50, cUnitTypeFirePit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12) researchCheck(cTechRifling, 50, gHouseUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12) researchCheck(cTechInfantryBreastplate, 50, gHouseUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12) researchCheck(cTechCaracole, 50, gHouseUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12) researchCheck(cTechCavalryCuirass, 50, gHouseUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeRanged, cUnitStateAlive) >= 12) researchCheck(cTechImprovedBows, 50, gHouseUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 5) researchCheck(cTechGunnersQuadrant, 50, gHouseUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 5) researchCheck(cTechHeatedShot, 50, gHouseUnit, cMilitaryEscrowID);
		researchCheck(cTechHarvestCeremony, 50, gFarmUnit, cEconomyEscrowID);
		researchCheck(cTechBigFirepitFounder, 50, cUnitTypeFirePit, cEconomyEscrowID);
		if (xsGetTime() > 1800000) researchCheck(cTechBigHouseCoatlicue, 50, gHouseUnit, cEconomyEscrowID);				
		if (kbUnitCount(cMyID, cUnitTypeAbstractWall, cUnitStateAlive) >= 20) researchCheck(cTechBastion, 50, cUnitTypeAbstractWall, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechBigDockRawhideCovers, 50, gDockUnit, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechBigDockFlamingArrows, 50, gDockUnit, cEconomyEscrowID);
		if (kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive) >= 14) researchCheck(cTechLongLines, 50, gDockUnit, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechArmorPlating, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechCarronade, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, gFishingUnit, cUnitStateAlive) >= 14) researchCheck(cTechLongLines, 50, gDockUnit, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechBigDockRawhideCovers, 50, gDockUnit, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechBigDockFlamingArrows, 50, gDockUnit, cEconomyEscrowID);			
		if (xsGetTime() > 1800000) researchCheck(cTechBigSiouxDogSoldiers, 50, gTownCenter, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12) researchCheck(cTechRifling, 50, cUnitTypeTeepee, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12) researchCheck(cTechInfantryBreastplate, 50, cUnitTypeTeepee, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12) researchCheck(cTechCavalryCuirass, 50, cUnitTypeTeepee, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12) researchCheck(cTechCaracole, 50, cUnitTypeTeepee, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeRanged, cUnitStateAlive) >= 12) researchCheck(cTechImprovedBows, 50, cUnitTypeTeepee, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12) researchCheck(cTechPillage, 50, cUnitTypeTeepee, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeTeepee, cUnitStateAlive) == kbGetBuildLimit(cMyID, cUnitTypeTeepee)) researchCheck(cTechBigWarrior, 50, cUnitTypeTeepee, cEconomyEscrowID);
		researchCheck(cTechypVillagePopCapIncrease, 50, cUnitTypeypVillage, cEconomyEscrowID);
	}
	
	if (kbGetAge() == cAge4)
	{
		if (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 12) researchCheck(cTechVeteranLongbowmen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeOutpost, cUnitStateAlive) > kbGetBuildLimit(cMyID, gTowerUnit) / 2) researchCheck(cTechFrontierOutpost, 50, gTowerUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMissionary, cUnitStateAlive) > 4) researchCheck(cTechChurchStateReligion, 50, cUnitTypeChurch, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFlatbowman, cUnitStateAlive) >= 12) researchCheck(cTechVeteranFlatbowman, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechVeteranMusketeers, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCavalaria, cUnitStateAlive) >= 8) researchCheck(cTechVeteranDrabants, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSchutze, cUnitStateAlive) >= 12) researchCheck(cTechVeteranSchutze, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) > kbGetBuildLimit(cMyID, gTowerUnit) / 2) researchCheck(cTechFrontierBlockhouse, 50, gTowerUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 12) researchCheck(cTechVeteranStrelets, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12) researchCheck(cTechVeteranPikemen, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechVeteranMusketeers, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCossack, cUnitStateAlive) >= 8) researchCheck(cTechVeteranCossacks, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) > kbGetBuildLimit(cMyID, gTowerUnit) / 2) researchCheck(cTechFrontierOutpost, 50, gTowerUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePriest, cUnitStateAlive) > 4) researchCheck(cTechChurchStateReligion, 50, cUnitTypeChurch, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 12) researchCheck(cTechVeteranCrossbowmen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12) researchCheck(cTechVeteranPikemen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeDopplesoldner, cUnitStateAlive) >= 12) researchCheck(cTechVeteranDopplesoldners, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeUhlan, cUnitStateAlive) >= 8) researchCheck(cTechVeteranUhlans, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 33) researchCheck(cTechChurchTopkapi, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechCircularSaw, 50, cUnitTypeMarket, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMill, cUnitStateAlive) >= 3) researchCheck(cTechArtificialFertilizer, 50, cUnitTypeMill, cEconomyEscrowID);
		
		if (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 3) researchCheck(cTechBookkeeping, 50, cUnitTypePlantation, cEconomyEscrowID);
		
		if (kbUnitCount(cMyID, cUnitTypeOutpost, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeOutpost) / 2) researchCheck(cTechFrontierOutpost, 50, cUnitTypeOutpost, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeImam, cUnitStateAlive) > 4) researchCheck(cTechChurchStateReligion, 50, cUnitTypeChurch, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 12) researchCheck(cTechVeteranJanissaries, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechVeteranHussars, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) >= 8) researchCheck(cTechVeteranAbusGuns, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechVeteranGrenadiers, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		
		if (kbUnitCount(cMyID, cUnitTypeMarine, cUnitStateAlive) >= 12) researchCheck(cTechVeteranMusketeersUS, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSaber, cUnitStateAlive) >= 8) researchCheck(cTechVeteranSabers, 50, cUnitTypeStable, cMilitaryEscrowID);
		
		if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12) researchCheck(cTechRifling, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12) researchCheck(cTechInfantryBreastplate, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractInfantry, cUnitStateAlive) >= 12) researchCheck(cTechBayonet, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 12) researchCheck(cTechCavalryCuirass, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractLightCavalry, cUnitStateAlive) >= 12) researchCheck(cTechCaracole, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeRanged, cUnitStateAlive) >= 12) researchCheck(cTechImprovedBows, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechHeatedShot, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 12) researchCheck(cTechGunnersQuadrant, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 12) researchCheck(cTechIncendiaryGrenades, 50, cUnitTypeArsenal, cMilitaryEscrowID);
		researchCheck(cTechImpPeerage, 50, cUnitTypeSPCFortCenter, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 12) researchCheck(cTechEliteAennas, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 12) researchCheck(cTechEliteTomahawks, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive) >= 8) researchCheck(cTechEliteHorsemen, 50, cUnitTypeCorral, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpRam, cUnitStateAlive) >= 5) researchCheck(cTechBigSiegeshopSiegeDrill, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMantlet, cUnitStateAlive) >= 5) researchCheck(cTechBigSiegeshopSiegeDrill, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpLightCannon, cUnitStateAlive) >= 5) researchCheck(cTechBigSiegeshopSiegeDrill, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		researchCheck(cTechypMonasteryIndianSpeed, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechypMonasteryCompunction, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechypMonasteryCriticalUpgrade, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechypMonasteryAttackSpeed, 50, cUnitTypeypMonastery, cEconomyEscrowID);				
		researchCheck(cTechypMarketCircularSaw, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractRajput, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedRajput, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractUrumi, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedUrumi, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractSepoy, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedSepoy, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) >= 8) researchCheck(cTechYPDisciplinedCamel, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) >= 8) researchCheck(cTechYPDisciplinedCamelGun, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive) >= 5) researchCheck(cTechYPDisciplinedFlailElephant, 50, cUnitTypeypCastle, cMilitaryEscrowID);			
		if (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateAlive) >= 5) researchCheck(cTechYPDisciplinedFlameThrower, 50, cUnitTypeypCastle, cMilitaryEscrowID);					
		if (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedChuKoNu, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedQiangPikeman, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedSteppeRider, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedKeshik, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		researchCheck(cTechypWaterConservancy, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypSharecropping, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypIrrigationSystems, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypMonasteryKillingBlowUpgrade, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeYPOutpostAsian, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeYPOutpostAsian) / 2) researchCheck(cTechTownGuard, 50, cUnitTypeYPOutpostAsian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechPercussionLocks, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedYumi, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 12) researchCheck(cTechYPDisciplinedAshigaru, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) >= 8) researchCheck(cTechYPDisciplinedSamurai, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) >= 8) researchCheck(cTechYPDisciplinedNaginataRider, 50, cUnitTypeypStableJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeypCastle) / 2) researchCheck(cTechypFrontierCastle, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		researchCheck(cTechTreasuryCrateAmount, 50, cUnitTypeSPCIncaTemple, cEconomyEscrowID);
		if (xsGetTime() > 1800000) researchCheck(cTechBigFarmCinteotl, 50, gFarmUnit, cEconomyEscrowID);
		if (xsGetTime() > 1800000) researchCheck(cTechBigPlantationTezcatlipoca, 50, cUnitTypePlantation, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) >= 12) researchCheck(cTechEliteCoyotemen, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 12) researchCheck(cTechEliteMacehualtins, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 12) researchCheck(cTechElitePumaMen, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeNoblesHut) / 2) researchCheck(cTechStrongNoblesHut, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		if (xsGetTime() > 1800000) researchCheck(cTechBigNoblesHutWarSong, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		researchCheck(cTechForestSpiritCeremony, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechBigMarketNewYear, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechGreenCornCeremony, 50, gFarmUnit, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractCavalry, cUnitStateAlive) >= 10) researchCheck(cTechBigCorralBonepipeArmor, 50, cUnitTypeCorral, cEconomyEscrowID);
		researchCheck(cTechBigWarHutWarDrums, 50, cUnitTypeWarHut, cEconomyEscrowID);
		researchCheck(cTechEarthGiftCeremony, 50, cUnitTypePlantation, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeWarHut) / 2) researchCheck(cTechStrongWarHut, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 12) researchCheck(cTechEliteWarBows, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 12) researchCheck(cTechEliteWarClubs, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpAxeRider, cUnitStateAlive) >= 10) researchCheck(cTechEliteAxeRiders, 50, cUnitTypeCorral, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpBowRider, cUnitStateAlive) >= 10) researchCheck(cTechEliteBowRider, 50, cUnitTypeCorral, cEconomyEscrowID);
		researchCheck(cTechypVillagePopCapIncrease2, 50, cUnitTypeypVillage, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechVeteranGrenadiersUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);	
	}
	
	if (kbGetAge() == cAge4)
	{		
		if (kbUnitCount(cMyID, cUnitTypeSaber, cUnitStateAlive) >= 8) researchCheck(cTechGuardSabers, 50, cUnitTypeStable, cMilitaryEscrowID);
		researchCheck(cTechChurchMercantilism, 50, cUnitTypeMarket, cEconomyEscrowID); //age 2 tech
		if (kbUnitCount(cMyID, cUnitTypeOutpost, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeOutpost) / 2) researchCheck(cTechFortifiedOutpost, 50, cUnitTypeOutpost, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechRGLifeGuardHussars, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 12) researchCheck(cTechGuardLongbowmen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechRGRedcoats, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		researchCheck(cTechChurchBlackWatch, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchThinRedLine, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchRogersRangers, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeLancer, cUnitStateAlive) >= 8) researchCheck(cTechRGGarrochista, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12) researchCheck(cTechRGTercio, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeRodelero, cUnitStateAlive) >= 12) researchCheck(cTechRGEspadachins, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		researchCheck(cTechChurchCorsolet, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchQuatrefage, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchWildGeeseSpanish, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechImperialLifeGuard, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 8) researchCheck(cTechGuardDragoons, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCuirassier, cUnitStateAlive) >= 8) researchCheck(cTechRGGendarmes, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFlatbowman, cUnitStateAlive) >= 12) researchCheck(cTechGuardFlatbowman, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechGuardMusketeers, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12) researchCheck(cTechRGVoltigeur, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 4) researchCheck(cTechImperialFieldGunNew, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);	
		if (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 4) researchCheck(cTechFieldGunUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 4) researchCheck(cTechGrapeShotUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 4) researchCheck(cTechHowitzerUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4) researchCheck(cTechHeavyHorseArtilleryUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		researchCheck(cTechChurchCodeNapoleon, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchGardeImperial1, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchGardeImperial2, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchGardeImperial3, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchTies, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCavalaria, cUnitStateAlive) >= 8) researchCheck(cTechGuardDrabants, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 8) researchCheck(cTechRGJinetes, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 12) researchCheck(cTechGuardHalberdiers, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechRGGuerreiros, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) >= 12) researchCheck(cTechGuardCacadores, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeOrganGun, cUnitStateAlive) >= 4) researchCheck(cTechRabauld, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 4) researchCheck(cTechGrapeShotNew, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		researchCheck(cTechChurchEconmediaManor, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchBestieros, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchTowerAndSword, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechRGRoyalHussar, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeRuyter, cUnitStateAlive) >= 8) researchCheck(cTechRGCarabineer, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 12) researchCheck(cTechRGNassausLinearTactics, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSchutze, cUnitStateAlive) >= 12) researchCheck(cTechGuardSchutzens, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12) researchCheck(cTechGuardSkirmishers, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechGuardGrenadiers, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);				
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechGuardGrenadiersUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) > 6) researchCheck(cTechChurchCoffeeTrade, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchWaardgelders, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchStadholders, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeBank, cUnitStateAlive) == kbGetBuildLimit(cMyID, cUnitTypeBank)) researchCheck(cTechImpExcessiveTaxationD, 50, cUnitTypeBank, cEconomyEscrowID);
		researchCheck(cTechChurchMercantilism, 50, cUnitTypeMarket, cEconomyEscrowID); //age 2 tech				
		if (kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) > kbGetBuildLimit(cMyID, gTowerUnit) / 2) researchCheck(cTechFortifiedBlockhouse, 50, gTowerUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCossack, cUnitStateAlive) >= 8) researchCheck(cTechGuardCossacks, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeOprichnik, cUnitStateAlive) >= 8) researchCheck(cTechGuardOprichniks, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 8) researchCheck(cTechRGTartarLoyalists, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 12) researchCheck(cTechGuardStrelets, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12) researchCheck(cTechGuardPikemen, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechGuardMusketeers, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 12) researchCheck(cTechGuardHalberdiers, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechVeteranGrenadiers, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechRGPavlovGrenadiers, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4) researchCheck(cTechHeavyHorseArtilleryNew, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		researchCheck(cTechChurchWesternization, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchKalmucks, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchBashkirPonies, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeUhlan, cUnitStateAlive) >= 8) researchCheck(cTechRGCzapkaUhlans, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeWarWagon, cUnitStateAlive) >= 8) researchCheck(cTechGuardWarWagons, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 12) researchCheck(cTechGuardCrossbowmen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12) researchCheck(cTechGuardPikemen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeDopplesoldner, cUnitStateAlive) >= 12) researchCheck(cTechGuardDopplesoldners, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12) researchCheck(cTechRGPrussianNeedleGun, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 4) researchCheck(cTechHowitzerNew, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		researchCheck(cTechChurchTillysDiscipline, 50, cUnitTypeChurch, cEconomyEscrowID);
		//researchCheck(cTechChurchWallensteinsContracts, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchZweihander, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, gEconUnit, cUnitStateAlive) >= 48) researchCheck(cTechChurchTanzimat, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchMercantilism, 50, cUnitTypeMarket, cEconomyEscrowID); //age 2 tech			
		if (kbUnitCount(cMyID, cUnitTypeOutpost, cUnitStateAlive) > kbGetBuildLimit(cMyID, gTowerUnit) / 2) researchCheck(cTechFortifiedOutpost, 50, gTowerUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) > 0) researchCheck(cTechRevetment, 50, cUnitTypeFortFrontier, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) > 0) researchCheck(cTechStarFort, 50, cUnitTypeFortFrontier, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 3) researchCheck(cTechHomesteading, 50, cUnitTypePlantation, cEconomyEscrowID);
		researchCheck(cTechChurchStandingArmy, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchMassCavalry, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechSaloonWildWest, 50, cUnitTypeSPCFortCenter, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 3) researchCheck(cTechOreRefining, 50, cUnitTypePlantation, cEconomyEscrowID);
		researchCheck(cTechImpKnighthood, 50, cUnitTypeSPCFortCenter, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechRGGardener, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSpahi, cUnitStateAlive) >= 8) researchCheck(cTechGuardSpahi, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 8) researchCheck(cTechGuardCavalryArchers, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 12) researchCheck(cTechGuardJanissaries, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAzap, cUnitStateAlive) >= 12) researchCheck(cTechGuardAzaps, 50, cUnitTypeBarracks, cMilitaryEscrowID);			
		if (kbUnitCount(cMyID, cUnitTypeRiflemanUS, cUnitStateAlive) >= 12) researchCheck(cTechGuardRiflemenUS, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMarine, cUnitStateAlive) >= 12) researchCheck(cTechGuardMusketeersUS, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMountedRifleman, cUnitStateAlive) >= 8) researchCheck(cTechGuardMountedRiflemen, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) >= 8) researchCheck(cTechGuardAbusGuns, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechRGBaratcuCorps, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 4) researchCheck(cTechFieldGun, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 4) researchCheck(cTechGrapeShot, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 4) researchCheck(cTechHowitzer, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4) researchCheck(cTechHeavyHorseArtillery, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechFactoryCannery, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechFactoryWaterPower, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechFactorySteamPower, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechFactoryMassProduction, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbGetPop() > 150) researchCheck(cTechChurchCannonPop, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchHussars, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchTufanciCorps, 50, cUnitTypeChurch, cEconomyEscrowID);
		researchCheck(cTechChurchTopcuCorps, 50, cUnitTypeChurch, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 12) researchCheck(cTechChampionAennas, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 12) researchCheck(cTechChampionTomahawk, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) >= 12) researchCheck(cTechChampionMusketWarriors, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive) >= 8) researchCheck(cTechChampionHorsemen, 50, cUnitTypeCorral, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMusketRider, cUnitStateAlive) >= 8) researchCheck(cTechChampionMusketRiders, 50, cUnitTypeCorral, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpRam, cUnitStateAlive) >= 5) researchCheck(cTechChampionRams, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMantlet, cUnitStateAlive) >= 5) researchCheck(cTechChampionMantlets, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpLightCannon, cUnitStateAlive) >= 5) researchCheck(cTechFieldCannon, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		researchCheck(cTechBigFirepitBattleAnger, 50, cUnitTypeFirePit, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 12) researchCheck(cTechChampionWarBows, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 12) researchCheck(cTechChampionWarClubs, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) >= 12) researchCheck(cTechChampionWarRifles, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpAxeRider, cUnitStateAlive) >= 10) researchCheck(cTechChampionAxeRiders, 50, cUnitTypeCorral, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpBowRider, cUnitStateAlive) >= 10) researchCheck(cTechChampionBowRider, 50, cUnitTypeCorral, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpRifleRider, cUnitStateAlive) >= 10) researchCheck(cTechChampionRifleRiders, 50, cUnitTypeCorral, cEconomyEscrowID);
		researchCheck(cTechSaloonWildWest, 50, cUnitTypeNativeEmbassy, cMilitaryEscrowID);
		researchCheck(cTechConSupport, 50, cUnitTypeNativeEmbassy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeWarHut, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeWarHut) / 2) researchCheck(cTechMightyWarHut, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) >= 12) researchCheck(cTechChampionCoyotemen, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 12) researchCheck(cTechChampionMacehualtins, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 12) researchCheck(cTechChampionPumaMen, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) >= 12) researchCheck(cTechChampionArrowKnight, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) >= 12) researchCheck(cTechChampionEagleKnight, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpJaguarKnight, cUnitStateAlive) >= 12) researchCheck(cTechChampionJaguarKnight, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeNoblesHut, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeNoblesHut) / 2) researchCheck(cTechMightyNoblesHut, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) >= 5) researchCheck(cTechBigDockCipactli, 50, gDockUnit, cMilitaryEscrowID);
		researchCheck(cTechypShrineFortressUpgrade, 50, cUnitTypeypShrineJapanese, cEconomyEscrowID);
		researchCheck(cTechypMonasteryRangedSplash, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredYumi, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredAshigaru, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) >= 8) researchCheck(cTechYPHonoredSamurai, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSohei, cUnitStateAlive) >= 8) researchCheck(cTechYPHonoredSohei, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) >= 8) researchCheck(cTechYPHonoredNaginataRider, 50, cUnitTypeypStableJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypYabusame, cUnitStateAlive) >= 8) researchCheck(cTechYPHonoredYabusame, 50, cUnitTypeypStableJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypFlamingArrow, cUnitStateAlive) >= 5) researchCheck(cTechYPHonoredFlamingArrow, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypMorutaru, cUnitStateAlive) >= 5) researchCheck(cTechYPHonoredMorutaru, 50, cUnitTypeypCastle, cMilitaryEscrowID);						
		if (kbUnitCount(cMyID, cUnitTypeypHandMortar, cUnitStateAlive) >= 5) researchCheck(cTechYPHonoredHandMortar, 50, cUnitTypeypCastle, cMilitaryEscrowID);	
		if (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateAlive) >= 5) researchCheck(cTechYPHonoredFlameThrower, 50, cUnitTypeypCastle, cMilitaryEscrowID);					
		if (kbUnitCount(cMyID, cUnitTypeypIronFlail, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredIronFlail, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypMeteorHammer, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredMeteorHammer, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);					
		if (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredChuKoNu, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredQiangPikeman, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredSteppeRider, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredKeshik, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);					
		if (kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12) researchCheck(cTechFlintlock, 50, cUnitTypeypWJGoldenPavillion3, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractGunpowderTrooper, cUnitStateAlive) >= 12) researchCheck(cTechPaperCartridge, 50, cUnitTypeypWJGoldenPavillion3, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractHeavyCavalry, cUnitStateAlive) >= 8) researchCheck(cTechPillage, 50, cUnitTypeypWJGoldenPavillion3, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractArtillery, cUnitStateAlive) >= 5) researchCheck(cTechProfessionalGunners, 50, cUnitTypeypWJGoldenPavillion3, cMilitaryEscrowID);
		researchCheck(cTechypLandRedistribution, 50, cUnitTypeypRicePaddy, cEconomyEscrowID);
		researchCheck(cTechypCooperative, 50, cUnitTypeypRicePaddy, cEconomyEscrowID);
		researchCheck(cTechypMonasteryCompunction, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechypMonasteryStompUpgrade, 50, cUnitTypeypMonastery, cEconomyEscrowID);
		researchCheck(cTechypFrontierAgra, 50, cUnitTypeypWIAgraFort2, cEconomyEscrowID);
		researchCheck(cTechypFrontierAgra, 50, cUnitTypeypWIAgraFort3, cEconomyEscrowID);
		researchCheck(cTechypFrontierAgra, 50, cUnitTypeypWIAgraFort4, cEconomyEscrowID);
		researchCheck(cTechypFrontierAgra, 50, cUnitTypeypWIAgraFort5, cEconomyEscrowID);
		researchCheck(cTechypFortifiedAgra, 50, cUnitTypeypWIAgraFort2, cEconomyEscrowID);
		researchCheck(cTechypFortifiedAgra, 50, cUnitTypeypWIAgraFort3, cEconomyEscrowID);
		researchCheck(cTechypFortifiedAgra, 50, cUnitTypeypWIAgraFort4, cEconomyEscrowID);
		researchCheck(cTechypFortifiedAgra, 50, cUnitTypeypWIAgraFort5, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractRajput, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredRajput, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractUrumi, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredUrumi, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractSepoy, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredSepoy, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractGurkha, cUnitStateAlive) >= 12) researchCheck(cTechYPHonoredGurkha, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) >= 8) researchCheck(cTechYPHonoredCamel, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) >= 8) researchCheck(cTechYPHonoredCamelGun, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractMahout, cUnitStateAlive) >= 8) researchCheck(cTechYPHonoredMahout, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractHowdah, cUnitStateAlive) >= 8) researchCheck(cTechYPHonoredHowdah, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive) >= 5) researchCheck(cTechYPHonoredFlailElephant, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractSiegeElephant, cUnitStateAlive) >= 5) researchCheck(cTechYPHonoredSiegeElephant, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) > kbGetBuildLimit(cMyID, cUnitTypeypCastle) / 2) researchCheck(cTechypFortifiedCastle, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		researchCheck(cTechypVillagePopCapIncrease3, 50, cUnitTypeypVillage, cEconomyEscrowID);	
	}
	if (kbGetAge() == cAge5)
	{
		if (kbUnitCount(cMyID, cUnitTypeSaber, cUnitStateAlive) >= 8) researchCheck(cTechImperialSabers, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMountedRifleman, cUnitStateAlive) >= 8) researchCheck(cTechImperialMountedRiflemen, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeLongbowman, cUnitStateAlive) >= 12) researchCheck(cTechImperialLongbowmen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechImperialRedcoat, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechImperialLifeGuard, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) > 0) researchCheck(cTechImperialMonitorsNew, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFrigate, cUnitStateAlive) > 0) researchCheck(cTechImperialManOWarNew, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12) researchCheck(cTechImperialTercio, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeRodelero, cUnitStateAlive) >= 12) researchCheck(cTechImperialEspada, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeLancer, cUnitStateAlive) >= 8) researchCheck(cTechImperialGarrochistas, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFlatbowman, cUnitStateAlive) >= 12) researchCheck(cTechImperialFlatbowman, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechImperialMusketeers, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12) researchCheck(cTechImperialVoltigeur, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechImperialHussars, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 8) researchCheck(cTechImperialDragoons, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCuirassier, cUnitStateAlive) >= 8) researchCheck(cTechImperialGendarme, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 4) researchCheck(cTechImperialCulverinNew, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 12) researchCheck(cTechImperialHalberdiers, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechImperialGuerreiros, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCacadore, cUnitStateAlive) >= 12) researchCheck(cTechImperialCacadores, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCavalaria, cUnitStateAlive) >= 8) researchCheck(cTechImperialDrabants, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 8) researchCheck(cTechImperialJinetes, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeOrganGun, cUnitStateAlive) >= 4) researchCheck(cTechImperialRabaulds, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechImperialRocket, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 3) researchCheck(cTechImpExcessiveTaxationD3, 50, cUnitTypePlantation, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 12) researchCheck(cTechImperialNassauers, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSchutze, cUnitStateAlive) >= 12) researchCheck(cTechImperialSchutzens, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12) researchCheck(cTechImperialSkirmishers, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMarine, cUnitStateAlive) >= 12) researchCheck(cTechImperialMusketeersUS, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeRiflemanUS, cUnitStateAlive) >= 12) researchCheck(cTechImperialRiflemenUS, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechImperialRoyalHussar, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeDragoon, cUnitStateAlive) >= 8) researchCheck(cTechImperialCarabineer, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechImperialGrenadiers, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechImperialGrenadiersUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 4) researchCheck(cTechImperialFieldGunUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 4) researchCheck(cTechImperialCulverinUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 4) researchCheck(cTechImperialHowitzerUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4) researchCheck(cTechImperialHorseArtilleryUS, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		researchCheck(cTechImpExcessiveTaxationD2, 50, cUnitTypeBank, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeStrelet, cUnitStateAlive) >= 12) researchCheck(cTechImperialStrelets, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12) researchCheck(cTechImperialPikemen, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHalberdier, cUnitStateAlive) >= 12) researchCheck(cTechImperialHalberdiers, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMusketeer, cUnitStateAlive) >= 12) researchCheck(cTechImperialMusketeers, 50, cUnitTypeBlockhouse, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCossack, cUnitStateAlive) >= 8) researchCheck(cTechImperialCossack, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeOprichnik, cUnitStateAlive) >= 8) researchCheck(cTechImperialOprichniks, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 8) researchCheck(cTechImperialTartarLoyalist, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechImperialPavlovs, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4) researchCheck(cTechImperialHorseArtilleryNew, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechImperialGreatCannon, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCrossbowman, cUnitStateAlive) >= 12) researchCheck(cTechImperialCrossbowmen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePikeman, cUnitStateAlive) >= 12) researchCheck(cTechImperialPikemen, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeDopplesoldner, cUnitStateAlive) >= 12) researchCheck(cTechImperialDopplesoldner, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSkirmisher, cUnitStateAlive) >= 12) researchCheck(cTechImperialNeedleGun, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeUhlan, cUnitStateAlive) >= 8) researchCheck(cTechImperialCzapkaUhlans, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeWarWagon, cUnitStateAlive) >= 8) researchCheck(cTechImperialWarWagons, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 4) researchCheck(cTechImperialHowitzerNew, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechImperialCannon, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechImperialCannonUS, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFrigate, cUnitStateAlive) > 0) researchCheck(cTechImperialManOWar, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) > 0) researchCheck(cTechImperialMonitors, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMill, cUnitStateAlive) >= 3) researchCheck(cTechImpLargeScaleAgriculture, 50, cUnitTypeMill, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypePlantation, cUnitStateAlive) >= 3) researchCheck(cTechImpExcessiveTaxation, 50, cUnitTypePlantation, cEconomyEscrowID);
		researchCheck(cTechImpDeforestation, 50, cUnitTypeMarket, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeHussar, cUnitStateAlive) >= 8) researchCheck(cTechImperialGardener, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSpahi, cUnitStateAlive) >= 8) researchCheck(cTechImperialSpahi, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCavalryArcher, cUnitStateAlive) >= 8) researchCheck(cTechImperialCavalryArchers, 50, cUnitTypeStable, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeJanissary, cUnitStateAlive) >= 12) researchCheck(cTechImperialJanissaries, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAzap, cUnitStateAlive) >= 12) researchCheck(cTechImperialAzaps, 50, cUnitTypeBarracks, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbusGun, cUnitStateAlive) >= 8) researchCheck(cTechImperialAbusGun, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeGrenadier, cUnitStateAlive) >= 8) researchCheck(cTechImperialBaratcu, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFalconet, cUnitStateAlive) >= 4) researchCheck(cTechImperialFieldGun, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeCulverin, cUnitStateAlive) >= 4) researchCheck(cTechImperialCulverin, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMortar, cUnitStateAlive) >= 4) researchCheck(cTechImperialHowitzer, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseArtillery, cUnitStateAlive) >= 4) researchCheck(cTechImperialHorseArtillery, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractNativeWarrior, cUnitStateAlive) > 10) researchCheck(cTechImpLegendaryNatives, 50, gTownCenter, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFactory, cUnitStateAlive) > 0) researchCheck(cTechImperialBombard, 50, cUnitTypeFactory, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpAenna, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryAennas, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpTomahawk, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryTomahawks, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMusketWarrior, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryMusketWarriors, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpHorseman, cUnitStateAlive) >= 8) researchCheck(cTechImpLegendaryHorsemen, 50, cUnitTypeCorral, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMusketRider, cUnitStateAlive) >= 8) researchCheck(cTechImpLegendaryMusketRiders, 50, cUnitTypeCorral, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpRam, cUnitStateAlive) >= 5) researchCheck(cTechImpLegendaryRams, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMantlet, cUnitStateAlive) >= 5) researchCheck(cTechImpLegendaryMantlets, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpLightCannon, cUnitStateAlive) >= 5) researchCheck(cTechImpLegendaryLightCannon, 50, cUnitTypeArtilleryDepot, cMilitaryEscrowID);
		researchCheck(cTechypConsulateFrenchBrigadeN, 50, cUnitTypeNativeEmbassy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpWarBow, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryWarBows, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpWarClub, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryWarClubs, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpWarRifle, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryWarRifles, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpAxeRider, cUnitStateAlive) >= 10) researchCheck(cTechImpLegendaryAxeRiders, 50, cUnitTypeCorral, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpBowRider, cUnitStateAlive) >= 10) researchCheck(cTechImpLegendaryBowRider, 50, cUnitTypeCorral, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpRifleRider, cUnitStateAlive) >= 10) researchCheck(cTechImpLegendaryRifleRiders, 50, cUnitTypeCorral, cEconomyEscrowID);
		researchCheck(cTechypConsulateBritishBrigadeN, 50, cUnitTypeNativeEmbassy, cMilitaryEscrowID);
		researchCheck(cTechImpDeforestationNative, 50, cUnitTypeMarket, cEconomyEscrowID);
		researchCheck(cTechImpLargeScaleGathering, 50, gFarmUnit, cEconomyEscrowID);
		researchCheck(cTechImpExcessiveTributeNative, 50, gFarmUnit, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpCoyoteMan, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryCoyoteMen, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpMacehualtin, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryMacehualtins, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpPumaMan, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryPumaMen, 50, cUnitTypeWarHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpArrowKnight, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryArrowKnights, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpEagleKnight, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryEagleKnights, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypexpJaguarKnight, cUnitStateAlive) >= 12) researchCheck(cTechImpLegendaryJaguarKnights, 50, cUnitTypeNoblesHut, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0) researchCheck(cTechImpImmigrantsNative, 50, gTownCenter, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractNativeWarrior, cUnitStateAlive) > 10) researchCheck(cTechImpLegendaryNativesNatives, 50, gTownCenter, cMilitaryEscrowID);
		researchCheck(cTechypConsulateSpanishBrigadeN, 50, cUnitTypeNativeEmbassy, cMilitaryEscrowID);
		researchCheck(cTechBigDockCipactli2, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypYumi, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedYumi, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypAshigaru, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedAshigaru, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypKensei, cUnitStateAlive) >= 8) researchCheck(cTechYPExaltedSamurai, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeSohei, cUnitStateAlive) >= 8) researchCheck(cTechYPExaltedSohei, 50, cUnitTypeypBarracksJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypNaginataRider, cUnitStateAlive) >= 8) researchCheck(cTechYPExaltedNaginataRider, 50, cUnitTypeypStableJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypYabusame, cUnitStateAlive) >= 8) researchCheck(cTechYPExaltedYabusame, 50, cUnitTypeypStableJapanese, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypFlamingArrow, cUnitStateAlive) >= 5) researchCheck(cTechYPExaltedFlamingArrow, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypMorutaru, cUnitStateAlive) >= 5) researchCheck(cTechYPExaltedMorutaru, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypTekkousen, cUnitStateAlive) >= 1) researchCheck(cTechYPExaltedTekkousen, 50, gDockUnit, cMilitaryEscrowID);										
		if (kbUnitCount(cMyID, cUnitTypeypHandMortar, cUnitStateAlive) >= 5) researchCheck(cTechYPExaltedHandMortar, 50, cUnitTypeypCastle, cMilitaryEscrowID);															
		if (kbUnitCount(cMyID, cUnitTypeypFlameThrower, cUnitStateAlive) >= 5) researchCheck(cTechYPExaltedFlameThrower, 50, cUnitTypeypCastle, cMilitaryEscrowID);					
		if (kbUnitCount(cMyID, cUnitTypeypIronFlail, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedIronFlail, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypMeteorHammer, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedMeteorHammer, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);		
		if (kbUnitCount(cMyID, cUnitTypeypChuKoNu, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedChuKoNu, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypQiangPikeman, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedQiangPikeman, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypSteppeRider, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedSteppeRider, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypKeshik, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedKeshik, 50, cUnitTypeypWarAcademy, cMilitaryEscrowID);
		researchCheck(cTechypImpDeforestationAsian, 50, cUnitTypeypTradeMarketAsian, cEconomyEscrowID);
		researchCheck(cTechypImpLargeScaleAgricultureAsian, 50, cUnitTypeypRicePaddy, cEconomyEscrowID);
		researchCheck(cTechypImpExcessiveTributeAsian, 50, cUnitTypeypRicePaddy, cEconomyEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractRajput, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedRajput, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractUrumi, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedUrumi, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractSepoy, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedSepoy, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractGurkha, cUnitStateAlive) >= 12) researchCheck(cTechYPExaltedGurkha, 50, cUnitTypeYPBarracksIndian, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractSowar, cUnitStateAlive) >= 8) researchCheck(cTechYPExaltedCamel, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractZamburak, cUnitStateAlive) >= 8) researchCheck(cTechYPExaltedCamelGun, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractMahout, cUnitStateAlive) >= 8) researchCheck(cTechYPExaltedMahout, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractHowdah, cUnitStateAlive) >= 8) researchCheck(cTechYPExaltedHowdah, 50, cUnitTypeypCaravanserai, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractMercFlailiphant, cUnitStateAlive) >= 5) researchCheck(cTechYPExaltedFlailElephant, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractSiegeElephant, cUnitStateAlive) >= 5) researchCheck(cTechYPExaltedSiegeElephant, 50, cUnitTypeypCastle, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0) researchCheck(cTechImpImmigrants, 50, gTownCenter, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0) researchCheck(cTechImpImmigrantsAsian, 50, gTownCenter, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0 && kbGetTechAICost(cTechHCBlockade) < 8000) researchCheck(cTechHCBlockade, 50, gTownCenter, cMilitaryEscrowID);
		//if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0 && kbGetTechAICost(cTechSpies) < 8000) researchCheck(cTechSpies, 50, gTownCenter, cMilitaryEscrowID);
		//if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0 && kbGetTechAICost(cTechSpies) < 8000) researchCheck(cTechSpies, 50, gTownCenter, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeAbstractNativeWarrior, cUnitStateAlive) > 10) researchCheck(cTechypImpLegendaryNatives2, 50, gTownCenter, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFrigate, cUnitStateAlive) > 0) researchCheck(cTechypImperialManOWar, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeFrigate, cUnitStateAlive) > 0) researchCheck(cTechImperialManOWarUS, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) > 0) researchCheck(cTechImperialMonitorsUS, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeMonitor, cUnitStateAlive) > 0) researchCheck(cTechypImperialMonitors, 50, gDockUnit, cMilitaryEscrowID);
		if (kbUnitCount(cMyID, cUnitTypeypFuchuan, cUnitStateAlive) > 0) researchCheck(cTechYPExaltedFuchuan, 50, gDockUnit, cMilitaryEscrowID);
		researchCheck(cTechypVillagePopCapIncrease4, 50, cUnitTypeypVillage, cEconomyEscrowID);
		researchCheck(cTechUniqueUSTradingPosts, 50, cUnitTypeChurch, cEconomyEscrowID); 
		researchCheck(cTechUniqueSPCCustomizedMercWeaponsUS, 50, cUnitTypeChurch, cEconomyEscrowID); 
		researchCheck(cTechHCPatriots, 50, cUnitTypeChurch, cEconomyEscrowID); 	
	}
}


//=================================================================================================
// Improvement Mod
//=================================================================================================
extern int Q_FIND = -1;
extern int Q_FINDAT = -1;
extern int Q_COUNTAT = -1;
extern int Q_DOUBLE = -1;
extern int Q_ACTION = -1;

int FIND(int utID=-1, int prID=cMyID, int pos=-1, int state=cUnitStateAlive)
{
	if (Q_FIND==-1)
	{
		Q_FIND = kbUnitQueryCreate("FIND");
		kbUnitQuerySetIgnoreKnockedOutUnits(Q_FIND, true);
	}
	
	int found = 0;
	if (pos <= 0)
	{
		kbUnitQueryResetResults(Q_FIND);
		if (prID < 1000)
		{
			kbUnitQuerySetPlayerRelation(Q_FIND, -1);
			kbUnitQuerySetPlayerID(Q_FIND, prID, false);
		}
		else
		{
			kbUnitQuerySetPlayerID(Q_FIND, -1, false);
			kbUnitQuerySetPlayerRelation(Q_FIND, prID);
		}
		kbUnitQuerySetUnitType(Q_FIND, utID);
		kbUnitQuerySetState(Q_FIND, state);
		found = kbUnitQueryExecute(Q_FIND);
		if (pos < 0)
		return(kbUnitQueryGetResult(Q_FIND, aiRandInt(found)));
	}
	return(kbUnitQueryGetResult(Q_FIND, pos));
}

int FINDAT(int utID=-1, int prID=cMyID, vector loc=cInvalidVector, float radius=30.0, int pos=-1, int state=cUnitStateAlive)
{
	if (Q_FINDAT==-1)
	{
		Q_FINDAT = kbUnitQueryCreate("FINDAT");
		kbUnitQuerySetIgnoreKnockedOutUnits(Q_FINDAT, true);
		kbUnitQuerySetAscendingSort(Q_FINDAT, true);
	}
	
	int found = 0;
	if (pos <= 0)
	{
		kbUnitQueryResetResults(Q_FINDAT);
		if (prID < 1000)
		{
			kbUnitQuerySetPlayerRelation(Q_FINDAT, -1);
			kbUnitQuerySetPlayerID(Q_FINDAT, prID, false);
		}
		else
		{
			kbUnitQuerySetPlayerID(Q_FINDAT, -1, false);
			kbUnitQuerySetPlayerRelation(Q_FINDAT, prID);
		}
		kbUnitQuerySetUnitType(Q_FINDAT, utID);
		kbUnitQuerySetState(Q_FINDAT, state);
		kbUnitQuerySetPosition(Q_FINDAT, loc);
		kbUnitQuerySetMaximumDistance(Q_FINDAT, radius);
		found = kbUnitQueryExecute(Q_FINDAT);
		if (pos < 0)
		return(kbUnitQueryGetResult(Q_FINDAT, aiRandInt(found)));
	}
	return(kbUnitQueryGetResult(Q_FINDAT, pos));
}

int COUNTAT(int utID=-1, int prID=cMyID, vector loc=cInvalidVector, float radius=30.0, int state=cUnitStateAlive)
{
	if (Q_COUNTAT==-1)
	{
		Q_COUNTAT = kbUnitQueryCreate("COUNTAT");
		kbUnitQuerySetIgnoreKnockedOutUnits(Q_COUNTAT, true);
	}
	
	kbUnitQueryResetResults(Q_COUNTAT);
	if (prID < 1000)
	{
		kbUnitQuerySetPlayerRelation(Q_COUNTAT, -1);
		kbUnitQuerySetPlayerID(Q_COUNTAT, prID, false);
	}
	else
	{
		kbUnitQuerySetPlayerID(Q_COUNTAT, -1, false);
		kbUnitQuerySetPlayerRelation(Q_COUNTAT, prID);
	}
	kbUnitQuerySetUnitType(Q_COUNTAT, utID);
	kbUnitQuerySetState(Q_COUNTAT, state);
	kbUnitQuerySetPosition(Q_COUNTAT, loc);
	kbUnitQuerySetMaximumDistance(Q_COUNTAT, radius);
	return(kbUnitQueryExecute(Q_COUNTAT));
}

int DOUBLEQUERY(int queryID=-1, int utID=-1, vector loc=cInvalidVector, float radius=200.0, int pos=-1)
{
	if (Q_DOUBLE==-1)
	{
		Q_DOUBLE = kbUnitQueryCreate("DOUBLE");
		kbUnitQuerySetAscendingSort(Q_DOUBLE, true);
	}
	
	int found = 0;
	if (pos <= 0)
	{
		kbUnitQueryResetResults(Q_DOUBLE);
		kbUnitQuerySetUnitType(Q_DOUBLE, utID);
		kbUnitQuerySetPosition(Q_DOUBLE, loc);
		kbUnitQuerySetMaximumDistance(Q_DOUBLE, radius);
		found = kbUnitQueryExecuteOnQuery(Q_DOUBLE, queryID);
		if (pos < 0)
		return(kbUnitQueryGetResult(Q_DOUBLE, aiRandInt(found)));
	}
	return(kbUnitQueryGetResult(Q_DOUBLE, pos));
}

int FINDBYACTION(int unit_type=-1, int action=-1, int pos=0)
{
	if (Q_ACTION==-1)
	{
		Q_ACTION = kbUnitQueryCreate("ACTION");
		kbUnitQuerySetAscendingSort(Q_ACTION, true);
	}
	
	if (pos == 0)
	{
		kbUnitQueryResetResults(Q_ACTION);
		kbUnitQuerySetActionType(Q_ACTION, action);
		kbUnitQuerySetUnitType(Q_ACTION, unit_type);
		kbUnitQueryExecute(Q_ACTION);
	}
	return(kbUnitQueryGetResult(Q_ACTION, pos));
}

int kbUnitGetResourceType(int unitID = -1)
{
	if (kbUnitIsType(unitID, cUnitTypeGold) == true)
	return(cResourceGold);
	else if(kbUnitIsType(unitID, cUnitTypeMill) == true)
	return(cResourceFood);
	else if(kbUnitIsType(unitID, cUnitTypeFarm) == true)
	return(cResourceFood);
	else if(kbUnitIsType(unitID, cUnitTypeypRicePaddy) == true)
	{
		if (aiUnitGetTactic(unitID) == cTacticPaddyFood)
		return(cResourceFood);
		else
		return(cResourceGold);
	}
	else if (kbUnitIsType(unitID, cUnitTypeWood) == true)
	return(cResourceWood);
	if (kbUnitIsType(unitID, cUnitTypeHuntable) == true)
	{
		if (cMyCiv != cCivJapanese)
		return(cResourceFood);
		else
		return(-1);
	}
	else if (kbUnitIsType(unitID, cUnitTypeHerdable) == true)
	{
		if(cMyCiv == cCivIndians)
		return(-1);
		else if(cMyCiv == cCivJapanese)
		return(-1);
		return(cResourceFood);
	}
	else if (kbUnitIsType(unitID, cUnitTypeAbstractFruit) == true)
	return(cResourceFood);
	return(-1);
}

int kbUnitGetWorkerLimit(int resourceID = -1)
{
	if (kbUnitIsType(resourceID, cUnitTypeBuilding) == true)
	return(10 - kbUnitGetNumberWorkers(resourceID));
	
	vector v = kbUnitGetPosition(resourceID);
	
	if (kbUnitIsType(resourceID, cUnitTypeAbstractResourceCrate) == true)
	return(1 - COUNTAT(gEconUnit, cMyID, v, 4.0));
	
	else if (kbUnitIsType(resourceID, cUnitTypeTree) == true)
	return(8 - COUNTAT(gEconUnit, cPlayerRelationAny, v, 6.0));
	
	else if (kbUnitIsType(resourceID, cUnitTypeBerryBush) == true)
	return(8 - COUNTAT(gEconUnit, cPlayerRelationAny, v, 6.0));
	
	else if (kbUnitIsType(resourceID, cUnitTypeMinedResource) == true)
	return(20 - COUNTAT(gEconUnit, cPlayerRelationAny, v, 7.5));
	
	else if (kbUnitIsType(resourceID, cUnitTypeAnimalPrey) == true)
	{
		if (COUNTAT(cUnitTypeAbstractShrine, cPlayerRelationAny, v, 16.0) > 0)
		return(0);
		else
		return(8 - COUNTAT(gEconUnit, cPlayerRelationAny, v, 5.0));
	}
	
	return(1);
}

//==============================================================================
/* rule market_exchanges
	updatedOn 2019/11/18 By ageekhere  
*/
//==============================================================================
//rule market_exchanges
//inactive
//minInterval 5
//group startup
void market_exchanges()
{
	if(kbUnitCount(cMyID,gMarketUnit , cUnitStateAlive) == 0) return;
	if (kbGetAge()< cAge3) return;
	
	float inv_gold=kbResourceGet(cResourceGold);
	float inv_wood=kbResourceGet(cResourceWood);
	float inv_food=kbResourceGet(cResourceFood);
	
	float lowest = MIN(inv_food, MIN(inv_wood, inv_gold));
	float highest = MAX(inv_food, MAX(inv_wood, inv_gold));
	
	int tobuy = cResourceFood;
	int tosell = cResourceWood;
	
	if (lowest == inv_food)
	tobuy = cResourceFood;
	else if (lowest == inv_wood)
	tobuy = cResourceWood;
	
	if (highest == inv_food)
	tosell = cResourceFood;
	else if (highest == inv_wood)
	tosell = cResourceWood;
	
	if (highest == inv_gold)
	{
		//xsSetRuleMinIntervalSelf(1); // Fast mode interval
		if(inv_gold > (aiGetMarketBuyCost(tobuy) * 10) )
		{
			aiBuyResourceOnMarket(tobuy);
		}
		return;
	}
	else if (lowest == inv_gold)
	{
		// Hmm... To be decided
	}
	
	if (lowest*5.0 < highest)
	{
		//xsSetRuleMinIntervalSelf(1); // Fast mode interval
		if(aiGetMarketSellCost(tosell) != 30)
		{
			aiSellResourceOnMarket(tosell);
			aiSellResourceOnMarket(tosell);
			aiSellResourceOnMarket(tosell);
		}
		aiBuyResourceOnMarket(tobuy);
	}
	
	if (kbGetAge() < cAge5 && kbResourceGet(cResourceWood) > 700 && aiGetMarketBuyCost(cResourceWood) > 30 )
	{
		aiSellResourceOnMarket(cResourceWood);
	}
}

//==============================================================================
/* rule call_levies
	updatedOn 2019/09/14 By ageekhere  
*/
//==============================================================================
//rule call_levies
//active
//minInterval 5
void call_levies()
{ //trains levies when base is under attack
	int base=-1;
	int town=-1;
	for(i=0;<kbBaseGetNumber(cMyID))
	{
		base=kbBaseGetIDByIndex(cMyID, i);
		if (kbBaseGetUnderAttack(cMyID, base)==false) continue;
		//if(getUnitByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 80) < 10) continue;
		town=getUnitByLocation(gTownCenter, cMyID, cUnitStateAlive, kbBaseGetLocation(cMyID, base), 80.0);
		if (town==-1) continue;
		
		aiTaskUnitTrain(town, cUnitTypeLevyMin);
		aiTaskUnitTrain(town, cUnitTypeLevyIre);
		aiTaskUnitTrain(town, cUnitTypeLevyAsi);
	} //end for
} //end call_levies

//==============================================================================
/* rule livestockManager
	updatedOn 2019/11/26 By ageekhere  
*/
//==============================================================================
extern int livestockPlan = -1;
extern int livestockPlanKill = -1;
//rule livestockManager
//active
//minInterval 11
void livestockManager()
{ //train new livestock
	if(kbGetAge() == cAge1 || kbGetCiv() == cCivJapanese || kbGetCiv() == cCivSPCJapanese) return; //skip when in age 1
	
	if(kbBaseGetUnderAttack(cMyID, 0) == true) return; //when under attack do not make sheep
	int livestockAvailable = -1;
	int useLivestock = -1;
	
	//selected the best livestock available, if more than 1 type then use the highest food first
	livestockAvailable = kbProtoUnitAvailable(cUnitTypeypGoat);
	if(livestockAvailable == 1 && kbUnitCount(cMyID, cUnitTypeypGoat, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeypGoat)) useLivestock = cUnitTypeypGoat;
	
	livestockAvailable = kbProtoUnitAvailable(cUnitTypeSheep);
	if(livestockAvailable == 1 && kbUnitCount(cMyID, cUnitTypeSheep, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeSheep)) useLivestock = cUnitTypeSheep;
	
	livestockAvailable = kbProtoUnitAvailable(cUnitTypeLlama);
	if(livestockAvailable == 1 && kbUnitCount(cMyID, cUnitTypeLlama, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeLlama)) useLivestock = cUnitTypeLlama;
	
	livestockAvailable = kbProtoUnitAvailable(cUnitTypeCow);
	if(livestockAvailable == 1 && kbUnitCount(cMyID, cUnitTypeCow, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeCow) ) useLivestock = cUnitTypeCow;
	
	livestockAvailable = kbProtoUnitAvailable(cUnitTypeMustang);
	if(livestockAvailable == 1 && kbUnitCount(cMyID, cUnitTypeMustang, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeMustang) ) useLivestock = cUnitTypeMustang;
	
	livestockAvailable = kbProtoUnitAvailable(cUnitTypeypWaterBuffalo);
	if(livestockAvailable == 1 && kbUnitCount(cMyID, cUnitTypeypWaterBuffalo, cUnitStateABQ) < kbGetBuildLimit(cMyID, cUnitTypeypWaterBuffalo) ) useLivestock = cUnitTypeypWaterBuffalo;
	
	int maxLivestock = kbGetBuildLimit(cMyID, useLivestock); //get the max sheep limit
	switch(kbGetAge())
	{ //set maxLivestock for each age
		case cAge1:{ maxLivestock = 0; break;}
		case cAge2:{ maxLivestock = 1; break;}
		case cAge3:{ maxLivestock = 3; break;}
		case cAge4:{ maxLivestock = 4; break;}
		case cAge5:{ maxLivestock = 5; break;}
	} //end switch
	int diff = maxLivestock - kbUnitCount(cMyID, useLivestock, cUnitStateABQ); //see how many sheep you need
	for(i = 0; < diff)
	{ 
		if(kbUnitCount(cMyID, useLivestock, cUnitStateABQ) < maxLivestock)
		{ 
			aiTaskUnitTrain(getUnit(gLivestockPenUnit), useLivestock);
			
			
			//aiTaskUnitTrain(getUnit(gHouseUnit), useLivestock);
			livestockPlanKill = 1;
		}
	}
	if(civIsNative() == true && kbGetAge() == cAge3 && kbUnitCount(cMyID, gLivestockPenUnit, cUnitStateABQ) < 2)
	{
		if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gLivestockPenUnit) == -1)
		{
			createSimpleBuildPlan(gLivestockPenUnit, 1, 65, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1); //add another gLivestockPenUnit
		}
	}
	
	if(civIsNative() == true && kbGetAge() == cAge4 && kbUnitCount(cMyID, gLivestockPenUnit, cUnitStateABQ) < 3)
	{
		if(aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, gLivestockPenUnit) == -1)
		{
			createSimpleBuildPlan(gLivestockPenUnit, 1, 65, true, cEconomyEscrowID, kbBaseGetMainID(cMyID), 1); //add another gLivestockPenUnit
		}
	}
} //end livestockManager

//==============================================================================
/* rule livestockPenMonitor
	updatedOn 2020/11/27 By ageekhere  
*/
//==============================================================================
//rule livestockPenMonitor
//inactive
//group startup
//minInterval 12
void livestockPenMonitor()
{
	if(kbGetCiv() == cCivJapanese || kbGetCiv() == cCivSPCJapanese || kbGetCiv() == cCivSPCJapaneseEnemy) 
	{
		 static int stockQuery = -1;
		 if(stockQuery == -1) stockQuery = kbUnitQueryCreate("stockQuery");
         kbUnitQuerySetPlayerID(stockQuery, cMyID, false);
		 kbUnitQuerySetIgnoreKnockedOutUnits(stockQuery, true);
         kbUnitQuerySetUnitType(stockQuery, cUnitTypeHerdable);
         kbUnitQuerySetState(stockQuery, cUnitStateAny);
		 kbUnitQueryResetResults(stockQuery);
		 for (i = 0; < kbUnitQueryExecute(stockQuery))
		 {
			if(kbUnitGetPosition(getUnit(cUnitTypeAbstractShrine, cMyID, cUnitStateAlive)) == cInvalidVector) break;
			if( distance(kbUnitGetPosition(kbUnitQueryGetResult(stockQuery, i)), kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))) < 20)continue;
			 aiTaskUnitMove(kbUnitQueryGetResult(stockQuery, i), kbUnitGetPosition(getUnit(cUnitTypeAbstractShrine, cMyID, cUnitStateAlive)) );
		 } 
		return;
	}
	//static int livestockPlan = -1;
	// Livestock pen for Europeans, village for Chinese, shrine for Japanese
	// and sacred field for Indians, as defined in initEcon()
	
	if (livestockPlanKill == 1)
	{
		aiPlanDestroy(livestockPlan); // Destroy plan to have it recreated with a new pen
		livestockPlan = -1;
		livestockPlanKill = 0;
	}
	if ((cMyCiv == cCivXPAztec) || (cMyCiv == cCivXPIroquois) || (cMyCiv == cCivXPSioux) || (kbGetCiv() == cCivIndians))
	{
		if (kbUnitCount(cMyID, gLivestockPenUnit, cUnitStateAlive) > 0)
		{
			// Create herd plan
			if (livestockPlan < 0)
			{
				for (j = 0; < 100)
				{
					xsArraySetInt(excludeLivestockArray, j, -1);
				}
				livestockPlan = aiPlanCreate("Livestock Plan", cPlanHerd);
				aiPlanSetDesiredPriority(livestockPlan, 99);
				aiPlanAddUnitType(livestockPlan, cUnitTypeHerdable, 0, 100, 100);
				aiPlanSetNoMoreUnits(livestockPlan, true);
				aiPlanSetVariableInt(livestockPlan, cHerdPlanBuildingTypeID, 0, gLivestockPenUnit);
				aiPlanSetVariableFloat(livestockPlan, cHerdPlanDistance, 0, 0.0);
				aiPlanSetActive(livestockPlan);
			}
		}
		else
		{
			aiPlanDestroy(livestockPlan); // Destroy plan to have it recreated with a new pen
			livestockPlan = -1;
		}
	}
	
	static int liveStockAdd = -1; //current fatten livestock
	if (liveStockAdd == -1) liveStockAdd = kbUnitQueryCreate("liveStockAdd"); //livestock counter 
	kbUnitQuerySetPlayerID(liveStockAdd, cMyID, false);
	kbUnitQuerySetUnitType(liveStockAdd, cUnitTypeHerdable);
	//kbUnitQuerySetState(liveStockAdd, cUnitTypeHerdable);
	kbUnitQuerySetState(liveStockAdd, cUnitStateAlive);
	for (i = 0; < kbUnitQueryExecute(liveStockAdd))
	{ //loop through livestock
		int livestockId = kbUnitQueryGetResult(liveStockAdd, i);
		bool getInventory = kbUnitIsInventoryFull(livestockId);
		if (getInventory == false)
		{
			bool addunit = true;
			int arrayValue = -1;
			
			for (j = 0; < 100)
			{
				arrayValue = xsArrayGetInt(excludeLivestockArray, j);
				if (arrayValue == -1)
				{
					break;
				}
				
				if (arrayValue == livestockId)
				{
					addunit = false;
					break;
				}
			}
			
			if (addunit == true)
			{
				xsArraySetInt(excludeLivestockArray, j, livestockId);
				aiPlanAddUnit(livestockPlan, livestockId);
			}
			
		}
		
	}
}
//==============================================================================
/* rule MonitorHerding
	updatedOn 2019/09/30 By ageekhere  
	updatedOn 2019/09/07 By AlistairJah  
*/
//==============================================================================
//rule MonitorHerding
//active
//minInterval 13
extern int currentLivestock = -1;
void MonitorHerding()
{
	if (kbGetCiv() == cCivJapanese ||
		kbGetCiv() == cCivSPCJapanese ||
		kbGetCiv() == cCivSPCJapaneseEnemy ||
		kbGetCiv() == cCivIndians ||
		kbGetCiv() == cCivXPIroquois ||
		kbGetCiv() == cCivXPSioux ||
	kbGetCiv() == cCivXPAztec)
	{
		//xsDisableSelf();
		return;
	}
	int livestockCount = kbUnitCount(cMyID, cUnitTypeHerdable, cUnitStateAlive);
	if(currentLivestock != livestockCount)
	{
		currentLivestock = livestockCount;
		
		livestockPlanKill = 1;
	}
	
	static int default_plan = -1;
	if (livestockPlanKill == 1)
	{
		aiPlanDestroy(default_plan);
		default_plan = -1;
		for (j = 0; < 100)
		{
			xsArraySetInt(excludeLivestockArray, j, -1);
		}
	}
	if (default_plan == -1)
	{
		default_plan = aiPlanCreate("HerdToBase", cPlanDefend);
		aiPlanSetDesiredPriority(default_plan, 1);
		aiPlanAddUnitType(default_plan, cUnitTypeHerdable, 0, 0, 200);
		aiPlanSetNoMoreUnits(default_plan, true);
		aiPlanSetVariableVector(default_plan, cDefendPlanDefendPoint, 0, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
		aiPlanSetActive(default_plan, true);
		static int liveStockAdd2 = -1; //current fatten livestock
		if (liveStockAdd2 == -1) liveStockAdd2 = kbUnitQueryCreate("liveStockAdd2"); //livestock counter 
		kbUnitQuerySetPlayerID(liveStockAdd2, cMyID, false);
		kbUnitQuerySetUnitType(liveStockAdd2, cUnitTypeHerdable);
		//kbUnitQuerySetState(liveStockAdd2, cUnitTypeHerdable);
		kbUnitQuerySetState(liveStockAdd2, cUnitStateAlive);
		for (i = 0; < kbUnitQueryExecute(liveStockAdd2))
		{ //loop through livestock
			int livestockId1 = kbUnitQueryGetResult(liveStockAdd2, i);
			bool getInventory1 = kbUnitIsInventoryFull(livestockId1);
			if (getInventory1 == false)
			{
				
				bool addunit1 = true;
				int arrayValue1 = -1;
				if (addunit1 == true)
				{
					aiPlanAddUnit(default_plan, livestockId1);
				}
			}
		}
	}
	
	for (index = 0; < aiPlanGetNumber(cPlanHerd, -1, true))
	{
		int plan = aiPlanGetIDByIndex(cPlanHerd, -1, true, index);
		if (plan == default_plan) continue;
		
		int house = aiPlanGetVariableInt(plan, cHerdPlanBuildingID, 0);
		if (kbUnitGetPlayerID(house) != cMyID || livestockPlanKill == 1)
		{
			xsQVSet("Herding" + house, 0.0);
			aiPlanDestroy(plan);
		}
	}
	static int house_query = -1;
	if (livestockPlanKill == 1)
	{
		aiPlanDestroy(house_query);
		house_query = -1;
		livestockPlanKill = 0;
	}
	if (house_query == -1)
	{
		house_query = kbUnitQueryCreate("HouseToHerd");
		kbUnitQuerySetState(house_query, cUnitStateAlive);
		kbUnitQuerySetUnitType(house_query, cUnitTypeAbstractHouse);
		kbUnitQuerySetPlayerRelation(house_query, -1);
		kbUnitQuerySetPlayerID(house_query, cMyID, false);
	}
	
	kbUnitQueryResetResults(house_query);
	for (index = 0; < kbUnitQueryExecute(house_query))
	{
		house = kbUnitQueryGetResult(house_query, index);
		if (xsQVGet("Herding" + house) >= 1.0) continue;
		plan = aiPlanCreate("Herding" + house, cPlanHerd);
		aiPlanSetDesiredPriority(plan, 100);
		xsQVSet("Herding" + house, plan + 1);
		aiPlanAddUnitType(plan, cUnitTypeHerdable, 0, 0, 2);
		aiPlanSetNoMoreUnits(plan, true);
		aiPlanSetVariableInt(plan, cHerdPlanBuildingID, 0, house);
		aiPlanSetVariableFloat(plan, cHerdPlanDistance, 0, 0.0);
		aiPlanSetActive(plan, true);
		
		int addCount = 0;
		int addedCount = xsQVGet("Herding" + house);
		static int liveStockAdd = -1; //current fatten livestock
		if (liveStockAdd == -1) liveStockAdd = kbUnitQueryCreate("liveStockAdd"); //livestock counter 
		kbUnitQuerySetPlayerID(liveStockAdd, cMyID, false);
		kbUnitQuerySetUnitType(liveStockAdd, cUnitTypeHerdable);
		//kbUnitQuerySetState(liveStockAdd, cUnitTypeHerdable);
		kbUnitQuerySetState(liveStockAdd, cUnitStateAlive);
		for (i = 0; < kbUnitQueryExecute(liveStockAdd))
		{ //loop through livestock
			int livestockId = kbUnitQueryGetResult(liveStockAdd, i);
			bool getInventory = kbUnitIsInventoryFull(livestockId);
			if (getInventory == false && addCount < 2)
			{
				bool addunit = true;
				int arrayValue = -1;
				for (j = 0; < 100)
				{
					arrayValue = xsArrayGetInt(excludeLivestockArray, j);
					if (arrayValue == -1)
					{
						break;
					}
					
					if (arrayValue == livestockId)
					{
						addunit = false;
						break;
					}
				}
				if (addunit == true)
				{
					xsArraySetInt(excludeLivestockArray, j, livestockId);
					aiPlanAddUnit(plan, livestockId);
					addCount++;
				}
			}
		}
		
	}
	if (livestockPlanKill == 1) livestockPlanKill = 0;
}

//==============================================================================
/* rule livestockFatten
	updatedOn 2019/09/25 By ageekhere  
*/
//==============================================================================
//rule livestockFatten
//active
//minInterval 20
void livestockFatten()
{ //moves fatten livestock to area around tc
	if(kbGetCiv() == cCivJapanese || kbGetCiv() == cCivSPCJapanese || kbGetCiv() == cCivSPCJapaneseEnemy) return;
	static int lifeStockCount = -1; //current fatten livestock
	if (lifeStockCount == -1) lifeStockCount = kbUnitQueryCreate("lifeStockCount"); //livestock counter 
	kbUnitQuerySetPlayerID(lifeStockCount, cMyID, false); 
	kbUnitQuerySetUnitType(lifeStockCount, cUnitTypeHerdable);
	//kbUnitQuerySetState(lifeStockCount, cUnitTypeHerdable);
	kbUnitQuerySetState(lifeStockCount, cUnitStateAlive);
	float vectSpace = 1; //for spacing
	int livestockId = -1;
	bool getInventory = false;
	float cxLocation = -1;
	float czLocation = -1;
	float dxLocation = -1;
	float dzLocation = -1;
	float xDiff = -1;
	float zDiff = -1;
	vector cLocation = cInvalidVector;
	vector dLocation = cInvalidVector;
	for (i = 0; < kbUnitQueryExecute(lifeStockCount))
	{ //loop through livestock
		livestockId = kbUnitQueryGetResult(lifeStockCount, i); //get livestock id
		getInventory = kbUnitIsInventoryFull(livestockId); //getInventory value
		vector vecDist = vector(8.0, 0.0, 8.0); //que spacing
		for (j = 0; < vectSpace)
		{ // create a que around the tc
			if (j < 7) vecDist = vecDist + vector(0.0, 0.0, -3.0);
			else if (j < 14) vecDist = vecDist + vector(-3.0, 0.0, 0.0);
			else if (j < 21) vecDist = vecDist + vector(0.0, 0.0, 3.0);
			else if (j > 20) vecDist = vecDist + vector(3.0, 0.0, 0.0);
		} //end for
		
		if (getInventory == true)
		{ //que fatten livestock
			//do not move livestock if at tc
			cLocation = kbUnitGetPosition(livestockId);
			dLocation = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) - vecDist;
			cxLocation = xsVectorGetX(cLocation);
			czLocation = xsVectorGetZ(cLocation);
			dxLocation = xsVectorGetX(dLocation);
			dzLocation = xsVectorGetZ(dLocation);
			xDiff = cxLocation - dxLocation;
			zDiff = czLocation - dzLocation;
			
			vectSpace = vectSpace + 1;
			if ((xDiff > 1 || xDiff < -1) || (zDiff > 1 || zDiff < -1))
			{
				//aiPlanDestroy(livestockPlan);
				livestockPlanKill = 1;
				//livestockPlan = -1;
				aiTaskUnitMove(livestockId, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) - vecDist);
				
			}
		} //end if
	} //end for
} //end livestockFatten

rule AI_AutoRepair
active
minInterval 10
{ //Gives hard and expert ai auto repair cheat
	//if (aiGetWorldDifficulty() < cDifficultyHard)
	//{ //check Difficulty level
		//	xsDisableSelf(); //disable rule
		//	return;
	//} //end if
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 1) return; //check for town center
	aiTaskUnitResearch(getUnit(gTownCenter), cTechAIAutoRepair); //give ai auto repair cheat 
	if (kbTechGetStatus(cTechAIAutoRepair) == cTechStatusActive) xsDisableSelf(); //disable rule when ai has tech
} //end AI_AutoRepair

//==============================================================================
/* rule AI_LateCheats
	updatedOn 2019/10/08 By ageekhere  
*/
//==============================================================================
rule AI_EarlyCheats
active
minInterval 10
{ //Gives hard and expert ai AICheats
	if(kbGetAge() < cAge2) return;
	if (aiGetWorldDifficulty() < cDifficultyHard)
	{ //check Difficulty level
		xsDisableSelf(); //disable rule
		return;
	} //end if
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 1) return; //check for town center
	aiTaskUnitResearch(getUnit(gTownCenter), cTechAICheats); //give ai cheats 
	if (kbTechGetStatus(cTechAICheats) == cTechStatusActive) xsDisableSelf(); //disable rule when ai has tech
} //end AI_EarlyCheats

//==============================================================================
/* rule AI_LateCheats
	updatedOn 2019/10/08 By ageekhere  
*/
//==============================================================================
rule AI_LateCheats
active
minInterval 10
{ //Gives an expert ai AICheatsAge4
	if(kbGetAge() < cAge3) return;
	if (aiGetWorldDifficulty() < cDifficultyExpert)
	{ //check Difficulty level 
		xsDisableSelf(); //disable rule
		return;
	} //end if
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) < 1) return; //check for town center
	aiTaskUnitResearch(getUnit(gTownCenter), cTechAICheatsAge4); //give ai age 4 cheats 
	if (kbTechGetStatus(cTechAICheatsAge4) == cTechStatusActive) xsDisableSelf(); //disable rule when ai has tech
} //end AI_LateCheats

//==============================================================================
/* rule make_2nd_fort
	updatedOn 2019/08/20 By ageekhere  
*/
//==============================================================================
//rule make_2nd_fort
//active
//minInterval 10
void make_2nd_fort()
{ //sends the fort Wagon to build a new fort
	if (kbUnitCount(cMyID, cUnitTypeFortWagon, cUnitStateAlive) == 0) return; //Check for alive Fort Wagons	
	if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateAlive) == 0) return; //Check for alive FortFrontier, Not ABQ, in case the existing wagon is used by plan	
	if (gForwardBaseState != cForwardBaseStateActive) return; //Check if the current foward base state is not active
	if (kbUnitCount(cMyID, cUnitTypeFortFrontier, cUnitStateABQ) >= kbGetBuildLimit(cMyID, cUnitTypeFortFrontier)) return; //Check if the number of Fort Frontiers is under build limit	
	if (aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, cUnitTypeFortFrontier, true) >= 0) return; //Check if there is already a plan	
	int fort_plan = -1; //2nd fort plan
	if (controlCenter == true) fort_plan = createLocationBuildPlan(cUnitTypeFortFrontier, 1, 100, false, cRootEscrowID, kbGetMapCenter(), 1); //build in center
	else fort_plan = createLocationBuildPlan(cUnitTypeFortFrontier, 1, 100, false, cRootEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1); //build in base
	aiPlanAddUnitType(fort_plan, cUnitTypeFortWagon, 1, 1, 1); //Add unit to plan
	/*
		Note: The ai can only send 1 FortWagon at a time to build a fort, an issue can happen while a fort is being built the ai will try and send the second FortWagon to the same location as the first FortWagon.
		However once the first fort is built the next FortWagon will go to a new location. Some time can be lost here.
	*/
	//aiPlanSetEventHandler(fort_plan, cPlanEventStateChange, "fort_2_state"); //disabled
} //end make_2nd_fort

//==============================================================================
/* rule gatherer_tasking
	updatedOn 2020/10/13 By ageekhere  
*/
//==============================================================================
bool assignSettler(int lookId = -1, int numberAssigned = -1)
{
	for(j = 0; < kbUnitQueryNumberResults(lookId))
	{
		if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( lookId, j ) ) != -1)
		{
			if( kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( lookId, j ) ) > numberAssigned ||
			kbUnitGetNumberTargeters( kbUnitQueryGetResult ( lookId, j ) ) > numberAssigned)
			{
				return(false);
			}
		}
	}
	return(true);
}
int countAllAllocations(int queryId = 0, int queryNum = 0)
{
	int results = 0;
	for (j = 0; < queryNum)
	{
		if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( queryId, j ) ) != 1)
		{
			results = results + kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( queryId, j ) );
			//results = results + kbUnitGetNumberTargeters( kbUnitQueryGetResult ( queryId, j ) );
		}
	}
	return(results);
}

void gathererTasking(int idleArray = -1)
{
	if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) == 0 && kbGetAge() == cAge1) return;
	if (kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) == cInvalidVector) return;
	int numVill = kbUnitCount(cMyID, cUnitTypeAffectedByTownBell, cUnitStateAlive);
	int iWood = numVill * aiGetResourceGathererPercentage(cResourceWood, cRGPActual);
	int iCoin = numVill * aiGetResourceGathererPercentage(cResourceGold, cRGPActual); 	
	int iFood = numVill * aiGetResourceGathererPercentage(cResourceFood, cRGPActual);
	int overflowWood = 0;
	if (iWood > 10)
	{
		overflowWood = (iWood - 10);
		iWood = 10;
	}
	/*
	if(kbGetAge() == cAge1)
	{
		if(iWood > 1) iWood = 1;
		overflowWood = iWood - 1;
	}
	if(kbGetAge() == cAge2)
	{
		if(iWood > 10) iWood = 10;
		overflowWood = iWood - 10;
	}
	if(kbGetAge() == cAge3)
	{
		if(iWood > 20) iWood = 20;
		overflowWood = iWood - 20;
	}
	if(kbGetAge() == cAge4)
	{
		if(iWood > 20) iWood = 20;
		overflowWood = iWood - 20;
	}
	if(kbGetAge() == cAge5)
	{
		if(iWood > 20) iWood = 20;
		overflowWood = iWood - 20;
	}
	*/
	int swap = 0;
	for(i = 0; < overflowWood)
	{
		if(swap == 0)
		{
			iFood++;
			swap = 1;
		}
		else
		{
			iCoin++;
			swap = 0;
		}	
	}
	gatherRange = 50; //Dynamic gather range
	for(t = 0; < 100)
	{ //dynamically incress gather range
		
		if (getUnitByLocation(cUnitTypeLogicalTypeBuildingsNotWallsOrGroves, cPlayerRelationEnemyNotGaia, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), gatherRange) != -1) break; //check for enemy buildings that are not gaia
		if (getUnitByLocation(cUnitTypeMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), gatherRange) != -1) break; //check for enemy that are not gaia
		if(getUnitByLocation(cUnitTypeMinedResource, cPlayerRelationAny, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), gatherRange) == -1 ||
			getUnitByLocation(cUnitTypeAnimalPrey, cPlayerRelationAny, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), gatherRange) == -1 ||
		getUnitByLocation(cUnitTypeTree, cPlayerRelationAny, cUnitStateAlive, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), gatherRange) == -1)
		{ //incress range if there is no mine, animal or trees
			gatherRange = gatherRange + 10; // incress range
		}//end if
		else
		{ //stop incressing gather range
			gatherRange = gatherRange + 10;
			break;
		} //end else
	} //end for
	if(kbGetAge() > cAge3) gatherRange = 80;
	
	static int crateLook = -1;
	kbUnitQueryDestroy(crateLook);
	crateLook = kbUnitQueryCreate("crateLook");
	kbUnitQuerySetPlayerID(crateLook, cMyID, true); 
	kbUnitQuerySetUnitType(crateLook, cUnitTypeAbstractResourceCrate);
	kbUnitQuerySetState(crateLook, cUnitStateAlive);
	kbUnitQuerySetPosition(crateLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(crateLook,true);
	kbUnitQuerySetMaximumDistance(crateLook,gatherRange);
	kbUnitQueryExecute(crateLook);
	int crateNum = kbUnitQueryExecute(crateLook);
	
	static int treeLook = -1;
	kbUnitQueryDestroy(treeLook);
	treeLook = kbUnitQueryCreate("treeLook");
	kbUnitQuerySetPlayerID(treeLook, 0, true); 
	kbUnitQuerySetUnitType(treeLook, cUnitTypeTree);
	kbUnitQuerySetState(treeLook, cUnitStateAlive);
	kbUnitQuerySetPosition(treeLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(treeLook,true);
	kbUnitQuerySetMaximumDistance(treeLook,gatherRange);
	kbUnitQueryExecute(treeLook);
	int treeNum = kbUnitQueryExecute(treeLook);
	
	static int mineLook = -1;
	kbUnitQueryDestroy(mineLook);
	mineLook = kbUnitQueryCreate("mineLook");
	kbUnitQuerySetPlayerID(mineLook, 0, true); 
	kbUnitQuerySetUnitType(mineLook, cUnitTypeMinedResource);
	kbUnitQuerySetState(mineLook, cUnitStateAlive);
	kbUnitQuerySetPosition(mineLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(mineLook,true);
	kbUnitQuerySetMaximumDistance(mineLook,gatherRange);
	int mineNum = kbUnitQueryExecute(mineLook);
	
	static int livestockLook = -1;
	kbUnitQueryDestroy(livestockLook);
	livestockLook = kbUnitQueryCreate("livestockLook");
	kbUnitQuerySetPlayerID(livestockLook, cMyID, true); 
	kbUnitQuerySetUnitType(livestockLook, cUnitTypeHerdable);
	kbUnitQuerySetState(livestockLook, cUnitStateAlive);
	kbUnitQuerySetPosition(livestockLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	//kbUnitQuerySetAscendingSort(livestockLook,true);
	kbUnitQuerySetMaximumDistance(livestockLook,gatherRange);
	kbUnitQueryExecute(livestockLook);
	int livestockNum = kbUnitQueryExecute(livestockLook);
	
	static int livestockALLLook = -1;
	kbUnitQueryDestroy(livestockALLLook);
	livestockALLLook = kbUnitQueryCreate("livestockALLLook");
	kbUnitQuerySetPlayerID(livestockALLLook, cMyID, true); 
	kbUnitQuerySetUnitType(livestockALLLook, cUnitTypeHerdable);
	kbUnitQuerySetState(livestockALLLook, cUnitStateAny);
	kbUnitQuerySetPosition(livestockALLLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(livestockALLLook,true);
	kbUnitQuerySetMaximumDistance(livestockALLLook,gatherRange);
	kbUnitQueryExecute(livestockALLLook);
	int livestockALLNum = kbUnitQueryExecute(livestockALLLook);
	
	static int preyLook = -1;
	kbUnitQueryDestroy(preyLook);
	preyLook = kbUnitQueryCreate("preyLook");
	kbUnitQuerySetPlayerID(preyLook, 0, true); 
	kbUnitQuerySetUnitType(preyLook, cUnitTypeAnimalPrey);
	kbUnitQuerySetState(preyLook, cUnitStateAlive);
	kbUnitQuerySetPosition(preyLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(preyLook,true);
	kbUnitQuerySetMaximumDistance(preyLook,gatherRange);
	int prayNum = kbUnitQueryExecute(preyLook);
	
	static int preyAllLook = -1;
	kbUnitQueryDestroy(preyAllLook);
	preyAllLook = kbUnitQueryCreate("preyAllLook");
	kbUnitQuerySetPlayerID(preyAllLook, 0, true); 
	kbUnitQuerySetUnitType(preyAllLook, cUnitTypeAnimalPrey);
	kbUnitQuerySetState(preyAllLook, cUnitStateAny);
	kbUnitQuerySetPosition(preyAllLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(preyAllLook,true);
	kbUnitQuerySetMaximumDistance(preyAllLook,gatherRange);
	int prayAllNum = kbUnitQueryExecute(preyAllLook);
	
	static int preyDeadLook = -1;
	kbUnitQueryDestroy(preyDeadLook);
	preyDeadLook = kbUnitQueryCreate("preyDeadLook");
	kbUnitQuerySetPlayerID(preyDeadLook, 0, true); 
	kbUnitQuerySetUnitType(preyDeadLook, cUnitTypeAnimalPrey);
	kbUnitQuerySetState(preyDeadLook, cUnitStateDead);
	kbUnitQuerySetPosition(preyDeadLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(preyDeadLook,true);
	kbUnitQuerySetMaximumDistance(preyDeadLook,gatherRange);
	int prayDeadNum = kbUnitQueryExecute(preyDeadLook);
	
	static int berryLook = -1;
	kbUnitQueryDestroy(berryLook);
	berryLook = kbUnitQueryCreate("berryLook");
	kbUnitQuerySetPlayerRelation(berryLook, cPlayerRelationAny);
	//kbUnitQuerySetPlayerID(berryLook, 0, true); 
	kbUnitQuerySetUnitType(berryLook, cUnitTypeAbstractFruit);
	kbUnitQuerySetState(berryLook, cUnitStateAlive);
	kbUnitQuerySetPosition(berryLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(berryLook,true);
	kbUnitQuerySetMaximumDistance(berryLook,gatherRange);
	int berryNum = kbUnitQueryExecute(berryLook);
	
	static int millLook = -1;
	kbUnitQueryDestroy(millLook);
	millLook = kbUnitQueryCreate("millLook");
	kbUnitQuerySetPlayerID(millLook, cMyID, true); 
	kbUnitQuerySetUnitType(millLook, cUnitTypeMill);
	kbUnitQuerySetState(millLook, cUnitStateAlive);
	kbUnitQuerySetPosition(millLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(millLook,true);
	kbUnitQuerySetMaximumDistance(millLook,gatherRange);
	int millNum = kbUnitQueryExecute(millLook);

	static int farmLook = -1;
	kbUnitQueryDestroy(farmLook);
	farmLook = kbUnitQueryCreate("farmLook");
	kbUnitQuerySetPlayerID(farmLook, cMyID, true); 
	kbUnitQuerySetUnitType(farmLook, cUnitTypeFarm);
	kbUnitQuerySetState(farmLook, cUnitStateAlive);
	kbUnitQuerySetPosition(farmLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(farmLook,true);
	kbUnitQuerySetMaximumDistance(farmLook,gatherRange);
	int farmNum = kbUnitQueryExecute(farmLook);
	
	static int plantationLook = -1;
	kbUnitQueryDestroy(plantationLook);
	plantationLook = kbUnitQueryCreate("plantationLook");
	kbUnitQuerySetPlayerID(plantationLook, cMyID, true); 
	kbUnitQuerySetUnitType(plantationLook, cUnitTypePlantation);
	kbUnitQuerySetState(plantationLook, cUnitStateAlive);
	kbUnitQuerySetPosition(plantationLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(plantationLook,true);
	kbUnitQuerySetMaximumDistance(plantationLook,gatherRange);
	int plantationNum = kbUnitQueryExecute(plantationLook);
	
	static int riceLook = -1;
	kbUnitQueryDestroy(riceLook);
	riceLook = kbUnitQueryCreate("riceLook");
	kbUnitQuerySetPlayerID(riceLook, cMyID, true); 
	kbUnitQuerySetUnitType(riceLook, cUnitTypeypRicePaddy);
	kbUnitQuerySetState(riceLook, cUnitStateAlive);
	kbUnitQuerySetPosition(riceLook,kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	kbUnitQuerySetAscendingSort(riceLook,true);
	kbUnitQuerySetMaximumDistance(riceLook,gatherRange);
	int riceNum = kbUnitQueryExecute(riceLook);
	
	static int minerUsa = -1;
	static int minerPlan = -1;
	if(kbGetCiv() == cCivUSA)
	{
		kbUnitQueryDestroy(minerUsa);
		if(minerPlan == -1) minerPlan = createLocationBuildPlan(cUnitTypeMineGoldUS, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
		
		kbUnitQueryDestroy(minerUsa);
		minerUsa = kbUnitQueryCreate("minerUsa");
		kbUnitQuerySetPlayerID(minerUsa, cMyID, true); 
		kbUnitQuerySetUnitType(minerUsa, cUnitTypeGoldMiner);
		kbUnitQuerySetState(minerUsa, cUnitStateAlive);
		kbUnitQuerySetActionType(minerUsa,7);
		int minerUsaNum = kbUnitQueryExecute(minerUsa);
		for(i = 0; < minerUsaNum )
		{
			int minerId = kbUnitQueryGetResult ( minerUsa, i);
			aiTaskUnitWork(minerId, kbUnitQueryGetResult( mineLook, 0 ));
		}
		if(kbGetAge() > cAge2)
		{
			for(i = minerUsaNum; <= kbGetBuildLimit(cMyID, cUnitTypeGoldMiner))
			{
				aiTaskUnitTrain(getUnit(gTownCenter), cUnitTypeGoldMiner);
			}
		}
	}
	iWood = iWood - countAllAllocations(treeLook,treeNum);
	iCoin = iCoin - countAllAllocations(mineLook,mineNum);
	iCoin = iCoin - countAllAllocations(plantationLook,plantationNum);
	iFood = iFood - countAllAllocations(livestockALLLook,livestockALLNum);
	iFood = iFood - countAllAllocations(preyAllLook,prayAllNum);
	iFood = iFood - countAllAllocations(berryLook,berryNum);
	iFood = iFood - countAllAllocations(millLook,millNum);
	iFood = iFood - countAllAllocations(farmLook,farmNum);
	
		
	if(iWood < 0)reallocateSettlers = true;
	if(iFood < 0)reallocateSettlers = true;
	if(iCoin < 0)reallocateSettlers = true;
	
	bool createAssigned = false;
	bool mineAssigned = false;
	bool treeAssigned = false;
	bool livestockAssigned = false;
	bool preyAssigned = false;
	bool berryAssigned = false;
	bool millAssigned = false;
	bool farmAssigned = false;
	bool plantationAssigned = false;
	int settlerId = -1;
	bool nextSettler = false;
	int resourceCount = 0;
	int livestockAddedThisTurn = 0;
	int preyAddedThisTurn = 0;
	int berryAddedThisTurn = 0;
	int mineAddedThisTurn = 0;
	int ageAssign = 0;
	int roundAddedLivestock = 0;

	static bool age1Wood = false;
	static bool age2reset = false;
	if (kbGetAge() == cAge1 && agingUp() == true && age1Wood == false)
	{						
		age1Wood = true;
		for (j = 0; < kbUnitCount(cMyID, gEconUnit, cUnitStateAlive))
		{
			if(kbUnitIsType(kbUnitGetTargetUnitID(settlerId),cUnitTypeTree) == false)
			settlerId = FIND(gEconUnit, cMyID, j);
			aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( treeLook, 0 ));
		}
		return;
	}
	
	if (kbGetAge() == cAge2 && age2reset == false)
	{						
		age2reset = true;
		bool gotoFood = true;
		for (j = 0; < kbUnitCount(cMyID, gEconUnit, cUnitStateAlive))
		{
			settlerId = FIND(gEconUnit, cMyID, j);
			if(gotoFood == true)
			{
				gotoFood = false;
				if(prayDeadNum > 0)aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( preyDeadLook, 0 ));
				else aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( preyLook, 0 )); 
			}
			else if(gotoFood == false)
			{
				aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( mineLook, 0 ));
				gotoFood = true;
			}
			
		}
		return;
	}
	
	
	
	
	

	
	for(i = 0; < maxVillPop )
	{
		settlerId = xsArrayGetInt(idleArray, i);
		if(settlerId == -1) return;
		nextSettler = false;
		
		aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( treeLook, 0 ));
		
		if(createAssigned == false && crateNum > 0)
		{		
			for(k = 0; < crateNum)
			{
				if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( crateLook, k ) ) == -1) break;
				resourceCount = resourceCount + kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( crateLook, k ) );
			}
			if ( resourceCount > 1 )
			{
				createAssigned = true;
				break;
			}
			aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( crateLook, 0 ));
			createAssigned = true;
			continue;
		}
		
		if (kbGetAge() == cAge1 && agingUp() == true)
		{						
			for (j = 0; < kbUnitCount(cMyID, gEconUnit, cUnitStateAlive))
			{
				settlerId = FIND(gEconUnit, cMyID, j);
				aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( treeLook, 0 ));
			}
			return;
		}
		
		for(j = 0; < xsArrayGetSize(huntSettlersArray))
		{
			if (settlerId == xsArrayGetInt(huntSettlersArray,j))
			{
				if(prayDeadNum > 0)
				{
					for(k = 0; < prayDeadNum)
					{
						if(kbUnitGetCurrentInventory(kbUnitQueryGetResult ( preyDeadLook, k ),cResourceFood ) > 100)
						{
							aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( preyDeadLook, k ));
							nextSettler = true;
							break;
						}
					}
				}
				
				else if( distance(kbUnitGetPosition(settlerId), kbUnitGetPosition(huntUnitMoveTo) ) <= 7 )
				{
					xsArraySetInt(huntSettlersArray,j,-1);
				}
				else if(kbUnitGetPosition(huntUnitMoveTo)!= cInvalidVector)
				{
					aiTaskUnitMove(settlerId, kbUnitGetPosition(huntUnitMoveTo));
					
					nextSettler = true;
				}
				break;
			}	
		}
		
		if(nextSettler == true) continue;
		resourceCount = 0;
		
		if(iFood > 0 && preyAssigned == false && prayNum > 0 && kbGetCiv() != cCivJapanese && kbGetCiv() != cCivSPCJapanese && kbGetCiv() != cCivSPCJapaneseEnemy)//&& kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive) < 2
		{	
			int countHunters = 0;
			bool skipHunt = false;
			if(farmNum > 0 && kbGetAge() > cAge3)
			{
				for(l = 0; < maxVillPop)
				{
					if(xsArrayGetInt(huntSettlersArray,l) == -1)
					{
						countHunters++;
						if(countHunters > 10) 
						{
							skipHunt = true;
							break;
						}
					}
				}
			}
			
			/*if(farmNum > 0 && kbGetAge() > cAge2)
			{
				for(j = 0; < farmNum)
				{
					if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( farmLook, j ) ) == -1)break;
					if( kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( farmLook, j ) ) < 10 && kbUnitGetNumberTargeters( kbUnitQueryGetResult (farmLook) ) < 10 )
					{
						aiPlanDestroy(kbUnitGetPlanID(settlerId));																	   
						aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( farmLook, j ));
						iFood--;
						nextSettler = true;
						break;
					}
				}
			}
			*/
			if(skipHunt == false)
			{
				bool foundDead = false;
				switch(kbGetAge())
				{
					case cAge1:{ageAssign = maxVillPop;break;}
					case cAge2:{ageAssign = maxVillPop;break;}
					case cAge3:{ageAssign = 5;break;}
					case cAge4:{ageAssign = 5;break;}
					case cAge5:{ageAssign = 5;break;}
				}
				
				if(prayDeadNum > 0)
				{
					for(j = 0; < prayDeadNum)
					{
						if(kbUnitGetCurrentInventory(kbUnitQueryGetResult ( preyDeadLook, j ),cResourceFood ) > 100)
						{
							preyLook = preyDeadLook;
							prayNum = prayDeadNum;
							foundDead = true;
							break;
						}
					}
				}
				
				if(assignSettler(preyLook,10) == true)
				{
					for(j = 0; < prayNum)
					{
						if(iFood == 0) break;
						if(j+1 <= prayNum && foundDead == false)
						{
							if( distance(kbUnitGetPosition(kbUnitQueryGetResult ( preyLook, 0 )),kbUnitGetPosition(kbUnitQueryGetResult ( preyLook, j + 1 ))) < 40 )
							{
								continue;
							}
						}
						if(kbUnitGetCurrentInventory(kbUnitQueryGetResult ( preyLook, j ),cResourceFood ) > 100)
						{
							for(k = 0; < prayAllNum)
							{
								if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( preyAllLook, k ) ) == -1) break;
								resourceCount = resourceCount + kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( preyAllLook, k ) );
							}
							resourceCount = resourceCount + preyAddedThisTurn;
							if (resourceCount >= ageAssign)
							{
								preyAssigned = true;
								nextSettler = true;
								break;
							}	
							vector kiteLocation = cInvalidVector;
							vector kiteLocationCheck = kbUnitGetPosition(kbUnitQueryGetResult ( preyLook, j )) ;			
							float farthestDist = 0;
							float distCheck = 0;
							float dx = 5;
							float dz = 5;				
							for(t = 0;< 8)
							{
								dx = 5;
								dz = 5;
								switch(t) 
								{ 
									case 0:{dx = -0.9 * dx;dz = 0.9 * dz;break;} // W
									case 1:{dx = 0.0;break;}// NW
									case 2:{dx = 0.9 * dx;dz = 0.9 * dz;break;} // N
									case 3:{dz = 0.0;break;}// NE
									case 4:{dx = 0.9 * dx;dz = -0.9 * dz;break;}//E	
									case 5:{dx = 0.0;dz = -1.0 * dz;break;}// SE					
									case 6:{dx = -0.9 * dx;dz = -0.9 * dz;break;}// S
									case 7:{dx = -1.0 * dx;dz = 0;break;}// SW				
								}
								
								kiteLocationCheck = kbUnitGetPosition(kbUnitQueryGetResult ( preyLook, j ));
								kiteLocationCheck = xsVectorSetX(kiteLocationCheck, xsVectorGetX(kiteLocationCheck) + dx);
								kiteLocationCheck = xsVectorSetZ(kiteLocationCheck, xsVectorGetZ(kiteLocationCheck) + dz);
								
								distCheck = distance(kiteLocationCheck, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
								if(distCheck > farthestDist)
								{
									kiteLocation = kiteLocationCheck;
									farthestDist = distCheck;
								}	
								
							}	
							if( distance(kbUnitGetPosition(settlerId), kbUnitGetPosition(kbUnitQueryGetResult ( preyLook, j ))) > 7 )
							{
								aiTaskUnitMove(settlerId, kiteLocation);
								aiPlanDestroy(kbUnitGetPlanID(settlerId));
								preyAddedThisTurn++;						 
								for(l = 0; < maxVillPop)
								{
									if(xsArrayGetInt(huntSettlersArray,l) == -1)
									{
										xsArraySetInt(huntSettlersArray, l, settlerId);
										huntUnitMoveTo = kbUnitQueryGetResult ( preyLook, j );
										break;
									}
								}
							}
							else
							{
								aiPlanDestroy(kbUnitGetPlanID(settlerId));
								aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( preyLook, j ));
							}
							iFood--;
							nextSettler = true;
							preyAddedThisTurn++;
							break;
						}
					}	
				}
				if(nextSettler == true) continue;
			}
		}
		
		
		
		resourceCount = 0;
		if(iCoin > 0 && mineAssigned == false && mineNum > 0 )//&& kbUnitCount(cMyID, gPlantationUnit, cUnitStateAlive) < 2
		{	
			if(assignSettler(mineLook,19) == true && mineAddedThisTurn < 20)
			{
				aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( mineLook, 0 ));
				iCoin--;
				nextSettler = true;
				mineAddedThisTurn++;
			}
			else
			{
				mineAssigned = true;
			}
			if(nextSettler == true) continue;
		}
		
		resourceCount = 0;
		if(iFood > 0 && livestockAssigned == false && livestockNum > 0 && kbGetCiv() != cCivJapanese && kbGetCiv() != cCivSPCJapanese && kbGetCiv() != cCivSPCJapaneseEnemy)
		{	
			if(roundAddedLivestock > 1)break;
			switch(kbGetAge())
			{
				case cAge1: {ageAssign = 2;break;}
				case cAge2: {ageAssign = 2;break;}
				case cAge3: {ageAssign = 2;break;}
				case cAge4: {ageAssign = 2;break;}
				case cAge5: {ageAssign = 2;break;}
			}
			
			for(j = 0; < livestockNum)
			{
				if(iFood == 0) break;
				if( kbUnitIsInventoryFull(kbUnitQueryGetResult ( livestockLook, j )) == true ) 
				{
					resourceCount = 0;
					for(k = 0; < livestockALLNum)
					{
						if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( livestockALLLook, k ) ) == -1) break;
						resourceCount = resourceCount + kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( livestockALLLook, k ) );
					}
					if (livestockAddedThisTurn + resourceCount > ageAssign)
					{
						livestockAssigned = true;
						break;
					}
					if(roundAddedLivestock > 1)break;
					aiPlanDestroy(kbUnitGetPlanID(settlerId));		   
					aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( livestockLook, j ));
					iFood--;
					nextSettler = true;
					livestockAddedThisTurn++;
					roundAddedLivestock++;
					break;
				}
			}
			if(nextSettler == true) continue;
		}
		
		resourceCount = 0;
		if(kbGetCiv() == cCivJapanese || kbGetCiv() == cCivSPCJapanese || kbGetCiv() == cCivSPCJapaneseEnemy)
		{
			if(iFood > 0 && berryAssigned == false && berryNum > 0)
			{		
				for(k = 0; < berryNum)
				{
					if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( berryLook, k ) ) == -1) break;
					resourceCount = resourceCount + kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( berryLook, k ) );
				}
				resourceCount = resourceCount + berryAddedThisTurn;
				
				int berryID = 0;
				for(k = 0; < berryNum)
				{
					if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( berryLook, k ) ) == -1) break;
					if( kbUnitGetMaximumHitpoints(kbUnitQueryGetResult ( berryLook, k ) ) >101 )
					{
						berryID = k;
						break;
					}
				}
				
				if (resourceCount > 20 && kbUnitGetMaximumHitpoints(kbUnitQueryGetResult ( berryLook, berryID )) > 101 )
				{
					berryAssigned = true;
					continue;
				}
				else if (resourceCount > 8 && kbUnitGetMaximumHitpoints(kbUnitQueryGetResult ( berryLook, berryID )) < 101 )
				{
					berryAssigned = true;
					continue;
				}
				
				aiPlanDestroy(kbUnitGetPlanID(settlerId));
				aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( berryLook, 0 ));
				iFood--;
				nextSettler = true;
				berryAddedThisTurn++;
				if(nextSettler == true) continue;
			}
		}
		
		resourceCount = 0;
		if(iFood > 0 && berryAssigned == false && berryNum > 0 && kbGetCiv() != cCivJapanese && kbGetCiv() != cCivSPCJapanese && kbGetCiv() != cCivSPCJapaneseEnemy)//&& kbUnitCount(cMyID, gFarmUnit, cUnitStateAlive) < 2
		{		
			if(assignSettler(berryLook,8) == true)
			{
				for(k = 0; < berryNum)
				{
					if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( berryLook, k ) ) == -1) break;
					resourceCount = resourceCount + kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( berryLook, k ) );
				}
				resourceCount = resourceCount + berryAddedThisTurn;
				if (resourceCount > 8)
				{
					berryAssigned = true;
					continue;
				}
				aiPlanDestroy(kbUnitGetPlanID(settlerId));		  
				aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( berryLook, 0 ));
				iFood--;
				nextSettler = true;
				berryAddedThisTurn++;
			}
			if(nextSettler == true) continue;
		}
		
		if(iFood > 0 && millNum > 0)
		{
			for(j = 0; < millNum)
			{
				if(iFood == 0) break;
				if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( millLook, j ) ) == -1)break;
				if( kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( millLook, j ) ) < 10)
				{
					aiPlanDestroy(kbUnitGetPlanID(settlerId));																	   
					aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( millLook, j ));
					iFood--;
					nextSettler = true;
					break;
				}
			}
			if(nextSettler == true) continue;
		}
		
		if(iFood > 0 && farmNum > 0)
		{
			for(j = 0; < farmNum)
			{
				if(iFood == 0) break;
				if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( farmLook, j ) ) == -1)break;
				if( kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( farmLook, j ) ) < 10)
				{
					aiPlanDestroy(kbUnitGetPlanID(settlerId));																	   
					aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( farmLook, j ));
					iFood--;
					nextSettler = true;
					break;
				}
			}
			if(nextSettler == true) continue;
		}
		
		if(iCoin > 0 && plantationNum > 0)
		{
			for(j = 0; < plantationNum)
			{
				if(iCoin == 0) break;
				if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( plantationLook, j ) ) == -1)break;
				if( kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( plantationLook, j ) ) < 10)
				{
					aiPlanDestroy(kbUnitGetPlanID(settlerId));																			 
					aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( plantationLook, j ));
					iCoin--;
					nextSettler = true;
					break;
				}
			}
			if(nextSettler == true) continue;
		}
		
		if(iCoin > 0 && riceNum > 0)
		{
			for(j = 0; < riceNum)
			{
				if(iCoin == 0) break;
				if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( riceLook, j ) ) == -1)break;
				if(aiUnitGetTactic(kbUnitQueryGetResult ( riceLook, j )) != cTacticPaddyCoin) continue;
				if( kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( riceLook, j ) ) < 10)
				{
					aiPlanDestroy(kbUnitGetPlanID(settlerId));																	   
					aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( riceLook, j ));
					iCoin--;
					nextSettler = true;
					break;
				}
			}
			if(nextSettler == true) continue;
		}
		
		if(iFood > 0 && riceNum > 0)
		{
			for(j = 0; < riceNum)
			{
				if(iFood == 0) break;
				if(kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( riceLook, j ) ) == -1)break;
				if(aiUnitGetTactic(kbUnitQueryGetResult ( riceLook, j )) != cTacticPaddyFood) continue;
				if( kbUnitGetNumberWorkersIfSeeable( kbUnitQueryGetResult ( riceLook, j ) ) < 10)
				{
					aiPlanDestroy(kbUnitGetPlanID(settlerId));																	   
					aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( riceLook, j ));
					iFood--;
					nextSettler = true;
					break;
				}
			}
			if(nextSettler == true) continue;
		}
				if(iWood > 0) 
		{
			if(kbUnitIsType(kbUnitGetTargetUnitID(settlerId),cUnitTypeTree) == false)
			{
				aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( treeLook, 0 ));
				iWood--;
			}
		}
		//if(kbUnitIsType(kbUnitGetTargetUnitID(settlerId),cUnitTypeTree) == false)
		//{
		//aiPlanDestroy(kbUnitGetPlanID(settlerId));							
		//
		//iWood--;
		//}
	}	
	/*
	int idleCheck = -1;
	idleCheck = kbUnitQueryCreate("idleCheck");
	kbUnitQuerySetPlayerID(idleCheck, cMyID, false);
	kbUnitQuerySetUnitType(idleCheck, gEconUnit);
	kbUnitQuerySetState(idleCheck, cUnitStateAlive);
	kbUnitQuerySetActionType(idleCheck,7);
	*/
	//bool idleAssigned = false;
	//for(i = 0; < kbUnitQueryExecute(idleCheck))
	////{
		//settlerId = kbUnitQueryGetResult(idleCheck, i);
		//aiChat(1,"hit nextSettler " +  settlerId);
		aiTaskUnitWork(settlerId, kbUnitQueryGetResult ( treeLook, 0 ));
		iWood--;
	//}

		

}

void checkIdleVill()
{
	static int settlerCheck = -1;
	static int settlerAllCheck = -1;
	static int lastTimeAllocation = 0;
	static int idleArray = -1;
	static bool age1Ageingup = false;
	static bool age2enter = false;
	if(settlerCheck < 0)
	{
		settlerCheck = kbUnitQueryCreate("settlerCheck");
		kbUnitQuerySetPlayerID(settlerCheck, cMyID, false); 
		kbUnitQuerySetUnitType(settlerCheck, cUnitTypeAffectedByTownBell);
		kbUnitQuerySetState(settlerCheck, cUnitStateAlive);
		kbUnitQuerySetActionType(settlerCheck,7);
	}
	kbUnitQueryResetResults(settlerCheck);
	if(settlerAllCheck < 0)
	{
		settlerAllCheck = kbUnitQueryCreate("settlerAllCheck");
		kbUnitQuerySetPlayerID(settlerAllCheck, cMyID, false); 
		kbUnitQuerySetUnitType(settlerAllCheck, cUnitTypeAffectedByTownBell);
		kbUnitQuerySetState(settlerAllCheck, cUnitStateAlive);
	}
	int allSettlers = kbUnitQueryResetResults(settlerAllCheck);	
	int idlesize = kbUnitQueryExecute(settlerCheck);
	if(idleArray == -1) idleArray = xsArrayCreateInt(200, -1, "idleSettlers");
	
	for (i = 0; < 200) 
	{
		xsArraySetInt(idleArray, i, -1 );
	}
	
	int v = 0;
	for (i = 0; < idlesize) 
	{
		xsArraySetInt(idleArray, i,kbUnitQueryGetResult(settlerCheck, i) );
		v = v + 1;
	}
	
	for (i = 0; < allSettlers) 
	{
		if(kbUnitGetActionType(kbUnitQueryGetResult(settlerAllCheck, i)) == -1  )
		{
			xsArraySetInt(idleArray, v,kbUnitQueryGetResult(settlerAllCheck, i) );
		}
	}	

	
	
	
	if(xsGetTime() > lastTimeAllocation + 300000)
	{
		reallocateSettlers = true;
	}
	
	//if (kbGetAge() == cAge1 && agingUp() == true && age1Ageingup == false) 
	//{
	//	age1Ageingup = true;
	//	reallocateSettlers = true;
	//	lastTimeAllocation = -120000;
	//}
	
	if (kbGetAge() == cAge2 && age2enter == false) 
	{
		age2enter = true;
		reallocateSettlers = true;
		lastTimeAllocation = -130000;
	}
	
	if( (reallocateSettlers == true && xsGetTime() > lastTimeAllocation + 120000))
	{
		reallocateSettlers = false;
		lastTimeAllocation = xsGetTime();
		for (i = 0; < allSettlers) 
		{
			xsArraySetInt(idleArray, i,kbUnitQueryGetResult(settlerAllCheck, i) );
		}	
	}
	gathererTasking(idleArray);
}


rule backBaseSet
active
minInterval 2
{
	static bool backBaseReset = true;
	if(getUnit(gTownCenter, cMyID, cUnitStateAlive) == -1)
	{
		backBaseReset = true;
		return;
	}
	if(backBaseReset == false) return;
	backBaseReset = false;
	vector currentPosition = kbUnitGetPosition(getUnit(gTownCenter, cMyID, cUnitStateAlive));
	vector backLocation = cInvalidVector;
	vector backLocationCheck =  currentPosition;
	
	float farthestDist = 0;
	float distCheck = 0;
	float dx = 15;
	float dz = 15;		
	
	for(t = 0;< 8)
	{
		dx = 15;
		dz = 15;
		switch(t) 
		{ 
			case 0:
			{  // W
				dx = -0.9 * dx;
				dz = 0.9 * dz;
				break;
			}
			case 1:
			{  // NW
				dx = 0.0;
				break;
			}
			case 2:
			{  // N
				dx = 0.9 * dx;
				dz = 0.9 * dz;
				break;
			}
			case 3:						
			{  // NE
				dz = 0.0;
				break;
			}
			case 4:									
			{  // E									
				dx = 0.9 * dx;
				dz = -0.9 * dz;	
				break;
			}
			case 5:
			{  // SE
				dx = 0.0;
				dz = -1.0 * dz;	
				break;
			}
			
			case 6:
			{  // S
				dx = -0.9 * dx;
				dz = -0.9 * dz;
				break;
			}
			case 7:
			{  // SW
				dx = -1.0 * dx;
				dz = 0;
				break;
			}
			
		}
		backLocationCheck = currentPosition;
		backLocationCheck = xsVectorSetX(backLocationCheck, xsVectorGetX(backLocationCheck) + dx);
		backLocationCheck = xsVectorSetZ(backLocationCheck, xsVectorGetZ(backLocationCheck) + dz);
		
		distCheck = distance(backLocationCheck, kbGetMapCenter());
		if(distCheck > farthestDist)
		{
			backLocation = backLocationCheck;
			farthestDist = distCheck;
		}
	}
	gBackBaseLocation = backLocation;
	
}
//==============================================================================
/* rule economyUpdate replaces build_plantation and build_mill
	Complete rewrite - updatedOn 2020/09/30 By ageekhere 
*/
//==============================================================================
void economyUpdate(int ecoType=-1, bool timeTo=false)
{ //Check if a new farm/plantation/rice paddy is needed
	if (timeTo == true && aiPlanGetIDByTypeAndVariableType(cPlanBuild, cBuildPlanBuildingTypeID, ecoType) == -1)
	{ //Check if it is time and a plan has not been created 
		int currentGatherers = 0; //The current number of villiagers currently gathering
		static int buildingCount = -1; //The current number of eco buildings
		if (buildingCount == -1) buildingCount = kbUnitQueryCreate("buildingCount"); //Creates a Query for counting eco buildings
		kbUnitQuerySetPlayerID(buildingCount, cMyID, false); //set the Query for the current ai
		kbUnitQuerySetUnitType(buildingCount, ecoType); //set to count ecoType buildings
		kbUnitQuerySetState(buildingCount, cUnitStateABQ); //set to count buildings that are alive and queued
		
		if(kbUnitQueryExecute(buildingCount) == 0)
		{
			createLocationBuildPlan(ecoType, 1, 100, true, cEconomyEscrowID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), 1);
			return;
		}
		
		for (i = 0; < kbUnitQueryExecute(buildingCount))
		{ //Loop through the AI's ecoType buildings
			currentGatherers = currentGatherers + kbUnitGetNumberWorkers(kbUnitQueryGetResult(buildingCount, i)); //Count the total number of villiagers on ecoType
		} //end for i
		
		
		if (currentGatherers > (7 * i)) 
		{ //when ecoType are all full
			//vector buildLocaiton = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
			vector buildLocaiton = gBackBaseLocation;
			
			//if( getUnit(gFarmUnit, cMyID, cUnitStateAlive) != -1 ) buildLocaiton = kbUnitGetPosition(getUnit(gFarmUnit, cMyID, cUnitStateAlive));
			//if( getUnit(gFarmUnit, cMyID, cUnitStateAlive) == -1 && ecoType == gFarmUnit) buildLocaiton = gBackBaseLocation;
			if(kbUnitCount(cMyID, ecoType, cUnitStateAlive) > 0)
			{
				buildLocaiton = kbUnitGetPosition(getUnit(ecoType, cMyID, cUnitStateAlive));
			}
			createLocationBuildPlan(ecoType, 1, 100, true, cEconomyEscrowID, buildLocaiton, 1); //use createLocationBuildPlan instead of createSimpleBuildPlan to prevent ai running out of room	
		} //end if
		buildingCount = -1;
	} //end if	
} //end economyUpdate

//rule build_economy
//inactive
//group tcComplete
//minInterval 10
void buildEconomy()
{ //controlls when the ai builds a new farm/plantation/rice paddy
	//if(xsGetTime() > 600000) gTimeToFarm = true;
	//if(xsGetTime() > 900000) gTimeForPlantations = true;
	if(cvOkToBuild == false) return;//xsDisableSelf(); //Check if the ai is allowed to build
	//if(kbGetAge() < cAge3 && xsGetTime() < 1200000) return; //Check if the ai is in age 2 (no farms in age 1)
	economyUpdate(gFarmUnit,gTimeToFarm); //Check if a new farm is needed
	//if(kbGetAge() < cAge3) return; //Check if the ai is in age 3 (no plantations in age 1 or 2)
	economyUpdate(gPlantationUnit,gTimeForPlantations); //Check if a new plantation is needed
} //end build_economy

//==============================================================================
/* rule popManager
	updatedOn 2019/08/23 By ageekhere 
	Set population limits based on age, difficulty and control variable settings
	New feature added, ai catch up, caps military size inorder to boom
*/
//==============================================================================
//rule popManager
//active
//minInterval 60
void popManager()
{ //sets the setMilPopLimit/aiSetMilitaryPop
	maxVillPop = kbGetBuildLimit(cMyID, gEconUnit);
	
	/*
		if(kbResourceGet(cResourceFood) > 5000 && kbResourceGet(cResourceGold) > 5000) maxVillPop = 98;
		if(kbResourceGet(cResourceFood) > 6000 && kbResourceGet(cResourceGold) > 6000) maxVillPop = 95;
		if(kbResourceGet(cResourceFood) > 7000 && kbResourceGet(cResourceGold) > 7000) maxVillPop = 92;
		if(kbResourceGet(cResourceFood) > 8000 && kbResourceGet(cResourceGold) > 8000) maxVillPop = 89;
		if(kbResourceGet(cResourceFood) > 9000 && kbResourceGet(cResourceGold) > 9000) maxVillPop = 86;
		if(kbResourceGet(cResourceFood) > 10000 && kbResourceGet(cResourceGold) > 10000) maxVillPop = 83;
		if(kbResourceGet(cResourceFood) > 11000 && kbResourceGet(cResourceGold) > 11000) maxVillPop = 80;
	*/
	float difficulty = aiGetWorldDifficulty();
	int intDifficulty = difficulty;
	int cvPopLimit = gMaxPopFixValue; // Used to calculate implied total pop limit based on civ, army and navy components.
	int maxMil = -1; // The full age-5 max military size...to be reduced in earlier ages to control runaway spending.
	if ((cvMaxCivPop >= 0) && (cvMaxArmyPop >= 0) && (cvMaxNavyPop >= 0)) // All three are defined, so set a hard total
	cvPopLimit = cvMaxCivPop + cvMaxArmyPop + cvMaxNavyPop;
	
	switch (intDifficulty)
	{ //sets the Economy and military caps per difficulty level
		case cDifficultySandbox: 
		{ // Sandbox
			gMaxPop = 50 + (30 * (difficulty - intDifficulty)); // Interpolate between integers
			if (gMaxPop > cvPopLimit) gMaxPop = cvPopLimit;
			aiSetEconomyPop(20);
			//if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0)) aiSetEconomyPop(cvMaxCivPop); //normally turned off
			maxMil = gMaxPop - aiGetEconomyPop(); //Get max military size
			setMilPopLimit(maxMil / 8, maxMil / 4, maxMil / 2, maxMil, maxMil); //cap military per age 
			break;
		} //end case
		case cDifficultyEasy: // Easiest
		{ //Easy
			gMaxPop = 80 + (50 * (difficulty - intDifficulty)); // 70 at easy up to 120 at moderate
			if (gMaxPop > cvPopLimit) gMaxPop = cvPopLimit;
			aiSetEconomyPop(35);
			if (gSPC == true)
			{ //for custom maps
				aiSetEconomyPop(25);
				gMaxPop = 60;
			} //end if
			//if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0)) aiSetEconomyPop(cvMaxCivPop); //normally turned off
			maxMil = gMaxPop - aiGetEconomyPop(); //Get max military size
			setMilPopLimit(0, 5, 50, maxMil, maxMil); //cap military per age 
			break;
		} //end case
		
		default: 
		{ // All other difficulty levels
			gMaxPop = gMaxPopFixValue; //set the max pop
			if (gMaxPop > cvPopLimit) gMaxPop = cvPopLimit; //normally turned off
			aiSetEconomyPop(maxVillPop); //The villiage train pop cap, use max
			//if ((aiGetEconomyPop() > cvMaxCivPop) && (cvMaxCivPop >= 0)) aiSetEconomyPop(cvMaxCivPop); //normally turned off
			maxMil = gMaxPop - aiGetEconomyPop(); //Get max military size
			//setMilPopLimit(0, 10, 70, maxMil, maxMil); //cap military per age 
			setMilPopLimit(0, 50, maxMil, maxMil, maxMil); //cap military per age 
			break;
		} //end default
	} //end switch
	
	
	
	if (kbResourceGet(cResourceFood) > 5000)
	{ //make max villiagers
		xsArraySetInt(gTargetSettlerCounts, cAge1, maxVillPop);
		xsArraySetInt(gTargetSettlerCounts, cAge2, maxVillPop);
		xsArraySetInt(gTargetSettlerCounts, cAge3, maxVillPop);
		xsArraySetInt(gTargetSettlerCounts, cAge4, maxVillPop);
		xsArraySetInt(gTargetSettlerCounts, cAge5, maxVillPop);
	}
	else
	{ //limit villiagers
		xsArraySetInt(gTargetSettlerCounts, cAge1, 16);
		xsArraySetInt(gTargetSettlerCounts, cAge2, 32);//32
		xsArraySetInt(gTargetSettlerCounts, cAge3, maxVillPop);
		xsArraySetInt(gTargetSettlerCounts, cAge4, maxVillPop);
		xsArraySetInt(gTargetSettlerCounts, cAge5, maxVillPop);
	}
	
	if(kbGetAge() > cAge2 && kbUnitCount(cMyID, gEconUnit, cUnitStateABQ) < xsArrayGetInt(gTargetSettlerCounts, kbGetAge()) )
	{
		aiTaskUnitTrain(getUnit(gTownCenter), gEconUnit);
	}
	
	//New feature added, If the ai is last in score when there are 4 or more alive players the AI will cap military inorder to catch up or work on eco
	//updatedOn 2019/07/18 By ageekhere    
	//---------------------------
	
	if (kbGetAge() != cAge5 && revolted == false)
	{ //do not cap if revolted or in age5
		capedPop = -1; //the current military cap
		int firstScore = 0; //The player with the highest score
		int playersLeft = 0; //How many players are left
		int behindAmount = 0; //How far behind a player is from the leader
		int lastScore = 0; //The lower score
		for (j = 1; < cNumberPlayers)
		{ //loop through all players
			if (kbHasPlayerLost(j) == false)
			{ //Only check the alive players
				playersLeft++; //Count how many players are left
				if (lastScore > aiGetScore(j) && cMyID != j)
				{ //check if there is a lower score
					lastScore = aiGetScore(j); //new lowest score
				} //end if
				if (aiGetScore(j) > firstScore && cMyID != j)
				{ //check if there is a higher score
					firstScore = aiGetScore(j); //New score leader
				} //end if
			} //end if
		} //end for	
		
		switch (kbGetAge())
		{ //set the amount between the leader and last place
			case cAge2:{behindAmount = 5000;}
			case cAge3:{behindAmount = 10000;}
			case cAge4:{behindAmount = 15000;}
		} //end switch
		
		if (playersLeft > 3 && kbGetAge() > cAge1 && aiGetScore(cMyID) < lastScore && (firstScore - aiGetScore(cMyID)) > behindAmount)
		{ //Check for 4 or more alive players and player is not in age 1 and has the lowest score and meets the behindAmount
			if (agingUp() == false)
			{ //Skip if aging up
				int capSize = gMaxPopFixValue; // army cap size
				switch (kbGetAge())
				{ //set the military cap for the ai
					case cAge2:
					{ //age 2
						capSize = 10;
					} //end case 
					case cAge3:
					{ //age 3
						capSize = 50;
					} //end case 
					//case cAge4:
					//{ //age 4
						//	capSize = 30;
						//	if (xsGetTime() > 2700000) capSize = 20; //45 minutes
					//} //end case 
				} //end switch
				
				capedPop = capSize; //set the pop cap
				aiSetMilitaryPop(capSize); //set the military pop cap
			} //end if
		} //end if
	} //end if
	
	//---------------------------
	if (revolted == true) capedPop = cvPopLimit; //aiSetMilitaryPop(300);//setMilPopLimit(300, 300, 300, 300, 300);	
	
	if (gDefenseReflexBaseID != kbBaseGetMainID(cMyID) && agingUp() == false)
	{
		if(kbGetAge() == cAge3 || kbGetAge() == cAge4)
		{
			int ageTime = -1;
			if(kbGetAge() == cAge3) ageTime = 1800000;
			if(kbGetAge() == cAge4) ageTime = 2400000;
			float currentTime = xsGetTime();
			
			float percentDrop = ageTime - currentTime;
			float capPercent = percentDrop / ageTime * 100;
			
			int setSize = gMaxPopFixValue * capPercent * 0.01;
			if(setSize < 20) setSize = 20;
			aiSetMilitaryPop(setSize);	
		}
	}
	gGoodArmyPop = aiGetMilitaryPop(); /// 3;
	
	if(cRandomMapName == "caribbean" && kbGetAge() < cAge3) 
	{
		aiSetMilitaryPop(10);
		gGoodArmyPop = 10;
		
	}
	
	
	
	
} //end popManager

//==============================================================================
/* initArrays()
	updatedOn 2019/07/20 By ageekhere 
	Initialize all global arrays here, to make it easy to find var type and size.
*/
//==============================================================================
void initArrays(void)
{ //Initialize arrays
	//if (debugMessage == true) aiChat(1, "Setting up initArrays"); aiEcho("Setting up initArrays");
	gForecasts = xsArrayCreateFloat(cNumResourceTypes, 0.0, "Forecasts");
	gMapNames = xsArrayCreateString(98, "", "Map names");
	xsArraySetString(gMapNames, 0, "amazonia");
	xsArraySetString(gMapNames, 1, "bayou");
	xsArraySetString(gMapNames, 2, "caribbean");
	xsArraySetString(gMapNames, 3, "carolina");
	xsArraySetString(gMapNames, 4, "greatlakes");
	xsArraySetString(gMapNames, 5, "greatplains");
	xsArraySetString(gMapNames, 6, "newengland");
	xsArraySetString(gMapNames, 7, "pampas");
	xsArraySetString(gMapNames, 8, "patagonia");
	xsArraySetString(gMapNames, 9, "rockies");
	xsArraySetString(gMapNames, 10, "saguenay");
	xsArraySetString(gMapNames, 11, "sonora");
	xsArraySetString(gMapNames, 12, "texas");
	xsArraySetString(gMapNames, 13, "yucatan");
	xsArraySetString(gMapNames, 14, "yukon");
	xsArraySetString(gMapNames, 15, "greatplainslarge");
	xsArraySetString(gMapNames, 16, "carolinalarge");
	xsArraySetString(gMapNames, 17, "saguenaylarge");
	xsArraySetString(gMapNames, 18, "sonoraLarge");
	xsArraySetString(gMapNames, 19, "texaslarge");
	xsArraySetString(gMapNames, 20, "hispaniola");
	xsArraySetString(gMapNames, 21, "andes");
	xsArraySetString(gMapNames, 22, "ozarks");
	xsArraySetString(gMapNames, 23, "araucania");
	xsArraySetString(gMapNames, 24, "california");
	xsArraySetString(gMapNames, 25, "grandcanyon");
	xsArraySetString(gMapNames, 26, "northwestterritory");
	xsArraySetString(gMapNames, 27, "painteddesert");
	xsArraySetString(gMapNames, 28, "unknown");
	xsArraySetString(gMapNames, 29, "borneo");
	xsArraySetString(gMapNames, 30, "ceylon");
	xsArraySetString(gMapNames, 31, "deccan");
	xsArraySetString(gMapNames, 32, "himalayas");
	xsArraySetString(gMapNames, 33, "Honshu");
	xsArraySetString(gMapNames, 34, "mongolia");
	xsArraySetString(gMapNames, 35, "silkroad");
	xsArraySetString(gMapNames, 36, "yellowriverdry");
	xsArraySetString(gMapNames, 37, "yellowriverlarge");
	xsArraySetString(gMapNames, 38, "deccanLarge");
	xsArraySetString(gMapNames, 39, "himalayasupper");
	xsArraySetString(gMapNames, 40, "regicidehonshu");
	xsArraySetString(gMapNames, 41, "indochina");
	xsArraySetString(gMapNames, 42, "plymouth");
	xsArraySetString(gMapNames, 43, "siberia");
	xsArraySetString(gMapNames, 44, "siberialarge");
	xsArraySetString(gMapNames, 45, "silkroadlarge");
	xsArraySetString(gMapNames, 46, "australia");
	xsArraySetString(gMapNames, 47, "korea");
	xsArraySetString(gMapNames, 48, "oasis");
	xsArraySetString(gMapNames, 49, "tigrisflood");
	xsArraySetString(gMapNames, 50, "volgadelta");
	xsArraySetString(gMapNames, 51, "ESOCadirondacks");
	xsArraySetString(gMapNames, 52, "ESOCalaska");
	xsArraySetString(gMapNames, 53, "ESOCarizona");
	xsArraySetString(gMapNames, 54, "ESOCarkansas");
	xsArraySetString(gMapNames, 55, "ESOCbajacalifornia");
	xsArraySetString(gMapNames, 56, "ESOCbengal");
	xsArraySetString(gMapNames, 57, "ESOCberingstrait");
	xsArraySetString(gMapNames, 58, "ESOCcascaderange");
	xsArraySetString(gMapNames, 59, "ESOCcerrado");
	xsArraySetString(gMapNames, 60, "ESOCdhaka");
	xsArraySetString(gMapNames, 61, "ESOCfertilecrescent");
	xsArraySetString(gMapNames, 62, "ESOCflorida");
	xsArraySetString(gMapNames, 63, "ESOCfraserriver");
	xsArraySetString(gMapNames, 64, "ESOCgranchaco");
	xsArraySetString(gMapNames, 65, "ESOCgreatbasin");
	xsArraySetString(gMapNames, 66, "ESOChighplains");
	xsArraySetString(gMapNames, 67, "ESOCindonesia");
	xsArraySetString(gMapNames, 68, "ESOCiowa");
	xsArraySetString(gMapNames, 69, "ESOCkamchatka");
	xsArraySetString(gMapNames, 70, "ESOCklondike");
	xsArraySetString(gMapNames, 71, "ESOCmalaysia");
	xsArraySetString(gMapNames, 72, "ESOCmanchuria");
	xsArraySetString(gMapNames, 73, "ESOCmendocino");
	xsArraySetString(gMapNames, 74, "ESOCmississippi");
	xsArraySetString(gMapNames, 75, "ESOCnahanni");
	xsArraySetString(gMapNames, 76, "ESOCnewmexico");
	xsArraySetString(gMapNames, 77, "ESOCpampassierras");
	xsArraySetString(gMapNames, 78, "ESOCparallelrivers");
	xsArraySetString(gMapNames, 79, "ESOCthailand");
	xsArraySetString(gMapNames, 80, "ESOCthardesert");
	xsArraySetString(gMapNames, 81, "ESOCtibet");
	xsArraySetString(gMapNames, 82, "ESOCtuparro");
	xsArraySetString(gMapNames, 83, "ESOCyaluriver");
	xsArraySetString(gMapNames, 84, "ESOCzagros");
	xsArraySetString(gMapNames, 85, "regicideandes");
	xsArraySetString(gMapNames, 86, "regicidedeccan");
	xsArraySetString(gMapNames, 87, "regicidegreatlakes");
	xsArraySetString(gMapNames, 88, "regicideindochina");
	xsArraySetString(gMapNames, 89, "regicidekorea");
	xsArraySetString(gMapNames, 90, "regicidepampas");
	xsArraySetString(gMapNames, 91, "regicidesiberia");
	xsArraySetString(gMapNames, 92, "regicideyellowriver");
	xsArraySetString(gMapNames, 93, "regicideESOCcerrado");
	
	gTargetSettlerCounts = xsArrayCreateInt(cAge5 + 1, 0, "Target Settler Counts");
	xsArraySetInt(gTargetSettlerCounts, cAge1, 25);
	xsArraySetInt(gTargetSettlerCounts, cAge2, 50);
	xsArraySetInt(gTargetSettlerCounts, cAge3, 75);
	xsArraySetInt(gTargetSettlerCounts, cAge4, 90);
	xsArraySetInt(gTargetSettlerCounts, cAge5, 100);
	
	if (aiGetGameMode() == cGameModeDeathmatch)
	{ //BHG: JFR: if we are in deatmatch we dont want to research the consulate tech that takes us to age 5
		gConsulateTechsSize = 32;
	} //end if
	else
	{
		gConsulateTechsSize = 33;
	} //end else BHG: JFR:
	
	gConsulateTechs = xsArrayCreateInt(40, 0, "Consulate Tech IDs");
	xsArraySetInt(gConsulateTechs, 0, cTechypConsulateBritishBrigade);
	xsArraySetInt(gConsulateTechs, 1, cTechypConsulateBritishLifeGuards);
	xsArraySetInt(gConsulateTechs, 2, cTechypConsulateBritishRedcoats);
	xsArraySetInt(gConsulateTechs, 3, cTechypConsulateBritishRogersRangers);
	xsArraySetInt(gConsulateTechs, 4, cTechypConsulateDutchBrigade);
	xsArraySetInt(gConsulateTechs, 5, cTechypConsulateFrenchBrigade);
	xsArraySetInt(gConsulateTechs, 6, cTechypConsulateFrenchCoinCrates);
	xsArraySetInt(gConsulateTechs, 7, cTechypConsulateFrenchFoodCrates);
	xsArraySetInt(gConsulateTechs, 8, cTechypConsulateFrenchHotAirBalloonsPreq);
	xsArraySetInt(gConsulateTechs, 9, cTechypConsulateFrenchWoodCrates);
	xsArraySetInt(gConsulateTechs, 10, cTechypConsulateGermansBrigade);
	xsArraySetInt(gConsulateTechs, 11, cTechypConsulateGermansCoinTrickle);
	xsArraySetInt(gConsulateTechs, 12, cTechypConsulateGermansFoodTrickle);
	xsArraySetInt(gConsulateTechs, 13, cTechypConsulateGermansWoodTrickle);
	xsArraySetInt(gConsulateTechs, 14, cTechypConsulateJapaneseKoujou);
	xsArraySetInt(gConsulateTechs, 15, cTechypConsulateJapaneseMilitaryRickshaw);
	xsArraySetInt(gConsulateTechs, 16, cTechypConsulateJapaneseMasterTraining);
	xsArraySetInt(gConsulateTechs, 17, cTechypConsulateOttomansBrigade);
	xsArraySetInt(gConsulateTechs, 18, cTechypConsulateOttomansGunpowderSiege);
	xsArraySetInt(gConsulateTechs, 19, cTechypConsulateOttomansInfantrySpeed);
	xsArraySetInt(gConsulateTechs, 20, cTechypConsulateOttomansSettlerCombat);
	xsArraySetInt(gConsulateTechs, 21, cTechypConsulatePortugueseBrigade);
	xsArraySetInt(gConsulateTechs, 22, cTechypConsulatePortugueseExpeditionaryFleet);
	xsArraySetInt(gConsulateTechs, 23, cTechypConsulatePortugueseExplorationFleet);
	xsArraySetInt(gConsulateTechs, 24, cTechypConsulatePortugueseFishingFleet);
	xsArraySetInt(gConsulateTechs, 25, cTechypConsulateRussianBrigade);
	xsArraySetInt(gConsulateTechs, 26, cTechypConsulateRussianFactoryWagon);
	xsArraySetInt(gConsulateTechs, 27, cTechypConsulateRussianFortWagon);
	xsArraySetInt(gConsulateTechs, 28, cTechypConsulateSpanishBrigade);
	xsArraySetInt(gConsulateTechs, 29, cTechypConsulateSpanishEnhancedProfits);
	xsArraySetInt(gConsulateTechs, 30, cTechypConsulateSpanishFasterShipments);
	xsArraySetInt(gConsulateTechs, 31, cTechypConsulateSpanishMercantilism);
	
	if (aiGetGameMode() != cGameModeDeathmatch)
	{ //BHG: JFR: if we are in deatmatch we dont want to research the consulate tech that takes us to age 5...
		xsArraySetInt(gConsulateTechs, 32, cTechypConsulateJapaneseMeijiRestoration);
	} //end //...BHG: JFR:
	
	gAsianWonders = xsArrayCreateInt(5, 0, "Wonder Age IDs");
	int wonderchoice = aiRandInt(4); //wonder is decided by random, could be changed using logic
	
	if ((cMyCiv == cCivJapanese) || (cMyCiv == cCivSPCJapanese) || (cMyCiv == cCivSPCJapaneseEnemy))
	{ //Giant Buddha, Golden Pavillion, Shogunate, Torii Gates, Toshogu Shrine 
		if (wonderchoice == 0)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJGiantBuddha2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGoldenPavillion3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJShogunate4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJToshoguShrine5);
		}
		else if (wonderchoice == 1)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJGoldenPavillion2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJGiantBuddha3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJToshoguShrine4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJShogunate5);
		}
		else if (wonderchoice == 2)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJShogunate2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJToriiGates3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGiantBuddha4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJGoldenPavillion5);
		}
		else
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWJToriiGates2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWJToshoguShrine3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWJGoldenPavillion4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWJShogunate5);
		}
	} //end if
	if ((cMyCiv == cCivChinese) || (cMyCiv == cCivSPCChinese))
	{ //Confucian Academy, Porcelain Tower, Summer Palace, Temple of Heaven, White Pagoda
		if (wonderchoice == 0)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCConfucianAcademy2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCPorcelainTower3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCSummerPalace4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCTempleOfHeaven5);
		}
		else if (wonderchoice == 1)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCWhitePagoda2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCConfucianAcademy3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCSummerPalace4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCPorcelainTower5);
		}
		else if (wonderchoice == 2)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCSummerPalace2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCWhitePagoda3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCTempleOfHeaven4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCConfucianAcademy5);
		}
		else
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWCTempleOfHeaven2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWCWhitePagoda3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWCSummerPalace4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWCConfucianAcademy5);
		}
	} //end if
	if ((cMyCiv == cCivIndians) || (cMyCiv == cCivSPCIndians))
	{ //Agra Fort, Charminar Gate, Karni Mata, Taj Mahal, Tower of Victory
		if (wonderchoice == 0)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWIAgraFort2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWICharminarGate3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWIKarniMata4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITajMahal5);
		}
		else if (wonderchoice == 1)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWITowerOfVictory2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIAgraFort3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWICharminarGate4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWIKarniMata5);
		}
		else if (wonderchoice == 2)
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWICharminarGate2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWITajMahal3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWIAgraFort4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWITowerOfVictory5);
		}
		else
		{
			xsArraySetInt(gAsianWonders, 0, cUnitTypeypWITajMahal2);
			xsArraySetInt(gAsianWonders, 1, cUnitTypeypWIKarniMata3);
			xsArraySetInt(gAsianWonders, 2, cUnitTypeypWITowerOfVictory4);
			xsArraySetInt(gAsianWonders, 3, cUnitTypeypWICharminarGate5);
		}
	} //end if
	
	gAge2PoliticianList = xsArrayCreateInt(7, 0, "Age 2 Politician List");		
	xsArraySetInt(gAge2PoliticianList, 0, cTechPoliticianGovernor);
	xsArraySetInt(gAge2PoliticianList, 1, cTechPoliticianQuartermaster);
	xsArraySetInt(gAge2PoliticianList, 2, cTechPoliticianNaturalist);
	xsArraySetInt(gAge2PoliticianList, 3, cTechPoliticianBishop);
	xsArraySetInt(gAge2PoliticianList, 4, cTechPoliticianPhilosopherPrince);
	xsArraySetInt(gAge2PoliticianList, 5, cTechPoliticianDiplomat);
	xsArraySetInt(gAge2PoliticianList, 6, cTechPoliticianArtist);
	
	
	/*xsArraySetInt(gAge2PoliticianList, 0, cTechPoliticianGovernor);
		xsArraySetInt(gAge2PoliticianList, 1, cTechPoliticianQuartermaster);
		xsArraySetInt(gAge2PoliticianList, 2, cTechPoliticianNaturalist);
		xsArraySetInt(gAge2PoliticianList, 3, cTechPoliticianBishop);
		xsArraySetInt(gAge2PoliticianList, 4, cTechPoliticianPhilosopherPrince);
		xsArraySetInt(gAge2PoliticianList, 5, cTechPoliticianBishopGerman);
	*/
	
	gAge3PoliticianList = xsArrayCreateInt(8, 0, "Age 3 Politician List");
	
	xsArraySetInt(gAge3PoliticianList, 0, cTechPoliticianSergeant);
	xsArraySetInt(gAge3PoliticianList, 1, cTechPoliticianMohawk);
	xsArraySetInt(gAge3PoliticianList, 2, cTechPoliticianPirate);
	xsArraySetInt(gAge3PoliticianList, 3, cTechPoliticianAdventurer);
	xsArraySetInt(gAge3PoliticianList, 4, cTechPoliticianExiledPrince);
	xsArraySetInt(gAge3PoliticianList, 5, cTechPoliticianMarksman);
	xsArraySetInt(gAge3PoliticianList, 6, cTechPoliticianScout);
	xsArraySetInt(gAge3PoliticianList, 7, cTechPoliticianAdmiral);
	/*
		xsArraySetInt(gAge3PoliticianList, 0, cTechPoliticianSergeantSpanish);
		xsArraySetInt(gAge3PoliticianList, 1, cTechPoliticianMohawk);
		xsArraySetInt(gAge3PoliticianList, 2, cTechPoliticianPirate);
		xsArraySetInt(gAge3PoliticianList, 3, cTechPoliticianAdventurerSpanish);
		xsArraySetInt(gAge3PoliticianList, 4, cTechPoliticianAdmiral);
		xsArraySetInt(gAge3PoliticianList, 5, cTechPoliticianExiledPrince);
		xsArraySetInt(gAge3PoliticianList, 6, cTechPoliticianMarksman);
		xsArraySetInt(gAge3PoliticianList, 7, cTechPoliticianAdmiralOttoman);
		xsArraySetInt(gAge3PoliticianList, 8, cTechPoliticianAdventurerBritish);
		xsArraySetInt(gAge3PoliticianList, 9, cTechPoliticianScout);
		xsArraySetInt(gAge3PoliticianList, 10, cTechPoliticianScoutRussian);
		xsArraySetInt(gAge3PoliticianList, 11, cTechPoliticianAdventurerRussian);
		xsArraySetInt(gAge3PoliticianList, 12, cTechPoliticianSergeantGerman);
		xsArraySetInt(gAge3PoliticianList, 13, cTechPoliticianMarksmanPortuguese);
		xsArraySetInt(gAge3PoliticianList, 14, cTechPoliticianMarksmanOttoman);
		xsArraySetInt(gAge3PoliticianList, 15, cTechPoliticianSergeantDutch);
	*/
	
	gAge4PoliticianList = xsArrayCreateInt(7, 0, "Age 4 Politician List");		
	xsArraySetInt(gAge4PoliticianList, 0, cTechPoliticianEngineer);
	xsArraySetInt(gAge4PoliticianList, 1, cTechPoliticianTycoon);
	xsArraySetInt(gAge4PoliticianList, 2, cTechPoliticianMusketeer);
	xsArraySetInt(gAge4PoliticianList, 3, cTechPoliticianCavalier);
	xsArraySetInt(gAge4PoliticianList, 4, cTechPoliticianGrandVizier);
	xsArraySetInt(gAge4PoliticianList, 5, cTechPoliticianViceroy);
	xsArraySetInt(gAge4PoliticianList, 6, cTechPoliticianMercenary);
	
	/*
		xsArraySetInt(gAge4PoliticianList, 0, cTechPoliticianEngineer);
		xsArraySetInt(gAge4PoliticianList, 1, cTechPoliticianTycoon);
		xsArraySetInt(gAge4PoliticianList, 2, cTechPoliticianMusketeerSpanish);
		xsArraySetInt(gAge4PoliticianList, 3, cTechPoliticianCavalierSpanish);
		xsArraySetInt(gAge4PoliticianList, 4, cTechPoliticianGrandVizier);
		xsArraySetInt(gAge4PoliticianList, 5, cTechPoliticianWarMinisterSpanish);
		xsArraySetInt(gAge4PoliticianList, 6, cTechPoliticianViceroyBritish);
		xsArraySetInt(gAge4PoliticianList, 7, cTechPoliticianMusketeerBritish);
		xsArraySetInt(gAge4PoliticianList, 8, cTechPoliticianCavalierFrench);
		xsArraySetInt(gAge4PoliticianList, 9, cTechPoliticianMusketeerFrench);
		xsArraySetInt(gAge4PoliticianList, 10, cTechPoliticianWarMinisterRussian);
		xsArraySetInt(gAge4PoliticianList, 11, cTechPoliticianCavalierRussian);
		xsArraySetInt(gAge4PoliticianList, 12, cTechPoliticianMusketeerRussian);
		xsArraySetInt(gAge4PoliticianList, 13, cTechPoliticianCavalierGerman);
		xsArraySetInt(gAge4PoliticianList, 14, cTechPoliticianViceroyGerman);
		xsArraySetInt(gAge4PoliticianList, 15, cTechPoliticianEngineerPortuguese);
		xsArraySetInt(gAge4PoliticianList, 16, cTechPoliticianViceroyPortuguese);
		xsArraySetInt(gAge4PoliticianList, 17, cTechPoliticianMusketeerPortuguese);
		xsArraySetInt(gAge4PoliticianList, 18, cTechPoliticianCavalierDutch);
		xsArraySetInt(gAge4PoliticianList, 19, cTechPoliticianCavalierOttoman);
		xsArraySetInt(gAge4PoliticianList, 20, cTechPoliticianMusketeerDutch);
		xsArraySetInt(gAge4PoliticianList, 21, cTechPoliticianViceroyDutch);
		xsArraySetInt(gAge4PoliticianList, 22, cTechPoliticianTycoonAct3);
		xsArraySetInt(gAge4PoliticianList, 23, cTechPoliticianWarMinisterAct3);
	*/
	
	gAge5PoliticianList = xsArrayCreateInt(4, 0, "Age 5 Politician List");
	xsArraySetInt(gAge5PoliticianList, 0, cTechPoliticianPresidente);
	xsArraySetInt(gAge5PoliticianList, 1, cTechPoliticianPresidenteEU);
	xsArraySetInt(gAge5PoliticianList, 2, cTechPoliticianGeneral);
	xsArraySetInt(gAge5PoliticianList, 3, cTechPoliticianGeneralUSA);			
	/*
		xsArraySetInt(gAge5PoliticianList, 0, cTechPoliticianPresidente);
		xsArraySetInt(gAge5PoliticianList, 1, cTechPoliticianGeneral);
		xsArraySetInt(gAge5PoliticianList, 2, cTechPoliticianPresidenteEU);
		xsArraySetInt(gAge5PoliticianList, 3, cTechPoliticianGeneralUSA);
		xsArraySetInt(gAge5PoliticianList, 4, cTechPoliticianGeneralBritish);
		xsArraySetInt(gAge5PoliticianList, 5, cTechPoliticianGeneralOttoman);
		xsArraySetInt(gAge5PoliticianList, 6, cTechPoliticianGeneralSkirmisher);
	*/
	
	
	
	gAge2WonderList = xsArrayCreateInt(15, 0, "Age 2 Wonder List");
	xsArraySetInt(gAge2WonderList, 0, cUnitTypeypWCConfucianAcademy2);
	xsArraySetInt(gAge2WonderList, 1, cUnitTypeypWCPorcelainTower2);
	xsArraySetInt(gAge2WonderList, 2, cUnitTypeypWCSummerPalace2);
	xsArraySetInt(gAge2WonderList, 3, cUnitTypeypWCTempleOfHeaven2);
	xsArraySetInt(gAge2WonderList, 4, cUnitTypeypWCWhitePagoda2);
	xsArraySetInt(gAge2WonderList, 5, cUnitTypeypWIAgraFort2);
	xsArraySetInt(gAge2WonderList, 6, cUnitTypeypWICharminarGate2);
	xsArraySetInt(gAge2WonderList, 7, cUnitTypeypWIKarniMata2);
	xsArraySetInt(gAge2WonderList, 8, cUnitTypeypWITajMahal2);
	xsArraySetInt(gAge2WonderList, 9, cUnitTypeypWITowerOfVictory2);
	xsArraySetInt(gAge2WonderList, 10, cUnitTypeypWJGiantBuddha2);
	xsArraySetInt(gAge2WonderList, 11, cUnitTypeypWJGoldenPavillion2);
	xsArraySetInt(gAge2WonderList, 12, cUnitTypeypWJShogunate2);
	xsArraySetInt(gAge2WonderList, 13, cUnitTypeypWJToriiGates2);
	xsArraySetInt(gAge2WonderList, 14, cUnitTypeypWJToshoguShrine2);
	
	gAge3WonderList = xsArrayCreateInt(15, 0, "Age 3 Wonder List");
	xsArraySetInt(gAge3WonderList, 0, cUnitTypeypWCConfucianAcademy3);
	xsArraySetInt(gAge3WonderList, 1, cUnitTypeypWCPorcelainTower3);
	xsArraySetInt(gAge3WonderList, 2, cUnitTypeypWCSummerPalace3);
	xsArraySetInt(gAge3WonderList, 3, cUnitTypeypWCTempleOfHeaven3);
	xsArraySetInt(gAge3WonderList, 4, cUnitTypeypWCWhitePagoda3);
	xsArraySetInt(gAge3WonderList, 5, cUnitTypeypWIAgraFort3);
	xsArraySetInt(gAge3WonderList, 6, cUnitTypeypWICharminarGate3);
	xsArraySetInt(gAge3WonderList, 7, cUnitTypeypWIKarniMata3);
	xsArraySetInt(gAge3WonderList, 8, cUnitTypeypWITajMahal3);
	xsArraySetInt(gAge3WonderList, 9, cUnitTypeypWITowerOfVictory3);
	xsArraySetInt(gAge3WonderList, 10, cUnitTypeypWJGiantBuddha3);
	xsArraySetInt(gAge3WonderList, 11, cUnitTypeypWJGoldenPavillion3);
	xsArraySetInt(gAge3WonderList, 12, cUnitTypeypWJShogunate3);
	xsArraySetInt(gAge3WonderList, 13, cUnitTypeypWJToriiGates3);
	xsArraySetInt(gAge3WonderList, 14, cUnitTypeypWJToshoguShrine3);
	
	gAge4WonderList = xsArrayCreateInt(15, 0, "Age 4 Wonder List");
	xsArraySetInt(gAge4WonderList, 0, cUnitTypeypWCConfucianAcademy4);
	xsArraySetInt(gAge4WonderList, 1, cUnitTypeypWCPorcelainTower4);
	xsArraySetInt(gAge4WonderList, 2, cUnitTypeypWCSummerPalace4);
	xsArraySetInt(gAge4WonderList, 3, cUnitTypeypWCTempleOfHeaven4);
	xsArraySetInt(gAge4WonderList, 4, cUnitTypeypWCWhitePagoda4);
	xsArraySetInt(gAge4WonderList, 5, cUnitTypeypWIAgraFort4);
	xsArraySetInt(gAge4WonderList, 6, cUnitTypeypWICharminarGate4);
	xsArraySetInt(gAge4WonderList, 7, cUnitTypeypWIKarniMata4);
	xsArraySetInt(gAge4WonderList, 8, cUnitTypeypWITajMahal4);
	xsArraySetInt(gAge4WonderList, 9, cUnitTypeypWITowerOfVictory4);
	xsArraySetInt(gAge4WonderList, 10, cUnitTypeypWJGiantBuddha4);
	xsArraySetInt(gAge4WonderList, 11, cUnitTypeypWJGoldenPavillion4);
	xsArraySetInt(gAge4WonderList, 12, cUnitTypeypWJShogunate4);
	xsArraySetInt(gAge4WonderList, 13, cUnitTypeypWJToriiGates4);
	xsArraySetInt(gAge4WonderList, 14, cUnitTypeypWJToshoguShrine4);
	
	gAge5WonderList = xsArrayCreateInt(15, 0, "Age 5 Wonder List");
	xsArraySetInt(gAge5WonderList, 0, cUnitTypeypWCConfucianAcademy5);
	xsArraySetInt(gAge5WonderList, 1, cUnitTypeypWCPorcelainTower5);
	xsArraySetInt(gAge5WonderList, 2, cUnitTypeypWCSummerPalace5);
	xsArraySetInt(gAge5WonderList, 3, cUnitTypeypWCTempleOfHeaven5);
	xsArraySetInt(gAge5WonderList, 4, cUnitTypeypWCWhitePagoda5);
	xsArraySetInt(gAge5WonderList, 5, cUnitTypeypWIAgraFort5);
	xsArraySetInt(gAge5WonderList, 6, cUnitTypeypWICharminarGate5);
	xsArraySetInt(gAge5WonderList, 7, cUnitTypeypWIKarniMata5);
	xsArraySetInt(gAge5WonderList, 8, cUnitTypeypWITajMahal5);
	xsArraySetInt(gAge5WonderList, 9, cUnitTypeypWITowerOfVictory5);
	xsArraySetInt(gAge5WonderList, 10, cUnitTypeypWJGiantBuddha5);
	xsArraySetInt(gAge5WonderList, 11, cUnitTypeypWJGoldenPavillion5);
	xsArraySetInt(gAge5WonderList, 12, cUnitTypeypWJShogunate5);
	xsArraySetInt(gAge5WonderList, 13, cUnitTypeypWJToriiGates5);
	xsArraySetInt(gAge5WonderList, 14, cUnitTypeypWJToshoguShrine5);
	
	gAge2WonderTechList = xsArrayCreateInt(15, 0, "Age 2 WonderTech List");
	xsArraySetInt(gAge2WonderTechList, 0, cTechYPWonderChineseConfucianAcademy2);
	xsArraySetInt(gAge2WonderTechList, 1, cTechYPWonderChinesePorcelainTower2);
	xsArraySetInt(gAge2WonderTechList, 2, cTechYPWonderChineseSummerPalace2);
	xsArraySetInt(gAge2WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven2);
	xsArraySetInt(gAge2WonderTechList, 4, cTechYPWonderChineseWhitePagoda2);
	xsArraySetInt(gAge2WonderTechList, 5, cTechYPWonderIndianAgra2);
	xsArraySetInt(gAge2WonderTechList, 6, cTechYPWonderIndianCharminar2);
	xsArraySetInt(gAge2WonderTechList, 7, cTechYPWonderIndianKarniMata2);
	xsArraySetInt(gAge2WonderTechList, 8, cTechYPWonderIndianTajMahal2);
	xsArraySetInt(gAge2WonderTechList, 9, cTechYPWonderIndianTowerOfVictory2);
	xsArraySetInt(gAge2WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha2);
	xsArraySetInt(gAge2WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion2);
	xsArraySetInt(gAge2WonderTechList, 12, cTechYPWonderJapaneseShogunate2);
	xsArraySetInt(gAge2WonderTechList, 13, cTechYPWonderJapaneseToriiGates2);
	xsArraySetInt(gAge2WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine2);
	
	gAge3WonderTechList = xsArrayCreateInt(15, 0, "Age 3 WonderTech List");
	xsArraySetInt(gAge3WonderTechList, 0, cTechYPWonderChineseConfucianAcademy3);
	xsArraySetInt(gAge3WonderTechList, 1, cTechYPWonderChinesePorcelainTower3);
	xsArraySetInt(gAge3WonderTechList, 2, cTechYPWonderChineseSummerPalace3);
	xsArraySetInt(gAge3WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven3);
	xsArraySetInt(gAge3WonderTechList, 4, cTechYPWonderChineseWhitePagoda3);
	xsArraySetInt(gAge3WonderTechList, 5, cTechYPWonderIndianAgra3);
	xsArraySetInt(gAge3WonderTechList, 6, cTechYPWonderIndianCharminar3);
	xsArraySetInt(gAge3WonderTechList, 7, cTechYPWonderIndianKarniMata3);
	xsArraySetInt(gAge3WonderTechList, 8, cTechYPWonderIndianTajMahal3);
	xsArraySetInt(gAge3WonderTechList, 9, cTechYPWonderIndianTowerOfVictory3);
	xsArraySetInt(gAge3WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha3);
	xsArraySetInt(gAge3WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion3);
	xsArraySetInt(gAge3WonderTechList, 12, cTechYPWonderJapaneseShogunate3);
	xsArraySetInt(gAge3WonderTechList, 13, cTechYPWonderJapaneseToriiGates3);
	xsArraySetInt(gAge3WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine3);
	
	gAge4WonderTechList = xsArrayCreateInt(15, 0, "Age 4 WonderTech List");
	xsArraySetInt(gAge4WonderTechList, 0, cTechYPWonderChineseConfucianAcademy4);
	xsArraySetInt(gAge4WonderTechList, 1, cTechYPWonderChinesePorcelainTower4);
	xsArraySetInt(gAge4WonderTechList, 2, cTechYPWonderChineseSummerPalace4);
	xsArraySetInt(gAge4WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven4);
	xsArraySetInt(gAge4WonderTechList, 4, cTechYPWonderChineseWhitePagoda4);
	xsArraySetInt(gAge4WonderTechList, 5, cTechYPWonderIndianAgra4);
	xsArraySetInt(gAge4WonderTechList, 6, cTechYPWonderIndianCharminar4);
	xsArraySetInt(gAge4WonderTechList, 7, cTechYPWonderIndianKarniMata4);
	xsArraySetInt(gAge4WonderTechList, 8, cTechYPWonderIndianTajMahal4);
	xsArraySetInt(gAge4WonderTechList, 9, cTechYPWonderIndianTowerOfVictory4);
	xsArraySetInt(gAge4WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha4);
	xsArraySetInt(gAge4WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion4);
	xsArraySetInt(gAge4WonderTechList, 12, cTechYPWonderJapaneseShogunate4);
	xsArraySetInt(gAge4WonderTechList, 13, cTechYPWonderJapaneseToriiGates4);
	xsArraySetInt(gAge4WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine4);
	
	gAge5WonderTechList = xsArrayCreateInt(15, 0, "Age 5 WonderTech List");
	xsArraySetInt(gAge5WonderTechList, 0, cTechYPWonderChineseConfucianAcademy5);
	xsArraySetInt(gAge5WonderTechList, 1, cTechYPWonderChinesePorcelainTower5);
	xsArraySetInt(gAge5WonderTechList, 2, cTechYPWonderChineseSummerPalace5);
	xsArraySetInt(gAge5WonderTechList, 3, cTechYPWonderChineseTempleOfHeaven5);
	xsArraySetInt(gAge5WonderTechList, 4, cTechYPWonderChineseWhitePagoda5);
	xsArraySetInt(gAge5WonderTechList, 5, cTechYPWonderIndianAgra5);
	xsArraySetInt(gAge5WonderTechList, 6, cTechYPWonderIndianCharminar5);
	xsArraySetInt(gAge5WonderTechList, 7, cTechYPWonderIndianKarniMata5);
	xsArraySetInt(gAge5WonderTechList, 8, cTechYPWonderIndianTajMahal5);
	xsArraySetInt(gAge5WonderTechList, 9, cTechYPWonderIndianTowerOfVictory5);
	xsArraySetInt(gAge5WonderTechList, 10, cTechYPWonderJapaneseGiantBuddha5);
	xsArraySetInt(gAge5WonderTechList, 11, cTechYPWonderJapaneseGoldenPavillion5);
	xsArraySetInt(gAge5WonderTechList, 12, cTechYPWonderJapaneseShogunate5);
	xsArraySetInt(gAge5WonderTechList, 13, cTechYPWonderJapaneseToriiGates5);
	xsArraySetInt(gAge5WonderTechList, 14, cTechYPWonderJapaneseToshoguShrine5);
	
	gAgeUpPoliticians = xsArrayCreateInt(6, 0, "Ageup Politicians");
	gPoliticianScores = xsArrayCreateInt(6, 0, "European Politicians");
	gNatCouncilScores = xsArrayCreateInt(6, 0, "Native Council");
	gAsianWonderScores = xsArrayCreateInt(6, 0, "Asian Wonders");
	
	excludeLivestockArray = xsArrayCreateInt(100, -1, "excludeLivestock");
	excludeBuildingArray = xsArrayCreateInt(100, -1, "excludeBuilding");
	
	excludeSettlersArray = xsArrayCreateInt(51, -1, "excludeSettlers");
	huntSettlersArray = xsArrayCreateInt(100, -1, "huntSettlersArray");
	
	shorelineArray = xsArrayCreateVector(2000, cInvalidVector,"shorelineTargets");
	wallAreaArray = xsArrayCreateVector(2000, cInvalidVector,"wallAreaArray");
	transportShipsArray = xsArrayCreateInt(50, -1,"transportShips");
	shorelineEnemyBuildingsArray = xsArrayCreateInt(1000, -1,"shorelineEnemyBuildings");
	
	//garrisonArray = xsArrayCreateInt(110, -1, "garrisonArray");
} //end initArrays

//==============================================================================
// main
// updatedOn 2019/08/20 By ageekhere
//==============================================================================
void main(void)
{
	bool sentVersion = false;
	for (t = 1; < cNumberPlayers)
	{
		if (kbIsPlayerHuman(t) == false)
		{
			sentVersion = true;		
			if(t == cMyID)
			{
				if(aiGetWorldDifficulty() == cDifficultySandbox) echoMessage("The Improved AI version " + versionNumber + " - Time for some sleep"); 
				if(aiGetWorldDifficulty() == cDifficultyEasy)echoMessage("The Improved AI version " + versionNumber + " - I Guess I will go easy on you (Handicap 0.5)");
				if(aiGetWorldDifficulty() == cDifficultyModerate)echoMessage("The Improved AI version " + versionNumber + " - So we play on an even playing field, Good Luck"); 
				if(aiGetWorldDifficulty() == cDifficultyHard)echoMessage("The Improved AI version " + versionNumber + " - Ah finally a worthy opponent, Good Luck (Handicap 1.3 + AI EarlyCheats)"); 
				if(aiGetWorldDifficulty() == cDifficultyExpert)echoMessage("The Improved AI version " + versionNumber + " - Now you're in for it! (Handicap 1.5 + AI EarlyCheats and AI LateCheats)");
			}
			break;
		}
	}
	
	initArrays(); // Create the global arrays
	aiRandSetSeed(-1); // Set our random seed.  "-1" is a random init
	kbAreaCalculate(); // Analyze the map, create area matrix
	aiPopulatePoliticianList(); // Fill out the PoliticanLists.
	if( (aiGetGameType() == cGameTypeCampaign) || (aiGetGameType() == cGameTypeScenario) ) gSPC = true; //Checks if game type is Campaign or Scenario,default is false
	
	//-- setup the handicaps.
	// baseLineHandicap is a global multiplier that we can use to adjust all up or down. AdaptiveDifficulty changes this.
	// startingHandicap is the handicap set at game launch in the UI, i.e. boost this player 10% == 1.10.  That needs to be
	// multiplied by the appropriate difficulty for each level.
	float startingHandicap = kbGetPlayerHandicap(cMyID); //get Handicap for player
	float sandboxHandicap = 0.2;
	float easyHandicap = 0.5;
	float moderateHandicap = 1.0;
	float hardHandicap = 1.3;
	float expertHandicap = 1.5;
	
	switch (aiGetWorldDifficulty())
	{ //set Difficulty properties 
		case cDifficultySandbox: // Sandbox
		{ //Sandbox mode
			kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * sandboxHandicap); //Set handicap to a small fraction of baseline, i.e. minus %.
			gDelayAttacks = true; // Prevent attacks...actually stays that way, never turns true.
			cvOkToBuildForts = false; //Do not build forts
			break;
		} //end case
		case cDifficultyEasy: // Easiest
		{ //Easy mode
			kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * easyHandicap); // minus %
			gDelayAttacks = true;
			cvOkToBuildForts = false;
			xsEnableRule("delayAttackMonitor"); // Wait until I am attacked, then let slip the hounds of war.
			break;
		} //end case
		case cDifficultyModerate:
		{ //Moderate mode
			kbSetPlayerHandicap(cMyID, moderateHandicap); //No cheat level
			break;
		} //end case
		case cDifficultyHard:
		{ //Hard mode
			kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * hardHandicap); // % bonus
			break;
		} //end case
		case cDifficultyExpert:
		{ //Expert mode
			kbSetPlayerHandicap(cMyID, startingHandicap * baselineHandicap * expertHandicap); // % boost.
			break;
		} //end case
	} //end switch
	
	if(getUnit(cUnitTypeHomeCityWaterSpawnFlag) > 0)
	{ //check if the ai has a water flag
		aiSetWaterMap(true);
		gWaterMap = true;
	} //end if
	
	initPersonality(); //Find out what our personality is, init variables from it.
	preInit(); //Allow loader file to change default values before we start.
	if (cvInactiveAI == true)
	{ //using inactive ai
		cvOkToSelectMissions = false;
		cvOkToTrainArmy = false;
		cvOkToAllyNatives = false;
		cvOkToClaimTrade = false;
		cvOkToGatherFood = false;
		cvOkToGatherGold = false;
		cvOkToGatherWood = false;
		cvOkToExplore = false;
		cvOkToResign = false;
		cvOkToAttack = false;
	} //end if
	
	if (gSPC == true)
	{ // Figure out the starting conditions, and deal with them.
		cvOkToTaunt = false; //Taunt defaults to true, but needs to be false in scenario games.
		// Wait for the aiStart unit to appear, then figure out what to do.
		// That rule will have to set the start mode to ScenarioTC or ScenarioNoTC.
		xsEnableRule("waitForStartup");
	} //end if
	else
	{ //RM or GC game
		aiSetRandomMap(true); //set to use random map
		if (kbUnitCount(cMyID, gTownCenter, cUnitStateAlive) > 0)
		{ //Check for a TC.
			gStartMode = cStartModeLandTC; // TC start
			init(); // Call init directly.
			maxVillPop = kbGetBuildLimit(cMyID, gEconUnit);
			popManager(); //Call the rule once as a function, to get all the pop limits set up.  
		} //end if
		else
		{ // Check for a Boat.
			if (kbUnitCount(cMyID, cUnitTypeAbstractWarShip, cUnitStateAlive) > 0)
			{
				gStartMode = cStartModeBoat;
				aiSetHandler("transportArrive", cXSHomeCityTransportArriveHandler); // Needed for first transport unloading 
				// Rule that fires after 30 seconds in case
				// something goes wrong with unloading
				xsEnableRule("transportArriveFailsafe");
			} //end if
			else
			{ // This must be a land nomad start
				gStartMode = cStartModeLandWagon;
				transportArrive(); // Call the function that sets up explore plans, etc.
			} //end else
		} //end else
	} //end else
	if (aiGetWorldDifficulty() > cDifficultyModerate) kbLookAtAllUnitsOnMap();
	xsEnableRule("autoSave");
	autoSave(); //Trigger first autosave immediately
	
	
	if(kbIsNomad() == true) 
	{
		int startingSettkerWagon = getUnit(cUnitTypeAbstractWagon, cMyID);
		aiTaskUnitBuild( startingSettkerWagon, gTownCenter, kbUnitGetPosition(startingSettkerWagon) );
	}
	
	/*
	if(cMyCiv == cCivOttomans )
	{
		outOfOpening = false;
		openingType = 0;
		
	}
	*/
	gathererTasking();
	//backOfbase();
} //end main

void targetAttack(int targetPlayer=-1, int targetType=-1, int attackType=-1)
{
	
	int enemyTarget = kbUnitQueryCreate("enemyTarget");
	kbUnitQuerySetPlayerID(enemyTarget, targetPlayer);
	kbUnitQuerySetUnitType(enemyTarget, targetType);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyTarget, true);
	kbUnitQuerySetState(enemyTarget, cUnitStateAlive);
	int currentTarget = -1;
	
	for (i = 0; < kbUnitQueryExecute(enemyTarget))
	{
		currentTarget = kbUnitQueryGetResult(enemyTarget, i);
		break;
	}
	
	if(currentTarget == -1)return;
	int attackUnit = kbUnitQueryCreate("attackUnit");
	kbUnitQuerySetPlayerID(attackUnit, cMyID, false);
	kbUnitQuerySetUnitType(attackUnit, attackType);
	
	kbUnitQuerySetIgnoreKnockedOutUnits(attackUnit, true);
	kbUnitQuerySetState(attackUnit, cUnitStateAlive);
	int unitTarget = -1;
	for (i = 0; < kbUnitQueryExecute(attackUnit))
	{
		if( kbUnitGetHealth(attackUnit) < 1) continue;
		unitTarget = kbUnitQueryGetResult(attackUnit, i);
		float unitDist = distance(kbUnitGetPosition(enemyTarget), kbUnitGetPosition(unitTarget));
		if(unitDist > 20) continue;
		aiTaskUnitWork(unitTarget,currentTarget);
	}	
}

void targetAttackTimer()
//active
//minInterval 2
{
	for (x = 0; < cNumberPlayers)
	{
		if (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(x) && cMyID != x)
		{ 		
			targetAttack(x,cUnitTypeAbstractArtillery,cUnitTypeAbstractHandCavalry);
			targetAttack(x,cUnitTypeAbstractCavalry,cUnitTypeAbstractHandInfantry);
			targetAttack(x,cUnitTypeAbstractHandInfantry,cUnitTypeAbstractRangedInfantry);
			targetAttack(x,cUnitTypeAbstractCavalry,cUnitTypeAbstractRangedCavalry);
			targetAttack(x,cUnitTypeAbstractCavalry,cUnitTypeAbstractArtillery);
			targetAttack(x,cUnitTypeAbstractArtillery,cUnitTypeAbstractArtillery);
			targetAttack(x,cUnitTypeAbstractFort,cUnitTypeLogicalTypeLandMilitary);
			targetAttack(x,gTowerUnit,cUnitTypeLogicalTypeLandMilitary);
			targetAttack(x,cUnitTypeAbstractFort,cUnitTypeMortar);
		}
	}
}


//==============================================================================
// kiteUnit
// updatedOn 2020/10/14 By ageekhere
//==============================================================================
rule kiteUnit  
active
minInterval 1
{
	if(aiTreatyActive() == true) return;
	static int enemy = -1;
	static int units = -1;
	if (units == -1) units = kbUnitQueryCreate("units");
	kbUnitQueryResetResults(units);
	kbUnitQuerySetPlayerID(units, cMyID);
	kbUnitQuerySetUnitType(units, cUnitTypeRanged);
	kbUnitQuerySetIgnoreKnockedOutUnits(units, true);
	kbUnitQuerySetState(units, cUnitStateAlive);
	
	
	for (i = 0; < kbUnitQueryExecute(units))
	{
		int unitID = kbUnitQueryGetResult(units, i);
		if(kbUnitIsType(unitID,cUnitTypeMusketeer) == true) continue;
		if(kbUnitIsType(unitID,cUnitTypeHero) == true) continue;
		
		
		if (enemy == -1) enemy = kbUnitQueryCreate("enemy");
		kbUnitQueryResetResults(enemy);
		kbUnitQuerySetPlayerRelation(enemy,cPlayerRelationEnemyNotGaia);
		kbUnitQuerySetUnitType(enemy, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetPosition(enemy, kbUnitGetPosition(unitID) ); //set the location
		kbUnitQuerySetMaximumDistance(enemy, 8);
		kbUnitQuerySetIgnoreKnockedOutUnits(enemy, true);
		kbUnitQuerySetState(enemy, cUnitStateAlive);
		
		if(kbUnitQueryExecute(enemy) > 0)
		{	
			int nearestEnemy = 0;
			float nearestDist = 999999;
			for (b = 0; < kbUnitQueryExecute(enemy))
			{	
				int nearestId = kbUnitQueryGetResult(enemy, b);
				float nearDistCheck = distance(kbUnitGetPosition(unitID), kbUnitGetPosition(nearestId));
				if(nearDistCheck < nearestDist)
				{
					nearestDist = nearDistCheck;
					nearestEnemy = nearestId;
				}
			}
			int enemyId = nearestEnemy;
			vector kiteLocation = cInvalidVector;
			vector kiteLocationCheck =  kbUnitGetPosition(unitID);
			
			float farthestDist = 0;
			float distCheck = 0;
			float dx = 5;
			float dz = 5;				
			for(t = 0;< 8)
			{
				dx = 5;
				dz = 5;
				switch(t) 
				{ 
					case 0:
					{  // W
						dx = -0.9 * dx;
						dz = 0.9 * dz;
						break;
					}
					case 1:
					{  // NW
						dx = 0.0;
						break;
					}
					case 2:
					{  // N
						dx = 0.9 * dx;
						dz = 0.9 * dz;
						break;
					}
					case 3:						
					{  // NE
						dz = 0.0;
						break;
					}
					case 4:									
					{  // E									
						dx = 0.9 * dx;
						dz = -0.9 * dz;	
						break;
					}
					case 5:
					{  // SE
						dx = 0.0;
						dz = -1.0 * dz;	
						break;
					}
					
					case 6:
					{  // S
						dx = -0.9 * dx;
						dz = -0.9 * dz;
						break;
					}
					case 7:
					{  // SW
						dx = -1.0 * dx;
						dz = 0;
						break;
					}
					
				}
				kiteLocationCheck =  kbUnitGetPosition(unitID);
				kiteLocationCheck = xsVectorSetX(kiteLocationCheck, xsVectorGetX(kiteLocationCheck) + dx);
				kiteLocationCheck = xsVectorSetZ(kiteLocationCheck, xsVectorGetZ(kiteLocationCheck) + dz);
				
				distCheck = distance(kiteLocationCheck, kbUnitGetPosition(enemyId));
				if(distCheck > farthestDist)
				{
					kiteLocation = kiteLocationCheck;
					farthestDist = distCheck;
				}
				
				
			}	
			aiTaskUnitMove(unitID, kiteLocation);
			
		}
		
		//break;
	}
}






/*
	rule AdaptiveDifficulty  
	active
	minInterval 30
	{
	if(aiGetWorldDifficulty() != cDifficultyExpert) xsDisableSelf();
	if(xsGetTime() < 180000) return;
	bool upHandicap = false;
	
	for (x = 1; < cNumberPlayers -1)
	{
	if (cMyID != x && kbIsPlayerHuman(x) == true && aiGetScore(x) > aiGetScore(cMyID) && kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(x))
	{
	upHandicap = true;
	break;
	}
	}
	float startingHandicap = kbGetPlayerHandicap(cMyID);
	if(upHandicap == true)
	{
	startingHandicap = kbGetPlayerHandicap(cMyID);
	baselineHandicap = baselineHandicap + 0.1;
	kbSetPlayerHandicap(cMyID, baselineHandicap);
	}
	else
	{
	if(baselineHandicap <= 1.5)return;
	startingHandicap = kbGetPlayerHandicap(cMyID);
	baselineHandicap = baselineHandicap - 0.1;
	kbSetPlayerHandicap(cMyID, baselineHandicap);
	}
	}
*/
/*
	rule repairManager
	active
	minInterval 10
	{	
	//if(aiGetWorldDifficulty() == cDifficultyHard || aiGetWorldDifficulty() == cDifficultyExpert) return; //Hard and expert use cheat repair
	
	
	float repairAt = 0.9; //when to repair
	int buildingType = cUnitTypeBuilding; //building type to repair
	if(kbResourceGet(cResourceWood) < 3000) buildingType = cUnitTypeAbstractFort; //when low in wood 
	//levels to repair at, depending on wood
	if(kbResourceGet(cResourceWood) < 3000)repairAt = 0.8;
	if(kbResourceGet(cResourceWood) < 2500)repairAt = 0.7;
	if(kbResourceGet(cResourceWood) < 2000)repairAt = 0.6;
	if(kbResourceGet(cResourceWood) < 1500)repairAt = 0.5;
	if(kbResourceGet(cResourceWood) < 1000)repairAt = 0.4;
	if(kbResourceGet(cResourceWood) < 500)repairAt = 0.3;
	
	//plan to get buildings
	static int repairPlan = -1;
	if (repairPlan == -1) repairPlan = kbUnitQueryCreate("repairPlan");
	kbUnitQuerySetPlayerID(repairPlan, cMyID, false);
	kbUnitQuerySetUnitType(repairPlan, buildingType);
	kbUnitQuerySetState(repairPlan, cUnitStateAlive);
	for (i = 0; < kbUnitQueryExecute(repairPlan))
	{
	int buildingId = kbUnitQueryGetResult(repairPlan, i);
	float buildingHealth = kbUnitGetHealth( buildingId );
	
	//if( buildingHealth < repairAt )
	if( buildingHealth < 1.0 )
	{
	//aiChat(1,"buildingHealth " + buildingHealth);
	aiChat(1,"repair " + buildingId);
	aiTaskUnitRepair(buildingId);
	//aiTaskUnitWork(buildingId,buildingId);
	}	
	}
	} //end 
*/


rule saveBase
active
minInterval 60
{
	if(aiTreatyActive() == true) return;
	
	int enemy = kbUnitQueryCreate("enemy");
	kbUnitQuerySetPlayerRelation(enemy,cPlayerRelationEnemyNotGaia);
	kbUnitQuerySetUnitType(enemy, cUnitTypeMilitary);
	kbUnitQuerySetPosition(enemy, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
	kbUnitQuerySetMaximumDistance(enemy, 40);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemy, true);
	kbUnitQuerySetState(enemy, cUnitStateAlive);
	
	if(kbUnitQueryExecute(enemy) > 40)
	{
		static int militaryHome = -1;
		if (militaryHome == -1) militaryHome = kbUnitQueryCreate("militaryHome");
		kbUnitQuerySetPlayerID(militaryHome, cMyID, false);
		kbUnitQuerySetUnitType(militaryHome, cUnitTypeMilitary);
		kbUnitQuerySetState(militaryHome, cUnitStateAlive);
		
		for (j = 0; < kbUnitQueryExecute(militaryHome))
		{
			int militaryHimeId = kbUnitQueryGetResult(militaryHome, j);
			aiTaskUnitMove(militaryHimeId, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) );
		}
		
	}
}
/*
	rule rush
	inactive
	minInterval 60
	{
	if(aiTreatyActive() == true) return;
	if (kbGetAge() < cAge2 || xsGetTime() < 240000 || xsGetTime() > 900000) return;
	if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))return;
	
	static int militaryUnitRush = -1;
	if (militaryUnitRush == -1) militaryUnitRush = kbUnitQueryCreate("militaryUnitRush");
	kbUnitQuerySetPlayerID(militaryUnitRush, cMyID, false);
	kbUnitQuerySetUnitType(militaryUnitRush, cUnitTypeMilitary);
	kbUnitQuerySetState(militaryUnitRush, cUnitStateAlive);
	
	if(kbUnitQueryExecute(militaryUnitRush) > 20)
	{
	for (j = 0; < kbUnitQueryExecute(militaryUnitRush))
	{
	int militaryRushId = kbUnitQueryGetResult(militaryUnitRush, j);
	aiTaskUnitMove(militaryRushId, kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())) );
	}
	}
	}
	
	rule rushLong
	inactive
	minInterval 900
	{
	if(aiTreatyActive() == true) return;
	if (gDefenseReflexBaseID == kbBaseGetMainID(cMyID))return;
	static int militaryUnitRushLong = -1;
	if (militaryUnitRushLong == -1) militaryUnitRushLong = kbUnitQueryCreate("militaryUnitRushLong");
	kbUnitQuerySetPlayerID(militaryUnitRushLong, cMyID, false);
	kbUnitQuerySetUnitType(militaryUnitRushLong, cUnitTypeMilitary);
	kbUnitQuerySetState(militaryUnitRushLong, cUnitStateAlive);
	
	if(kbUnitQueryExecute(militaryUnitRushLong) > 20)
	{
	for (j = 0; < kbUnitQueryExecute(militaryUnitRushLong))
	{
	int militaryRushId = kbUnitQueryGetResult(militaryUnitRushLong, j);
	aiTaskUnitMove(militaryRushId, kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())) );
	}
	}
	}
*/


void sendRaid(int unitType = -1)
{ //hunt down settlers and explorers 
	vector sendPosition = cInvalidVector;
	//get enemy setters
	int enemySettler = kbUnitQueryCreate("enemySettler");
	kbUnitQuerySetPlayerID(enemySettler, aiGetMostHatedPlayerID(), false);
	kbUnitQuerySetUnitType(enemySettler, cUnitTypeAffectedByTownBell);
	kbUnitQuerySetPosition(enemySettler,kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID()) ));
	kbUnitQuerySetAscendingSort(enemySettler,true);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemySettler, true);
	kbUnitQuerySetState(enemySettler, cUnitStateAlive);
	
	int enemyExplorer = kbUnitQueryCreate("enemyExplorer");
	kbUnitQuerySetPlayerID(enemyExplorer, aiGetMostHatedPlayerID(), false);
	kbUnitQuerySetUnitType(enemyExplorer, cUnitTypeExplorer);
	kbUnitQuerySetPosition(enemyExplorer,kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())));
	kbUnitQuerySetAscendingSort(enemyExplorer,true);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyExplorer, true);
	kbUnitQuerySetState(enemyExplorer, cUnitStateAlive);
	
	int enemyAnimalPrey = kbUnitQueryCreate("enemyAnimalPrey");
	kbUnitQuerySetPlayerID(enemyAnimalPrey, 0);
	kbUnitQuerySetUnitType(enemyAnimalPrey, cUnitTypeAnimalPrey);
	kbUnitQuerySetPosition(enemyAnimalPrey,kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())));
	kbUnitQuerySetAscendingSort(enemyAnimalPrey,true);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyAnimalPrey, true);
	kbUnitQuerySetState(enemyAnimalPrey, cUnitStateAlive);
	
	int enemyGold = kbUnitQueryCreate("enemyGold");
	kbUnitQuerySetPlayerID(enemyGold, 0);
	kbUnitQuerySetUnitType(enemyGold, cUnitTypeAbstractMine);
	kbUnitQuerySetPosition(enemyGold,kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())));
	kbUnitQuerySetAscendingSort(enemyGold,true);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyGold, true);
	kbUnitQuerySetState(enemyGold, cUnitStateAlive);
	
	int attackUnit = -1;
	float targetDist = -1;
	if(kbUnitQueryExecute(enemySettler) > 0)
	{
		attackUnit = kbUnitQueryGetResult(enemySettler, 0);
		sendPosition = kbUnitGetPosition( attackUnit );
		targetDist = distance(sendPosition,kbUnitGetPosition(kbBaseGetMainID(aiGetMostHatedPlayerID())));
	}
	else if( kbUnitQueryExecute(enemyExplorer) > 0 )
	{
		attackUnit = kbUnitQueryGetResult(enemyExplorer, 0);
		sendPosition = kbUnitGetPosition( attackUnit );
		targetDist = distance(sendPosition,kbUnitGetPosition(kbBaseGetMainID(aiGetMostHatedPlayerID())));
	}
	
	int sendUnit = -1;
	if (sendUnit == -1) sendUnit = kbUnitQueryCreate("sendUnit");
	kbUnitQuerySetPlayerID(sendUnit, cMyID, false);
	kbUnitQuerySetUnitType(sendUnit, unitType);
	kbUnitQuerySetPosition(sendUnit,kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())));
	kbUnitQuerySetAscendingSort(sendUnit,true);
	kbUnitQuerySetState(sendUnit, cUnitStateAlive);
	
	int sendUnitId = -1;
	if (sendPosition != cInvalidVector && targetDist < 30)
	{		
		for (i = 0; < kbUnitQueryExecute(sendUnit))
		{
			if(i > 5) return;
			sendUnitId = kbUnitQueryGetResult(sendUnit, i);
			aiPlanDestroy(kbUnitGetPlanID(sendUnitId));
			aiTaskUnitWork(sendUnitId,attackUnit);
		}
		
	}
	else
	{
		int sendCount = 0;
		int sendAmount = 5;
		if (kbGetAge() < cAge3) sendAmount = 2;
		bool sendToGold = true;
		for (i = 0; < kbUnitQueryExecute(sendUnit))
		{
			if(sendCount > sendAmount) return;
			sendUnitId = kbUnitQueryGetResult(sendUnit, i);
			if(kbUnitIsType(sendUnitId, cUnitTypeAbstractMonk) == true) continue;
			sendCount++;
			
			aiPlanDestroy(kbUnitGetPlanID(sendUnitId));
			
			int enemyBuildings = -1;
			
			for(j = 0; < kbUnitQueryExecute(enemyAnimalPrey))
			{
				if( distance( kbUnitGetPosition(kbUnitQueryGetResult(enemyAnimalPrey, j)),kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID()))) < 20) continue;
				if( distance( kbUnitGetPosition(kbUnitQueryGetResult(enemyAnimalPrey, j)),kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID()))) > 80) continue;
				if(kbUnitQueryExecute(enemyBuildings) > 0) continue;
				
				enemyBuildings = kbUnitQueryCreate("enemyBuildings");
				kbUnitQuerySetPlayerRelation(enemyBuildings,cPlayerRelationEnemyNotGaia);
				kbUnitQuerySetUnitType(enemyBuildings, cUnitTypeLogicalTypeBuildingsNotWalls);
				kbUnitQuerySetPosition(enemyBuildings, kbUnitGetPosition(kbUnitQueryGetResult(enemyAnimalPrey, j)));
				kbUnitQuerySetMaximumDistance(enemyBuildings, 30);
				kbUnitQuerySetAscendingSort(enemyBuildings,true);
				kbUnitQuerySetIgnoreKnockedOutUnits(enemyBuildings, true);
				kbUnitQuerySetState(enemyBuildings, cUnitStateAlive);
				
				if( distance(kbUnitGetPosition(kbUnitQueryGetResult(enemyAnimalPrey, j)),kbUnitGetPosition(sendUnitId)) < 20)return; 
				sendToGold = false;
				aiTaskUnitMove(sendUnitId, kbUnitGetPosition(kbUnitQueryGetResult(enemyAnimalPrey, j)) );
				break;
			}
			if(sendToGold == true)
			{
				if( distance( kbUnitGetPosition(kbUnitQueryGetResult(enemyGold, j)),kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID()))) < 20) continue;
				if( distance( kbUnitGetPosition(kbUnitQueryGetResult(enemyGold, j)),kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID()))) > 80) continue;
				if(kbUnitQueryExecute(enemyBuildings) > 0) continue;
				
				enemyBuildings = kbUnitQueryCreate("enemyBuildings");
				kbUnitQuerySetPlayerRelation(enemyBuildings,cPlayerRelationEnemyNotGaia);
				kbUnitQuerySetUnitType(enemyBuildings, cUnitTypeLogicalTypeBuildingsNotWalls);
				kbUnitQuerySetPosition(enemyBuildings, kbUnitGetPosition(kbUnitQueryGetResult(enemyAnimalPrey, j)));
				kbUnitQuerySetMaximumDistance(enemyBuildings, 30);
				kbUnitQuerySetAscendingSort(enemyBuildings,true);
				kbUnitQuerySetIgnoreKnockedOutUnits(enemyBuildings, true);
				kbUnitQuerySetState(enemyBuildings, cUnitStateAlive);
				if( distance(kbUnitGetPosition(kbUnitQueryGetResult(enemyGold, j)),kbUnitGetPosition(sendUnitId)) < 20)return; 
				sendToGold = false;
				aiTaskUnitMove(sendUnitId, kbUnitGetPosition(kbUnitQueryGetResult(enemyGold, j)) );
				break;					
			}
		}
	}
	
}



//==============================================================================
// spy
// updatedOn 2019/12/09 By ageekhere
//==============================================================================
//rule spy
//active
//minInterval 10
void spy()
{
	static int randomSpy = -1;
	static int spyPlan = -1;
	
	if (kbGetAge() > cAge3) 
	{
		aiPlanDestroy(spyPlan);
		return;
	}
	if(randomSpy == -1) randomSpy = aiRandInt(2);
	if(randomSpy == 0 && aiGetWorldDifficulty() != cDifficultyExpert && aiGetWorldDifficulty() != cDifficultyHard )return;
	if(aiTreatyActive() == true) return;
	if (kbGetAge() < cAge2 || civIsNative() == true || civIsAsian() == true || aiTreatyActive() == true || aiGetWorldDifficulty() == cDifficultySandbox || aiGetWorldDifficulty() == cDifficultyEasy) return;
	int spyNum = 1; //1
	if(aiGetWorldDifficulty() == cDifficultyModerate) spyNum = 1;
	if(aiGetWorldDifficulty() == cDifficultyHard) spyNum = 2;
	if(aiGetWorldDifficulty() == cDifficultyExpert) spyNum = 3;
	
	if (spyPlan < 0 && kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) > 0)
	{ //create spy
		spyPlan = createSimpleMaintainPlan(cUnitTypexpSpy, spyNum, false, kbBaseGetMainID(cMyID), spyNum);
	}
	sendRaid(cUnitTypexpSpy);
	
}
void militaryRaid()
{
	if(kbGetAge() > cAge2)return;
	sendRaid(cUnitTypeAbstractCavalry);
}

/*
	void spy()
	{ //hunt down settlers and explorers 
	static int randomSpy = -1;
	if(randomSpy == -1) randomSpy = aiRandInt(2);
	if(randomSpy == 0 && aiGetWorldDifficulty() != cDifficultyExpert )return;
	if(aiTreatyActive() == true) return;
	if (kbGetAge() > cAge3) return;
	if (kbGetAge() < cAge2 || civIsNative() == true || civIsAsian() == true || aiTreatyActive() == true || aiGetWorldDifficulty() == cDifficultySandbox || aiGetWorldDifficulty() == cDifficultyEasy) return;
	int spyNum = 1; //1
	if(aiGetWorldDifficulty() == cDifficultyExpert) spyNum = 2;//2
	static int spyPlan = -1;
	if (spyPlan < 0 && kbUnitCount(cMyID, cUnitTypeChurch, cUnitStateAlive) > 0)
	{ //create spy
	spyPlan = createSimpleMaintainPlan(cUnitTypexpSpy, spyNum, false, kbBaseGetMainID(cMyID), spyNum);
	}
	vector sendPosition = cInvalidVector;
	//get enemy setters
	static int enemySettler = -1; 
	if (enemySettler == -1) enemySettler = kbUnitQueryCreate("enemySettler");
	kbUnitQuerySetPlayerID(enemySettler, aiGetMostHatedPlayerID(), false);
	kbUnitQuerySetUnitType(enemySettler, cUnitTypeAffectedByTownBell);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemySettler, true);
	kbUnitQuerySetState(enemySettler, cUnitStateAlive);
	int featherestSettler = -1;
	float featherestDist = 0;
	int attackUnit = -1;
	for (i = 0; < kbUnitQueryExecute(enemySettler))
	{
	int currentSettler = kbUnitQueryGetResult(enemySettler, i);
	float settlerDist = distance(kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())), kbUnitGetPosition(currentSettler));
	if (featherestDist < settlerDist)
	{
	featherestSettler = currentSettler;
	featherestDist = settlerDist;
	}
	}
	if (i > 0 && featherestDist > 100 && kbUnitGetPosition(featherestSettler) != cInvalidVector)
	{
	sendPosition = kbUnitGetPosition(featherestSettler);
	attackUnit = featherestSettler;
	}
	else
	{
	static int enemyExplorer = -1;
	if (enemyExplorer == -1) enemyExplorer = kbUnitQueryCreate("enemyExplorer");
	kbUnitQuerySetPlayerID(enemyExplorer, aiGetMostHatedPlayerID(), false);
	kbUnitQuerySetUnitType(enemyExplorer, cUnitTypeExplorer);
	kbUnitQuerySetIgnoreKnockedOutUnits(enemyExplorer, true);
	kbUnitQuerySetState(enemyExplorer, cUnitStateAlive);
	
	for (i = 0; < kbUnitQueryExecute(enemyExplorer))
	{
	int enemyExplorerId = kbUnitQueryGetResult(enemyExplorer, i);
	
	if (distance(kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())), kbUnitGetPosition(enemyExplorerId)) > 100)
	{
	sendPosition = kbUnitGetPosition(enemyExplorerId);
	attackUnit = enemyExplorerId;
	}
	break;
	}
	}
	if (sendPosition != cInvalidVector)
	{
	static int spyUnit = -1;
	if (spyUnit == -1) spyUnit = kbUnitQueryCreate("spyUnit");
	kbUnitQuerySetPlayerID(spyUnit, cMyID, false);
	kbUnitQuerySetUnitType(spyUnit, cUnitTypexpSpy);
	kbUnitQuerySetState(spyUnit, cUnitStateAlive);
	
	for (j = 0; < kbUnitQueryExecute(spyUnit))
	{
	int spyId = kbUnitQueryGetResult(spyUnit, j);
	aiPlanDestroy(kbUnitGetPlanID(spyId));
	aiTaskUnitWork(spyId,attackUnit);
	}
	
	if (kbGetAge() > cAge2)
	{
	static int cavUnit = -1;
	if (cavUnit == -1) cavUnit = kbUnitQueryCreate("cavUnit");
	kbUnitQuerySetPlayerID(cavUnit, cMyID, false);
	kbUnitQuerySetUnitType(cavUnit, cUnitTypeAbstractCavalry);
	kbUnitQuerySetState(cavUnit, cUnitStateAlive);
	kbUnitQuerySetActionType(cavUnit,7);
	
	int maxSend = 0;
	for (j = 0; < kbUnitQueryExecute(cavUnit))
	{
	int cavId = kbUnitQueryGetResult(cavUnit, j);
	aiPlanDestroy(kbUnitGetPlanID(cavId));
	aiTaskUnitWork(cavId,attackUnit);
	if(j == 6) break;
	}
	}
	
	}
	
	enemySettler = -1;
	enemyExplorer = -1;
	}
*/


rule ramManager
active
minInterval 10
{
	if(aiTreatyActive() == true) return;
	if (kbGetCiv() != cCivXPIroquois) return;
	if (kbGetAge() < cAge4) return;
	static int ramPlan = -1;
	int ramNum = 10;//kbGetBuildLimit(cMyID, cUnitTypexpRam);
	if (ramPlan < 0 && kbUnitCount(cMyID, cUnitTypeArtilleryDepot, cUnitStateAlive) > 0)
	{ 
		ramPlan = createSimpleMaintainPlan(cUnitTypexpRam, ramNum, false, kbBaseGetMainID(cMyID), ramNum);	
	}
	
	int ramUnit = -1;
	if (ramUnit == -1) ramUnit = kbUnitQueryCreate("ramUnit");
	kbUnitQuerySetPlayerID(ramUnit, cMyID, false);
	kbUnitQuerySetUnitType(ramUnit, cUnitTypexpRam);
	kbUnitQuerySetState(ramUnit, cUnitStateAlive);
	
	int ramId = -1;
	int millCheck = kbUnitQueryCreate("millCheck");
	kbUnitQuerySetPlayerID(millCheck, cMyID);
	kbUnitQuerySetIgnoreKnockedOutUnits(millCheck, true);
	kbUnitQuerySetUnitType(millCheck, cUnitTypeLogicalTypeLandMilitary);
	kbUnitQuerySetState(millCheck, cUnitStateAlive);
	
	if(kbUnitQueryExecute(ramUnit) > 2 && kbUnitQueryExecute(millCheck) > 50)
	{
		for (j = 0; < kbUnitQueryExecute(ramUnit))
		{
			ramId = kbUnitQueryGetResult(ramUnit, j);
			aiTaskUnitWork(ramId,petardTarget);
		}
	}
	
}





//==============================================================================
// blackPowderManager
// updatedOn 2020/02/29 By ageekhere
//==============================================================================

rule blackPowderManager
active
minInterval 10
{
	if(aiTreatyActive() == true) return;
	if (kbGetCiv() != cCivUSA) return;
	if (kbGetAge() < cAge4) return;
	static int powderPlan = -1;
	int powderNum = kbGetBuildLimit(cMyID, cUnitTypeBlackPowderWagon);
	
	if (powderPlan < 0 && kbUnitCount(cMyID, cUnitTypeBarracks, cUnitStateAlive) > 0)
	{ 
		powderPlan = createSimpleMaintainPlan(cUnitTypeBlackPowderWagon, powderNum, false, kbBaseGetMainID(cMyID), powderNum);	
	}
	
	int powderUnit = -1;
	if (powderUnit == -1) powderUnit = kbUnitQueryCreate("powderUnit");
	kbUnitQuerySetPlayerID(powderUnit, cMyID, false);
	kbUnitQuerySetUnitType(powderUnit, cUnitTypeBlackPowderWagon);
	kbUnitQuerySetState(powderUnit, cUnitStateAlive);
	
	int powderId = -1;
	int millCheck = kbUnitQueryCreate("millCheck");
	kbUnitQuerySetPlayerID(millCheck, cMyID);
	kbUnitQuerySetIgnoreKnockedOutUnits(millCheck, true);
	kbUnitQuerySetUnitType(millCheck, cUnitTypeLogicalTypeLandMilitary);
	kbUnitQuerySetState(millCheck, cUnitStateAlive);
	
	if(kbUnitQueryExecute(powderUnit) > 2 && kbUnitQueryExecute(millCheck)  > 50)
	{
		for (j = 0; < kbUnitQueryExecute(powderUnit))
		{
			powderId = kbUnitQueryGetResult(powderUnit, j);
			aiTaskUnitWork(powderId,petardTarget);
		}
	}
	
}


//==============================================================================
// petardManager
// updatedOn 2020/02/24 By ageekhere
//==============================================================================
rule petardManager
active
minInterval 10
{
	if(aiTreatyActive() == true) return;
	if ( (kbGetCiv() != cCivJapanese) && (kbGetCiv() != cCivSPCJapanese) && (kbGetCiv() != cCivSPCJapaneseEnemy) ) return;
	if (kbGetAge() < cAge4) return;
	static int petardPlan = -1;
	int petardNum = kbGetBuildLimit(cMyID, cUnitTypexpPetard);
	
	if (petardPlan < 0 && kbUnitCount(cMyID, cUnitTypeypCastle, cUnitStateAlive) > 0)
	{ //create mortars
		petardPlan = createSimpleMaintainPlan(cUnitTypexpPetard, petardNum, false, kbBaseGetMainID(cMyID), petardNum);
	}
	
	int petardUnit = -1;
	if (petardUnit == -1) petardUnit = kbUnitQueryCreate("petardUnit");
	kbUnitQuerySetPlayerID(petardUnit, cMyID, false);
	kbUnitQuerySetUnitType(petardUnit, cUnitTypexpPetard);
	kbUnitQuerySetState(petardUnit, cUnitStateAlive);
	
	int petardId = -1;
	
	int millCheck = kbUnitQueryCreate("millCheck");
	kbUnitQuerySetPlayerID(millCheck, cMyID);
	kbUnitQuerySetIgnoreKnockedOutUnits(millCheck, true);
	kbUnitQuerySetUnitType(millCheck, cUnitTypeLogicalTypeLandMilitary);
	kbUnitQuerySetState(millCheck, cUnitStateAlive);
	
	if(kbUnitQueryExecute(petardUnit) > 2 && kbUnitQueryExecute(millCheck)  > 50)
	{
		for (j = 0; < kbUnitQueryExecute(petardUnit))
		{
			petardId = kbUnitQueryGetResult(petardUnit, j);
			aiTaskUnitWork(petardId,petardTarget);
		}
	}
	
	
}
//==============================================================================
// mortarManager
// updatedOn 2020/02/24 By ageekhere
//==============================================================================
rule mortarManager
active
minInterval 10
{ //targets nearby AbstractFort and attacks them
	if(aiTreatyActive() == true) return;
	if (kbGetAge() < cAge4) return; //check if it is time to make mortars
	int mortarNum = 5; //number of mortars to build
	static int mortarPlan = -1;
	int mortarType = cUnitTypeMortar;
	int artilleryBuilding = cUnitTypeArtilleryDepot;
	petardTarget = -1;
	if ( (kbGetCiv() == cCivJapanese) || (kbGetCiv() == cCivSPCJapanese) || (kbGetCiv() == cCivSPCJapaneseEnemy) ) 
	{
		mortarType = cUnitTypeypMorutaru;
		artilleryBuilding = cUnitTypeypCastle;
	}
	
	if (mortarPlan < 0 && kbUnitCount(cMyID, artilleryBuilding, cUnitStateAlive) > 0)
	{ //create mortars
		mortarPlan = createSimpleMaintainPlan(mortarType, mortarNum, false, kbBaseGetMainID(cMyID), mortarNum);
	}//end if
	if( kbUnitCount(cMyID, mortarType, cUnitStateABQ) == 0 )aiTaskUnitTrain(getUnit(artilleryBuilding), mortarType);
	
	int buildingId = -1;
	float currentDist = -1;
	float lastDist = 999999;
	int nearestId = -1;
	
	for (t = 0; < cNumberPlayers)
	{ //loop through players
		if (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(t) && (t != cMyID))
		{ //That are not on my team and is not me
			int nearTarget = -1;
			if (nearTarget == -1) nearTarget = kbUnitQueryCreate("nearTarget");
			kbUnitQuerySetPlayerID(nearTarget, t, false);
			kbUnitQuerySetUnitType(nearTarget, cUnitTypeAbstractFort); 
			kbUnitQuerySetState(nearTarget, cUnitStateAlive);	
			for (i = 0; < kbUnitQueryExecute(nearTarget))
			{
				buildingId = kbUnitQueryGetResult(nearTarget, i);
				currentDist = distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(buildingId));
				if (currentDist < lastDist)
				{
					lastDist = currentDist;
					nearestId = buildingId;
				}		
			}
		}	
	}
	
	if(nearestId != -1)
	{
		petardTarget = nearestId;
		int mortarUnit = -1;
		if (mortarUnit == -1) mortarUnit = kbUnitQueryCreate("mortarUnit");
		kbUnitQuerySetPlayerID(mortarUnit, cMyID, false);
		kbUnitQuerySetUnitType(mortarUnit, mortarType);
		kbUnitQuerySetState(mortarUnit, cUnitStateAlive);
		
		
		int cavUnit = -1;
		if (cavUnit == -1) cavUnit = kbUnitQueryCreate("cavUnit");
		kbUnitQuerySetPlayerID(cavUnit, cMyID, false);
		kbUnitQuerySetUnitType(cavUnit, cUnitTypeAbstractLightCavalry);
		kbUnitQuerySetState(cavUnit, cUnitStateAlive);
		
		int millCheck = kbUnitQueryCreate("millCheck");
		kbUnitQuerySetPlayerID(millCheck, cMyID);
		kbUnitQuerySetIgnoreKnockedOutUnits(millCheck, true);
		kbUnitQuerySetUnitType(millCheck, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetState(millCheck, cUnitStateAlive);
		
		if(kbUnitQueryExecute(millCheck)  > 50)
		{
			int mortarId = -1;
			for (j = 0; < kbUnitQueryExecute(mortarUnit))
			{
				mortarId = kbUnitQueryGetResult(mortarUnit, j);
				aiTaskUnitWork(mortarId,nearestId);
			}
			
			if(mortarId != -1)
			{
				for (j = 0; < kbUnitQueryExecute(cavUnit))
				{
					int cavId = kbUnitQueryGetResult(cavUnit, j);
					aiTaskUnitWork(cavId,mortarId);
				}
			}
		}
		
	}
}



void trainUnit(int buildingType = -1, int buildingId = -1, int unitType = -1, int buildNum = -1)
{
	if (kbUnitCount(cMyID, buildingType, cUnitStateAlive) == 0) return;
	for (i = 0; < buildNum)
	{
		aiTaskUnitTrain(buildingId, unitType);
	}
}


int getBuildingId(int buidingType = -1)
{
	int buildingId = 0;
	float currentDist = 0;
	float lastDist = 0;
	int nearestId = 0;
	
	int nearBuilding = -1;
	if (nearBuilding == -1) nearBuilding = kbUnitQueryCreate("nearBuilding");
	kbUnitQuerySetPlayerID(nearBuilding, cMyID, false);
	kbUnitQuerySetUnitType(nearBuilding, buidingType);
	kbUnitQuerySetState(nearBuilding, cUnitStateAlive);
	//kbUnitQuerySetActionType(nearBuilding,7);
	bool underattack = false;
	if (kbBaseGetUnderAttack(cMyID, kbBaseGetMainID(cMyID)) == true)
	{
		underattack = true;
		lastDist = 9999999;
	}
	bool skipBuilding = false;
	int queCount = 0;
	for (t = 0; < kbUnitQueryExecute(nearBuilding))
	{
		skipBuilding = false;
		buildingId = kbUnitQueryGetResult(nearBuilding, t);
		
		for (i = 0; < 100)
		{
			if (xsArrayGetInt(excludeBuildingArray, i) == -1)
			{
				queCount = i;
				break;
			}
			
			if (xsArrayGetInt(excludeBuildingArray, i) == buildingId)
			{
				skipBuilding = true;
			}
			
		}
		if (skipBuilding == true) continue;
		currentDist = distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(buildingId));
		
		if (underattack == true)
		{
			if (currentDist < lastDist)
			{
				lastDist = currentDist;
				nearestId = buildingId;
			}
		}
		else
		{
			if (currentDist > lastDist)
			{
				lastDist = currentDist;
				nearestId = buildingId;
			}
		}
	}
	xsArraySetInt(excludeBuildingArray, queCount, nearestId);
	return (nearestId);
	
}


//==============================================================================
/* rule f_moveArmy, rule for void newAttack()
	updatedOn 2020/04/16 By ageekhere 
*/
//==============================================================================
void f_moveArmy(vector targetLocation = cInvalidVector,)
{
	static int moveArmyID = -1;
	aiPlanDestroy(moveArmyID);
	
	moveArmyID=aiPlanCreate("moveArmyID", cPlanExplore);
	aiPlanAddUnitType(moveArmyID, cUnitTypeLogicalTypeLandMilitary, 300, 300, 300);
	aiPlanAddWaypoint(moveArmyID, targetLocation);
	aiPlanSetVariableBool(moveArmyID, cExplorePlanDoLoops, 0, true);
	//aiPlanSetVariableBool(moveArmyID, cExplorePlanQuitWhenPointIsVisible, 0, true);
	aiPlanSetVariableBool(moveArmyID, cExplorePlanAvoidingAttackedAreas, 0, false);
	aiPlanSetVariableInt(moveArmyID, cExplorePlanNumberOfLoops, 0, 2);
	aiPlanSetRequiresAllNeedUnits(moveArmyID, true);
	//aiPlanSetVariableVector(moveArmyID, cExplorePlanQuitWhenPointIsVisiblePt, 0, targetLocation);
	aiPlanSetDesiredPriority(moveArmyID, 100);	
	kbUnitQuerySetPosition(moveArmyID, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); 
	kbUnitQuerySetMaximumDistance(moveArmyID, 100);
	kbUnitQuerySetActionType(moveArmyID,7);
	aiPlanSetActive(moveArmyID);
}	

//==============================================================================
/* rule newAttack, creates new attack targets
	updatedOn 2020/04/16 By ageekhere 
*/
//==============================================================================
extern int currentTargetPlayerAttack = 0;
void newAttack()
{
	if(kbGetAge() < cAge3) return;
	static int lastAttackTimer = 0; 
	static int planID = -1;
	bool newTarget = true;
	int attackPlayer = aiGetMostHatedPlayerID();	
	int millAtBaseSize = 0;
	static int millLocationCheck = -1;
	kbUnitQueryDestroy(millLocationCheck);
	if(currentTargetPlayerAttack != 0 && (kbHasPlayerLost(currentTargetPlayerAttack) == false) && kbUnitCount(currentTargetPlayerAttack, gTownCenter, cUnitStateAlive) > 0)
	{
		millLocationCheck = kbUnitQueryCreate("millLocationCheck");
		kbUnitQuerySetPlayerID(millLocationCheck, cMyID);
		kbUnitQuerySetIgnoreKnockedOutUnits(millLocationCheck, true);
		kbUnitQuerySetUnitType(millLocationCheck, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetState(millLocationCheck, cUnitStateAlive);
		kbUnitQuerySetMaximumDistance(millLocationCheck, 100.0);
		kbUnitQuerySetPosition(millLocationCheck, kbBaseGetLocation(currentTargetPlayerAttack, kbBaseGetMainID(currentTargetPlayerAttack)));
		if (kbUnitQueryExecute(millLocationCheck) > 0) 
		{
			attackPlayer = currentTargetPlayerAttack;
			newTarget = false;
		}
	}
	int highestScore = 999999;
	if(kbIsFFA() == false && newTarget == true)
	{
		for (i = 1; < cNumberPlayers + 1)
		{
			if (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(i) && (i != cMyID) && (kbHasPlayerLost(i) == false) && kbUnitCount(i, gTownCenter, cUnitStateAlive) > 0)
			{ 
				if (highestScore > aiGetScore(i))
				{
					attackPlayer = i;
					highestScore = aiGetScore(i);
				}
				
			}
		}
	}
	aiSetMostHatedPlayerID(attackPlayer);
	currentTargetPlayerAttack = attackPlayer;
	
	static int millCheck = -1;
	if(millCheck == -1)
	{
		millCheck = kbUnitQueryCreate("millCheck");
		kbUnitQuerySetPlayerID(millCheck, cMyID);
		kbUnitQuerySetIgnoreKnockedOutUnits(millCheck, true);
		kbUnitQuerySetUnitType(millCheck, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetState(millCheck, cUnitStateAlive);
	}
	kbUnitQueryResetResults(millCheck);
	
	static int millAtBaseCheck = -1;
	if(millCheck == -1)
	{
		millAtBaseCheck = kbUnitQueryCreate("millAtBaseCheck");
		kbUnitQuerySetPlayerID(millAtBaseCheck, cMyID);
		kbUnitQuerySetIgnoreKnockedOutUnits(millAtBaseCheck, true);
		kbUnitQuerySetUnitType(millAtBaseCheck, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetState(millAtBaseCheck, cUnitStateAlive);
		kbUnitQuerySetMaximumDistance(millAtBaseCheck, 100.0);
		kbUnitQuerySetPosition(millAtBaseCheck, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)));
	}
	kbUnitQueryResetResults(millAtBaseCheck);
	millAtBaseSize = kbUnitQueryExecute(millAtBaseCheck);
	
	static int enemyUnitCheck = -1;
	if(enemyUnitCheck == -1)
	{
		kbUnitQueryCreate("enemyUnitCheck");
		kbUnitQuerySetPlayerRelation(enemyUnitCheck, cPlayerRelationEnemyNotGaia);
		kbUnitQuerySetIgnoreKnockedOutUnits(enemyUnitCheck, true);
		kbUnitQuerySetUnitType(enemyUnitCheck, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetAscendingSort(enemyUnitCheck, true);
		kbUnitQuerySetState(enemyUnitCheck, cUnitStateAlive);
	}
	kbUnitQueryResetResults(enemyUnitCheck);
	if(millAtBaseSize > 20)
	{
		vector baseArmyMoveLocation = cInvalidVector;
		baseArmyMoveLocation = kbBaseGetLocation(attackPlayer, kbBaseGetMainID(attackPlayer)) ;
		if(kbUnitQueryExecute(enemyUnitCheck) > 0)
		{
			baseArmyMoveLocation = kbUnitGetPosition(kbUnitQueryGetResult(enemyUnitCheck, 0));
		}
		f_moveArmy(baseArmyMoveLocation);
	}
	int helpPlayer = 0;
	int enemySize = 0;
	int myBaseEnemy = 0;
	int millHelpCheck = -1;
	for (i = 1; < cNumberPlayers + 1)
	{
		if (kbGetPlayerTeam(cMyID) == kbGetPlayerTeam(i) && (kbHasPlayerLost(i) == false))
		{ 
			kbUnitQueryDestroy(millHelpCheck);
			millHelpCheck = kbUnitQueryCreate("millHelpCheck");
			kbUnitQuerySetPlayerRelation(millHelpCheck, cPlayerRelationEnemyNotGaia);
			kbUnitQuerySetIgnoreKnockedOutUnits(millHelpCheck, true);
			kbUnitQuerySetUnitType(millHelpCheck, cUnitTypeLogicalTypeLandMilitary);
			kbUnitQuerySetState(millHelpCheck, cUnitStateAlive);
			kbUnitQuerySetMaximumDistance(millHelpCheck, 100.0);
			kbUnitQuerySetPosition(millHelpCheck, kbBaseGetLocation(i, kbBaseGetMainID(i)));
			if (i == cMyID) myBaseEnemy = kbUnitQueryExecute(millHelpCheck);
			if (enemySize < kbUnitQueryExecute(millHelpCheck)) 
			{
				enemySize = kbUnitQueryExecute(millHelpCheck);
				helpPlayer = i;
			}
		}			
	}
	
	int armySize = 200;
	/*
		if (kbGetAge() > cAge3) armySize = 40;
		if (kbGetAge() > cAge4) armySize = 70;
		if (kbGetAge() > cAge5) armySize = 100;
		if(kbUnitQueryExecute(millCheck) < armySize )
		{
		aiPlanDestroy(planID);
		return;
		}
	*/
	
	if(aiPlanGetActive(planID) == false)
	{
		aiPlanDestroy(planID);
	}
	
	
	if(enemySize > 10 && myBaseEnemy == 0)
	{
		f_moveArmy(kbUnitGetPosition(kbUnitQueryGetResult(enemyUnitCheck, 0)));
	}
	if(xsGetTime() - lastAttackTimer < 120000) return; //120000
	int attackTarget = -1;
	vector attackLocation = cInvalidVector;
	attackTarget = getUnit(cUnitTypeFortFrontier, attackPlayer, cUnitStateAlive);
	attackLocation = kbUnitGetPosition(attackTarget);
	
	if(attackTarget == -1)
	{
		attackTarget = getUnit(cUnitTypeTradingPost, attackPlayer, cUnitStateAlive);
		attackLocation = kbUnitGetPosition(attackTarget);
	}
	else if(attackTarget == -1)
	{
		attackTarget = getUnit(gTownCenter, attackPlayer, cUnitStateAlive);
		attackLocation = kbUnitGetPosition(attackTarget);
	}
	if(attackTarget == -1)
	{
		attackTarget = getUnit(cUnitTypeBuildingClass, attackPlayer, cUnitStateAlive);
		attackLocation = kbUnitGetPosition(attackTarget);
	}
	if(attackTarget == -1)
	{
		attackPlayer = aiGetMostHatedPlayerID();
		attackLocation = kbBaseGetLocation(attackPlayer, kbBaseGetMainID(attackPlayer));
	}
	
	int playersLeft = 0;
	for (x = 1; < cNumberPlayers - 1)
	{ //loop through players
		if (kbGetPlayerTeam(cMyID) != kbGetPlayerTeam(x) && (x != cMyID) && kbHasPlayerLost(x) == false)
		{ //that are not on my team and is not me and are not dead
			playersLeft++;
		}
	}
	
	if(playersLeft == 1 && getUnit(cUnitTypeBuildingClass, attackPlayer, cUnitStateAlive) == -1)
	{
		attackTarget = getUnit(cUnitTypeUnit, attackPlayer, cUnitStateAlive);
		attackLocation = kbUnitGetPosition(attackTarget);
	}
	planID = aiPlanCreate("APN", cPlanAttack);
	aiPlanSetDesiredPriority(planID, 95);
	aiPlanSetUnitStance(planID, cUnitStanceAggressive);
	aiPlanSetAllowUnderAttackResponse(planID, true);
	aiPlanSetVariableInt(planID, cAttackPlanPlayerID, 0, attackPlayer);
	aiPlanSetVariableVector(planID, cAttackPlanAttackPoint, 0, attackLocation);
	aiPlanSetVariableFloat(planID, cAttackPlanAttackPointEngageRange, 0, 60.0);
	aiPlanSetNumberVariableValues(planID, cAttackPlanTargetTypeID, 3, true);
	//aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 0, MainUnitToBeCountered);
	//aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 1, UnitWhichIsNotACounterOfOurAttacker);
	aiPlanSetVariableInt(planID, cAttackPlanTargetTypeID, 2, cUnitTypeLogicalTypeBuildingsNotWalls);
	aiPlanSetVariableInt(planID, cAttackPlanAttackRoutePattern, 0, cAttackPlanAttackRoutePatternRandom);
	aiPlanSetVariableBool(planID, cAttackPlanMoveAttack, 0, true);
	aiPlanSetVariableInt(planID, cAttackPlanRefreshFrequency, 0, 6);
	aiPlanSetVariableInt(planID, cAttackPlanHandleDamageFrequency, 0, 6);
	aiPlanSetVariableInt(planID, cAttackPlanBaseAttackMode, 0, cAttackPlanBaseAttackModeClosest);
	aiPlanSetVariableInt(planID, cAttackPlanRetreatMode, 0, cAttackPlanRetreatModeWillLose);
	aiPlanSetVariableInt(planID, cAttackPlanGatherWaitTime, 0, 0);
	aiPlanAddUnitType(planID, cUnitTypeLogicalTypeLandMilitary, armySize, 300, 300);
	aiPlanSetActive(planID, true);
	lastAttackTimer = xsGetTime();
}

rule newAttackTimer
active
minInterval 60
{
	newAttack();
}

//==============================================================================
// areaFind
// updatedOn 2020/03/31 By ageekhere
/*
	does a grid search looking for the shoreline
*/
//==============================================================================
vector currentSearchLocation = cInvalidVector;
rule areaFind
active
minInterval 1
{
	if(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID) == -1)
	{
		xsDisableSelf();
		return;
	}
	int mapSizeX = kbGetMapXSize(); //the map max X range
	int mapSizeZ = kbGetMapZSize(); //the map max Z range
	if(currentSearchLocation == cInvalidVector)
	{ //set the start search location		
		currentSearchLocation = xsVectorSetX(currentSearchLocation, xsVectorGetX(currentSearchLocation) - mapSizeX);
		currentSearchLocation = xsVectorSetZ(currentSearchLocation, xsVectorGetZ(currentSearchLocation) - mapSizeZ);
	} //end if
	vector lookAtArea = cInvalidVector; //A location where a search is done to find land next to water
	int count = 0;
	int range = 10; //the search size		
	while (xsVectorGetZ(currentSearchLocation) < mapSizeZ)
	{ //Z search
		while (xsVectorGetX(currentSearchLocation) < mapSizeX)
		{ //X search
			lookAtArea = currentSearchLocation; //update the lookAtArea location with the current search block
			int areaType = kbAreaGetIDByPosition(currentSearchLocation); //get the current area type
			if(kbAreaGetType(areaType) == 2 )
			{ //water type found
				for(i = 0; < 8)
				{ //area search at lookAtArea
					if(i == 0) lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) - range); 
					else if(i == 1)lookAtArea = xsVectorSetZ(lookAtArea, xsVectorGetZ(lookAtArea) + range);
					else if(i == 2)lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) + range);
					else if(i == 3)lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) + range);
					else if(i == 4)lookAtArea = xsVectorSetZ(lookAtArea, xsVectorGetZ(lookAtArea) - range);
					else if(i == 5)lookAtArea = xsVectorSetZ(lookAtArea, xsVectorGetZ(lookAtArea) - range);
					else if(i == 6)lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) - range);
					else if(i == 7)lookAtArea = xsVectorSetX(lookAtArea, xsVectorGetX(lookAtArea) - range);		
					areaType = kbAreaGetIDByPosition(lookAtArea); //get area type 
					if(kbAreaGetType(areaType) != 2 && kbAreaGetType(areaType) != 3 && xsVectorGetX(lookAtArea) > -1 && xsVectorGetZ(lookAtArea) > -1)
					{ //found land
						xsArraySetVector(shorelineArray, count ,lookAtArea); //record locaiton
						count++;
					}  //end if	
				}//end for i	
			} //end if
			currentSearchLocation = xsVectorSetX(currentSearchLocation, xsVectorGetX(currentSearchLocation) + range); //update currentSearchLocation with new X value
		} //end while						
		currentSearchLocation = xsVectorSetX(currentSearchLocation, xsVectorGetX(currentSearchLocation) - mapSizeX); //reset x location
		currentSearchLocation = xsVectorSetZ(currentSearchLocation, xsVectorGetZ(currentSearchLocation) + range); //move the z location
	} //end while				
	xsDisableSelf();
} //end areaFind


int Garrison(int buildID = -1, int unitType = -1, vector garrLocation = cInvalidVector)
{
	int planID = -1;
	int unitID = -1;
	vector v = garrLocation;//kbUnitGetPosition(buildID);//garrLocation;
	planID = aiPlanCreate("Garrison"+buildID,cPlanTransport);
	//planID = aiPlanCreate("Garrison"+buildID,cPlanTransport);
	aiPlanAddUnitType(planID,unitType,1,1,1);
	aiPlanSetVariableInt(planID,cTransportPlanTransportID,0,buildID);
	aiPlanSetVariableInt(planID,cTransportPlanTransportTypeID,0,kbGetUnitBaseTypeID(buildID));
	aiPlanSetVariableInt(planID,cTransportPlanPathType,0,cTransportPathTypePoints);
	aiPlanSetVariableBool(planID,cTransportPlanTakeMoreUnits,0,false);
	aiPlanSetVariableBool(planID,cTransportPlanPathPlanned,0,true);
	aiPlanSetVariableBool(planID,cTransportPlanPersistent,0,true);
	aiPlanSetVariableBool(planID,cTransportPlanReturnWhenDone,0,false); //no effect
	aiPlanSetVariableBool(planID,cTransportPlanMaximizeXportMovement,0,false); //no effect
	aiPlanSetVariableVector(planID,cTransportPlanGatherPoint,0, v);
	aiPlanSetVariableVector(planID,cTransportPlanTargetPoint,0, cOriginVector);
	aiPlanSetEventHandler(planID,cPlanEventStateChange,"Goto");
	aiPlanSetActive(planID,true);
	return(planID);
}

void Goto(int parm=-1)
{
	if ( aiPlanGetState(parm)!=cPlanStateEnter )return;
	
	if( getUnitCountByLocation(cUnitTypeAbstractVillager, cMyID, cUnitStateAlive, aiPlanGetVariableVector(parm, cTransportPlanGatherPoint, 0), 5.0) >= aiPlanGetNumberUnits(parm) - 3) 
	{
		aiPlanDestroy(parm);
	}
	
	if( getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cMyID, cUnitStateAlive, aiPlanGetVariableVector(parm, cTransportPlanGatherPoint, 0), 5.0) >= aiPlanGetNumberUnits(parm) - 3) 
	{
		aiPlanDestroy(parm);
	}
	//if ( GetUnitCount(cUnitTypeAbstractVillager, cMyID, aiPlanGetVariableVector(parm, cTransportPlanGatherPoint, 0), 5.0) >= aiPlanGetNumberUnits(parm) - 3) aiPlanDestroy(parm);
}	
//==============================================================================
// settlerGarrison
// updatedOn 2019/12/09 By ageekhere
//==============================================================================
//OOS ISSUES

rule settlerGarrison
active
minInterval 1
//void garrison()
{
	if(aiTreatyActive() == true)return;
	static int timeout = 0;
	if(timeout > 0) timeout = timeout - 1;
		

	if (kbGetAge() >= cAge2)
	{
		static int nearTC = -1;
		if (nearTC == -1) nearTC = kbUnitQueryCreate("nearTC");
		kbUnitQuerySetPlayerID(nearTC, cMyID, false);
		kbUnitQuerySetUnitType(nearTC, gTownCenter); 
		kbUnitQuerySetState(nearTC, cUnitStateAlive);
		kbUnitQueryResetResults(nearTC);
		
		static int nearBuilding = -1;
		if (nearBuilding == -1) nearBuilding = kbUnitQueryCreate("nearBuilding");
		kbUnitQuerySetPlayerID(nearBuilding, cMyID, false);
		kbUnitQuerySetUnitType(nearBuilding, cUnitTypeAbstractFort);
		kbUnitQuerySetState(nearBuilding, cUnitStateAlive);
		kbUnitQueryResetResults(nearBuilding);
		
		//static int enemyUnits = -1;
		//if (nearBuilding == -1) enemyUnits = kbUnitQueryCreate("enemyUnits");
		
		int settlerID = -1;
		int nearestId = -1;
		float lastDist = 999999;
		int buildingId = -1;
		float currentDist = 0;
		bool sendDefend = true;
		for (i = 0; < kbUnitCount(cMyID, gEconUnit, cUnitStateAlive))
		{
			settlerID = FIND(gEconUnit, cMyID, i);
			nearestId = -1;
			lastDist = 999999;
			buildingId = -1;
			
			for (t = 0; < kbUnitQueryExecute(nearTC))
			{
				buildingId = kbUnitQueryGetResult(nearTC, t);
				currentDist = distance(kbUnitGetPosition(settlerID), kbUnitGetPosition(buildingId));
				if (currentDist < lastDist)
				{
					lastDist = currentDist;
					nearestId = buildingId;
				}
			}
			
			for (t = 0; < kbUnitQueryExecute(nearBuilding))
			{
				buildingId = kbUnitQueryGetResult(nearBuilding, t);				
				if(kbUnitGetProtoUnitID(buildingId) == 299) continue;
				currentDist = distance(kbUnitGetPosition(settlerID), kbUnitGetPosition(buildingId));
				if (currentDist < lastDist)
				{
					lastDist = currentDist;
					nearestId = buildingId;
				}
			}
		
			if (getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, kbUnitGetPosition(settlerID), 15) > 3)
			{
				aiPlanDestroy(kbUnitGetPlanID(settlerID));
				//aiTaskUnitMove(settlerID, kbUnitGetPosition(nearestId) ); 
				aiTaskUnitWork(settlerID,nearestId);
				timeout = 10;
				if(sendDefend == true)
				{
					moveDefenseReflex(kbUnitGetPosition(settlerID), cvDefenseReflexRadiusActive, kbBaseGetMainID(cMyID));
					sendDefend = false;
				}
			}
			if(timeout == 0)
			{
				if (getUnitCountByLocation(cUnitTypeLogicalTypeLandMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, kbUnitGetPosition(nearestId), 30) < 3 && kbUnitGetNumberContained(nearestId) > 0)// && lastDist < 6)
				{
					aiTaskUnitEject(nearestId);
				}
			}
		}
	}
}



vector loadLocationBase = cInvalidVector;
vector loadLastLocation = cInvalidVector;
int shipLoadWaitTime = 0;
int shipLoadWaitSettlerTime = 0;
int currentLoadingShip = -1;
int offloadtry = 0;
bool skipSettler = false;
int loadSettlerPlan = -1;
int loadArmyPlan = -1;
int sentSettler = -1;
int ruleNavyTransportTime = 0;


void navyTransport()
{ //transports units accross water
	if ( (cRandomMapName == "amazonia") || (cRandomMapName == "caribbean") || (cRandomMapName == "ceylon") || (cRandomMapName == "volgadelta") )
	{
		bool passed = true;
	}
	else
	{
		return;
	}
	
	static int lastCalled = -1;
	int currentTime = xsGetTime();
	if((currentTime - lastCalled) < 10000) return;
	lastCalled = xsGetTime();
	if(getUnit(cUnitTypeHomeCityWaterSpawnFlag, cMyID) == -1)return; 
	if(getUnit(cUnitTypeShip, cMyID, cUnitStateAlive) == -1)return;
	if(loadLocationBase == cInvalidVector) loadLocationBase = kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID));
	
	static bool loadSettler = true;
	float dist = -1;
	float mapDistToEndMap = 0.0;
	float mapDistToshoreline = 0.0;
	float mapMaxDist = 0.0;
	vector mapEndLocation = cInvalidVector; 
	float halfSize = kbGetMapXSize() * 0.5;
	mapEndLocation = xsVectorSet( halfSize, 0, 0 );
	int trainsportShipLimit = 2;
	int addEnemyBuildingCount = 0;
	if(loadLocation == cInvalidVector || unloadLocation == cInvalidVector)
	{
		float lastLoadDistance = 999999999;
		float lastUnLoadDistance = 999999999;
		float lastDockDistance = 999999999;
		vector checkLoc = cInvalidVector; 
		int shorelineCount = 0;
		for(i = 0; < xsArrayGetSize(shorelineArray))
		{		
			if(xsArrayGetVector(shorelineArray,i) == cInvalidVector) break; //end of shorelineArray	
			
			mapDistToshoreline = distance( xsArrayGetVector(shorelineArray,i), kbGetMapCenter() );
			mapDistToEndMap = distance( mapEndLocation, kbGetMapCenter() );
			mapMaxDist = mapDistToEndMap - 100;
			if(mapDistToshoreline > mapMaxDist) continue;
			
			dist = distance( xsArrayGetVector(shorelineArray,i), loadLocationBase );
			checkLoc = xsArrayGetVector(shorelineArray,i); 
			
			int buildingCheck = kbUnitQueryCreate("buildingCheck");
			kbUnitQuerySetPlayerID(buildingCheck, cMyID);
			kbUnitQuerySetUnitType(buildingCheck, cUnitTypeBuildingClass);
			kbUnitQuerySetPosition(buildingCheck, checkLoc ); //set the location
			kbUnitQuerySetMaximumDistance(buildingCheck, 15);	
			kbUnitQuerySetIgnoreKnockedOutUnits(buildingCheck, true);
			kbUnitQuerySetState(buildingCheck, cUnitStateABQ);
			
			int enemyBuildingCheck = kbUnitQueryCreate("enemyBuildingCheck");
			kbUnitQuerySetPlayerRelation(enemyBuildingCheck, cPlayerRelationEnemyNotGaia);
			//kbUnitQuerySetPlayerID(enemyBuildingCheck, 1);
			kbUnitQuerySetUnitType(enemyBuildingCheck, cUnitTypeBuildingClass);
			kbUnitQuerySetPosition(enemyBuildingCheck, checkLoc ); //set the location
			kbUnitQuerySetMaximumDistance(enemyBuildingCheck, 16);	
			kbUnitQuerySetIgnoreKnockedOutUnits(enemyBuildingCheck, true);
			kbUnitQuerySetState(enemyBuildingCheck, cUnitStateAlive);
			
			for(j = 0; < kbUnitQueryExecute(enemyBuildingCheck))
			{
				bool donotAdd = false;
				for(t = 0; < xsArrayGetSize(shorelineEnemyBuildingsArray))
				{
					if(xsArrayGetInt(shorelineEnemyBuildingsArray,t) == kbUnitQueryGetResult(enemyBuildingCheck, j))
					{
						donotAdd = true;
						break;
					}
				}
				if(donotAdd == false)
				{
					xsArraySetInt(shorelineEnemyBuildingsArray, addEnemyBuildingCount, kbUnitQueryGetResult(enemyBuildingCheck, j) );
					addEnemyBuildingCount++;
				}
			}
			
			if( getUnit(gEconUnit, cMyID, cUnitStateAlive) != -1 && kbCanPath2( kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), loadLocation, kbUnitGetProtoUnitID(getUnit(gEconUnit, cMyID, cUnitStateAlive)), 1000 ) == false ) 
			{
				continue;
			}
			
			if(dist < lastLoadDistance && kbUnitQueryExecute(buildingCheck) == 0 && loadLastLocation != checkLoc)
			{
				lastLoadDistance = dist;
				loadLocation = checkLoc;
				loadLastLocation = checkLoc;
				shorelineCount++;
			}
			
			int enemyTowncenterId = getUnit(gTownCenter, aiGetMostHatedPlayerID(), cUnitStateAlive);
			if (enemyTowncenterId == -1)
			{
				dist = distance( xsArrayGetVector(shorelineArray,i), kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())) );
			}
			else
			{
				dist = distance( xsArrayGetVector(shorelineArray,i),kbUnitGetPosition(enemyTowncenterId) );
			}	
			
			checkLoc = xsArrayGetVector(shorelineArray,i); 
			if(dist < lastUnLoadDistance && 
				getUnitByLocation(cUnitTypeMilitary, cPlayerRelationEnemyNotGaia, cUnitStateAlive, checkLoc, 20.0) == -1 &&
				getUnitByLocation(cUnitTypeAbstractFort, cPlayerRelationEnemyNotGaia, cUnitStateAlive, checkLoc, 20.0) == -1 &&
			dist > 50 && dist < 100 && unloadLocation == cInvalidVector) //debug
			{
				lastUnLoadDistance = dist;
				unloadLocation = checkLoc; 
			}	
		}
	}
	
	if(unloadLocation == cInvalidVector) return;
	if(loadLocation == cInvalidVector) return;
	int transportShipId = currentLoadingShip;
	int currentlyTransportNumber = 0;
	for(j = 0; < xsArrayGetSize(transportShipsArray))
	{
		int shipCountId = xsArrayGetInt(transportShipsArray,j);
		if(shipCountId != -1)
		{
			currentlyTransportNumber++;		
		}
	}
	if(currentlyTransportNumber < trainsportShipLimit && transportShipId == -1 && currentShipTransport == -1)
	{
		int transportLastDist = 999999999;
		int transportShip = kbUnitQueryCreate("transportShip");
		kbUnitQuerySetPlayerID(transportShip, cMyID);
		kbUnitQuerySetUnitType(transportShip, cUnitTypeTransport);
		kbUnitQuerySetPosition(transportShip, loadLocation );
		kbUnitQuerySetAscendingSort(transportShip,true);	
		kbUnitQuerySetState(transportShip, cUnitStateAlive); 
		kbUnitQuerySetActionType(transportShip,7);
		int shipId = -1;
		bool skipShip = false;
		
		for (i = 0; < kbUnitQueryExecute(transportShip))
		{ //scan all ships that are under cap
			shipId = kbUnitQueryGetResult(transportShip, i);
			skipShip = false;	
			for(j = 0; < xsArrayGetSize(transportShipsArray))
			{
				if(xsArrayGetInt(transportShipsArray,j) == shipId && kbUnitGetHealth(xsArrayGetInt(transportShipsArray,j)) > 0) 
				{
					skipShip = true;
					break;
				}
			}
			if(skipShip == true) continue;
			
			if (skipShip == false && kbUnitGetNumberContained(shipId) < 20 && shipId != currentLoadingShip ) //&& dist < transportLastDist
			{
				transportShipId = shipId;
				currentShipTransport = shipId;
			}
			
			else if(currentLoadingShip == shipId)
			{
				transportShipId = currentLoadingShip;
				break;
			}
		}
	}
	if(transportShipId != -1 && loadLocation != cInvalidVector)
	{
		if(currentLoadingShip == -1) currentLoadingShip = transportShipId;
		if(shipLoadWaitTime == 0)shipLoadWaitTime = xsGetTime();
		
		dist = distance( loadLocation,kbUnitGetPosition(transportShipId) );
		if(dist > 50)
		{
			aiPlanDestroy(kbUnitGetPlanID(transportShipId));
			aiTaskUnitMove(transportShipId,loadLocation);
		}
		int gameTime = xsGetTime();
		if((gameTime - shipLoadWaitTime) > 300000)
		{
			shipLoadWaitTime = 0;
			loadLocation = cInvalidVector;
		}
	}
	
	if(aiPlanGetNumberUnits(loadSettlerPlan,gEconUnit) == 0)
	{
		loadSettler = true;		
		for(j = 0; < xsArrayGetSize(excludeSettlersArray))
		{
			if(xsArrayGetInt(excludeSettlersArray,j) == sentSettler)
			{
				xsArraySetInt(excludeSettlersArray, j, -1);
				break;
			}
		}
	}
	
	if(transportShipId != -1 && kbUnitGetActionType(transportShipId) == 7 && kbUnitGetNumberContained(transportShipId) == 0 && loadSettler == true)// && distance( loadLocation,kbUnitGetPosition(transportShipId) ) < 20)
	{
		
		//if(loadSettlerPlan == -1 && loadArmyPlan == -1) //&& sentSettler == -1)
		//{
			int settlerIsland = kbUnitQueryCreate("settlerIsland");
			kbUnitQuerySetPlayerID(settlerIsland, cMyID);
			kbUnitQuerySetUnitType(settlerIsland, cUnitTypeAffectedByTownBell);	
			//kbUnitQuerySetPosition(settlerIsland, loadLocation ); //set the location
			kbUnitQuerySetAscendingSort(settlerIsland,true);
			kbUnitQuerySetState(settlerIsland, cUnitStateAlive); 
			int settlerID = -1;
			bool doNotSendVills = false;
			for (i = 0; < kbUnitQueryExecute(settlerIsland))
			{
				settlerID = kbUnitQueryGetResult(settlerIsland, i);
				doNotSendVills = false;
				for(j = 0; < xsArrayGetSize(excludeSettlersArray))
				{	
					int xsettlerID = xsArrayGetInt(excludeSettlersArray,j);
					//if(xsArrayGetInt(excludeSettlersArray,j) == -1) break;
					
					if (xsettlerID == settlerID) 
					{
						doNotSendVills = true;
						break;
					}
				}
				
				if(doNotSendVills == false)
				{			
					for(j = 0; < xsArrayGetSize(excludeSettlersArray))
					{
						if(xsArrayGetInt(excludeSettlersArray,j) == -1)
						{
							xsArraySetInt(excludeSettlersArray, j, settlerID);
							break;
						}
					}
					
					aiPlanDestroy(kbUnitGetPlanID(settlerID));
					loadSettlerPlan = Garrison(transportShipId, gEconUnit,loadLocation);
					aiPlanAddUnit(loadSettlerPlan, settlerID);
					sentSettler = settlerID;
					loadSettler = false;
					
					if (shipLoadWaitSettlerTime == 0) shipLoadWaitSettlerTime = xsGetTime();
					int settgameTime = xsGetTime();
					if((settgameTime - shipLoadWaitSettlerTime) > 300000) skipSettler = true;
					break;
				}
				if(i == 50)
				{
					for(j = 0; < xsArrayGetSize(excludeSettlersArray))
					{
						xsArraySetInt(excludeSettlersArray, j, -1);
					}
					break;
				}
			}
		}
		
		if(transportShipId != -1 && kbUnitGetNumberContained(transportShipId) < 20 && (kbUnitGetNumberContained(transportShipId) != 0 || skipSettler == true) && kbUnitGetActionType(transportShipId) == 7 &&
		aiPlanGetNumberUnits(loadArmyPlan,cUnitTypeLogicalTypeLandMilitary) == 0)//distance( loadLocation,kbUnitGetPosition(transportShipId) ) < 20)
		{				
			loadLocation = kbUnitGetPosition(transportShipId);
			//if(loadArmyPlan != -1 )return;
			//	aiPlanDestroy(kbUnitGetPlanID(transportShipId));	
			aiPlanDestroy(loadSettlerPlan);	
			loadSettlerPlan = -1;
			
			int myTransport = kbUnitQueryCreate("myTransport");
			kbUnitQuerySetPlayerID(myTransport, cMyID);
			kbUnitQuerySetUnitType(myTransport, cUnitTypeLogicalTypeLandMilitary);
			kbUnitQuerySetPosition(myTransport, loadLocation ); //set the location
			kbUnitQuerySetMaximumDistance(myTransport, 1500);	
			kbUnitQuerySetAscendingSort(myTransport,true);
			kbUnitQuerySetIgnoreKnockedOutUnits(myTransport, true);
			kbUnitQuerySetState(myTransport, cUnitStateAlive);
			
			//if(loadArmyPlan == -1)
			//{			
				//aiChat(1,"army");
				int unitId = -1;
				loadArmyPlan = Garrison(transportShipId, cUnitTypeLogicalTypeLandMilitary,loadLocation);
				
				for (i = 0; < kbUnitQueryExecute(myTransport))
				{
					unitId = kbUnitQueryGetResult(myTransport, i);
					aiPlanDestroy(kbUnitGetPlanID(unitId));
					
					aiPlanAddUnit(loadArmyPlan, unitId);
					//aiTaskUnitMove(unitId,loadLocation);
					//aiTaskUnitWork(unitId,transportShipId);
					if(i == 25) break;
				}
				
			//}	
			
		}
		//aiChat(1,"onboard " + kbUnitGetNumberContained(transportShipId) );
		if(transportShipId != -1 && kbUnitGetNumberContained(transportShipId) > 19 && unloadLocation != cInvalidVector)
		{
			//aiChat(1,"Transport ship " + transportShipId + " is now full, going to " + unloadLocation);
			aiPlanDestroy(loadArmyPlan);
			loadArmyPlan = -1;
			currentLoadingShip = -1;
			aiPlanDestroy(loadSettlerPlan);	
			loadSettlerPlan = -1;
			loadSettler = true;
			
			aiPlanDestroy(kbUnitGetPlanID(transportShipId));
			aiTaskUnitMove(transportShipId,unloadLocation);
			unloadLocation = cInvalidVector;
			sendNavyForLanding = true;
			bool excludeShip = false;
			skipSettler = false;
			currentShipTransport = -1;
			//	sentSettler = -1;
			
			for(i = 0; < xsArrayGetSize(transportShipsArray))
			{
				if(xsArrayGetInt(transportShipsArray,i) == transportShipId) 
				{
					excludeShip = true;
					break;	
				}
			}
			if(excludeShip == false)
			{
				for(i = 0; < xsArrayGetSize(transportShipsArray))
				{
					if(xsArrayGetInt(transportShipsArray,i) == -1) 
					xsArraySetInt(transportShipsArray, i ,transportShipId);
					//aiChat(1,"Excluding Transport " + transportShipId + " ship from loading untill offload is complete");
					break;
				}
			}
		}
		
		for(j = 0; < xsArrayGetSize(transportShipsArray))
		{
			int shipToSend = xsArrayGetInt(transportShipsArray,j);
			if(kbUnitGetHealth(shipToSend) == 0 && shipToSend != -1) xsArraySetInt(transportShipsArray, j ,-1);
			if(shipToSend != -1 && unloadLocation != cInvalidVector)
			{
				//			aiChat(1,"Resending unload locaition to " + shipToSend);
				//aiPlanDestroy(kbUnitGetPlanID(shipToSend));
				aiTaskUnitMove(shipToSend,unloadLocation);
			}
		}
		
		for(j = 0; < xsArrayGetSize(transportShipsArray))
		{
			int shipToUnload = xsArrayGetInt(transportShipsArray,j);
			if(kbUnitGetHealth(shipToUnload) == 0) xsArraySetInt(transportShipsArray, j ,-1);
			
			if(shipToUnload != -1)
			{
				float currentUnLoadDist = distance( unloadLocation, kbUnitGetPosition(shipToUnload));
				//			aiChat(1,"Transport ship " + shipToUnload + " is " + currentUnLoadDist + " away from unload location");
				
				if(currentUnLoadDist < 150 && kbUnitGetActionType(shipToUnload) == 7)
				{
					//aiChat(1,"Transport ship " + shipToUnload + " is tring to offload, i have " + kbUnitGetNumberContained(shipToUnload) + " units on board");
					aiTaskUnitEject(shipToUnload);
					offloadtry++;
					if(kbUnitGetNumberContained(shipToUnload) == 0)
					{
						//aiChat(1,"Transport ship " + shipToUnload + " offloaded completed");
						offloadtry = 0;
						xsArraySetInt(transportShipsArray, j ,-1);
						unloadLocation = cInvalidVector;
						aiTaskUnitMove(shipToUnload,loadLocation);
						xsEnableRule("transportBaseBuild");
						newAttack();	
					}
					if(offloadtry == 3) unloadLocation = cInvalidVector;	
				}
			}
		}
		
	}
	
	int aiPlanIslandTrain( int proto_unit = -1, int num_to_maintain = 200, int batch_size = 5, int train_from = -1, int pri = 100 )
	{
		int plan_train = -1;
		//if(plan_train != -1) return(-1);
		plan_train = aiPlanCreate( "Maintain " + kbGetProtoUnitName( proto_unit ), cPlanTrain );
		aiPlanSetDesiredPriority( plan_train, pri );
		aiPlanSetEscrowID( plan_train, cRootEscrowID );
		aiPlanSetVariableInt( plan_train, cTrainPlanFrequency, 0, 1 );
		aiPlanSetVariableInt( plan_train, cTrainPlanBuildingID, 0, train_from );
		aiPlanSetVariableInt( plan_train, cTrainPlanUnitType, 0, proto_unit );
		aiPlanSetVariableInt( plan_train, cTrainPlanNumberToMaintain, 0, num_to_maintain );
		aiPlanSetVariableBool( plan_train, cTrainPlanUseMultipleBuildings, 0, false );
		// aiPlanSetVariableInt( plan_train, cTrainPlanMaxQueueSize, 0, 5 );
		aiPlanSetVariableInt( plan_train, cTrainPlanBatchSize, 0, batch_size );
		aiPlanSetActive( plan_train, true );
		return( plan_train );
		
	}
	
	bool stopBuild = false;
	rule transportBaseBuild
	inactive
	minInterval 10
	{
		int barracksType = cUnitTypeAbstractBarracks2;
		int stableType = cUnitTypeAbstractStables;
		int artDepotType = cUnitTypeAbstractFoundry;
		
		int artDepotUnit = cUnitTypeFalconet;
		int stableUnit = cUnitTypeHussar;
		int barracksUnit = cUnitTypePikeman;
		
		switch (kbGetCiv())
		{
			case cCivBritish:
			{
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypeHussar;
				artDepotUnit = cUnitTypeFalconet;	
				break;
			}
			
			case cCivFrench:
			{	
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypeCuirassier;
				artDepotUnit = cUnitTypeFalconet;	
				break;
			}
			case cCivJapanese:
			{
				barracksUnit = cUnitTypeypKensei;
				stableUnit = cUnitTypeypNaginataRider;
				artDepotUnit = cUnitTypeypFlamingArrow;		
				break;
			}
			case cCivSpanish:
			{
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypeLancer;
				artDepotUnit = cUnitTypeFalconet;		
				break;
			}
			
			case cCivPortuguese:
			{	
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypeCavalaria;
				artDepotUnit = cUnitTypeOrganGun;	
				break;
			}
			
			case cCivDutch:
			{	
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypeHussar;
				artDepotUnit = cUnitTypeFalconet;
				break;
			}
			
			case cCivRussians:
			{	
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypeOprichnik;
				artDepotUnit = cUnitTypeFalconet;	
				break;
			}
			
			case cCivGermans:
			{	
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypeWarWagon;
				artDepotUnit = cUnitTypeFalconet;
				break;
			}
			
			case cCivOttomans:
			{	
				barracksUnit = cUnitTypeJanissary;
				stableUnit = cUnitTypeSpahi;
				artDepotUnit = cUnitTypeFalconet;
				break;
			}
			
			case cCivXPIroquois:
			{	
				barracksUnit = cUnitTypexpTomahawk;
				stableUnit = cUnitTypexpHorseman;
				artDepotUnit = cUnitTypexpLightCannon;
				break;
			}
			
			case cCivXPSioux:
			{	
				barracksUnit = cUnitTypexpWarClub;
				stableUnit = cUnitTypexpAxeRider;
				artDepotUnit = cUnitTypexpCoupRider;
				break;
			}
			
			case cCivXPAztec:
			{	
				barracksUnit = cTechEliteCoyotemen;
				stableUnit = cUnitTypeNatHuaminca;
				artDepotUnit = cUnitTypexpCoupRider;	
				break;
			}
			case cCivUSA:
			{
				barracksUnit = cUnitTypeUSColonialMarines;
				stableUnit = cUnitTypeSaber;
				artDepotUnit = cUnitTypeFalconet;
				break;
			}
			
			case cCivSwedish:
			{
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypePistolS;
				artDepotUnit = cUnitTypeFalconet;
				break;
			}
			
			case cCivItalians:
			{
				barracksUnit = cUnitTypePikeman;
				stableUnit = cUnitTypeHussar;
				artDepotUnit = cUnitTypeSaker;
				break;
			}
			
			case cCivIndians:
			{
				barracksUnit = cUnitTypeypRajput;
				stableUnit = cUnitTypeypMahoutMansabdar;
				artDepotUnit = cUnitTypeypMercFlailiphantMansabdar;
				break;
			}
			
			case cCivChinese:
			{
				barracksUnit = cUnitTypeypMingArmy;
				stableUnit = cUnitTypeypForbiddenArmy;
				artDepotUnit = cUnitTypeypFlameThrower;
				break;
			}
		}
		int unitId = -1;
		
		int islandBase = kbUnitQueryCreate("islandBase");
		kbUnitQuerySetPlayerID(islandBase, cMyID);
		kbUnitQuerySetUnitType(islandBase, cUnitTypeMilitaryBuilding);
		kbUnitQuerySetPosition(islandBase, unloadLocation ); //set the location
		kbUnitQuerySetMaximumDistance(islandBase, 25);	
		kbUnitQuerySetIgnoreKnockedOutUnits(islandBase, true);
		kbUnitQuerySetState(islandBase, cUnitStateAlive);
		
		int countBarracks = 0;
		int countStable = 0;
		int countArtDepot = 0;
		
		for (i = 0; < kbUnitQueryExecute(islandBase))
		{
			unitId = kbUnitQueryGetResult(islandBase, i);
			if(kbUnitIsType(unitId, gBarracksUnit) == true) 
			{
				aiTaskUnitTrain( unitId, barracksUnit );
				aiTaskUnitTrain( unitId, barracksUnit );
				aiTaskUnitTrain( unitId, barracksUnit );
				aiTaskUnitTrain( unitId, barracksUnit );
				aiTaskUnitTrain( unitId, barracksUnit );
				if(kbUnitGetPlanID(unitId) == -1) aiPlanIslandTrain(barracksUnit, 200, 10, unitId, 100);
				countBarracks++;
			}
			
			if(kbUnitIsType(unitId, gStableUnit) == true) 
			{
				aiTaskUnitTrain( unitId, stableUnit );
				aiTaskUnitTrain( unitId, stableUnit );
				aiTaskUnitTrain( unitId, stableUnit );
				aiTaskUnitTrain( unitId, stableUnit );
				aiTaskUnitTrain( unitId, stableUnit );
				if(kbUnitGetPlanID(unitId) == -1) aiPlanIslandTrain(stableUnit, 200, 20, unitId, 100);
				countStable++;
			}
			if(kbUnitIsType(unitId, gArtilleryDepotUnit) == true) 
			{
				aiTaskUnitTrain( unitId, artDepotUnit );
				aiTaskUnitTrain( unitId, artDepotUnit );
				aiTaskUnitTrain( unitId, artDepotUnit );
				aiTaskUnitTrain( unitId, artDepotUnit );
				aiTaskUnitTrain( unitId, artDepotUnit );
				if(kbUnitGetPlanID(unitId) == -1) aiPlanIslandTrain(artDepotUnit, 200, 10, unitId, 100);
				countArtDepot++;
			}
		}
		
		int totalBuildings = countBarracks + countStable + countArtDepot;
		if(totalBuildings > 0 )
		{
			islandLanded = true;
			islandLandedLocationUnit = unitId;
		}
		if(totalBuildings == 0 )islandLanded = false;
		
		if(countBarracks < 3) createLocationBuildPlan(gBarracksUnit, 1, 97, false, cMilitaryEscrowID, unloadLocation, 1);
		if(countStable < 3) createLocationBuildPlan(gStableUnit, 1, 97, false, cMilitaryEscrowID, unloadLocation, 1);
		if(countArtDepot < 3) createLocationBuildPlan(gArtilleryDepotUnit, 1, 97, false, cMilitaryEscrowID, unloadLocation, 1);
		
		
		if(kbUnitQueryExecute(islandBase) > 0)
		{
			if( kbUnitCount(cMyID, gTowerUnit) != kbGetBuildLimit(cMyID,gTowerUnit) )
			{
				createLocationBuildPlan(gTowerUnit, 2, 97, false, cMilitaryEscrowID, unloadLocation, 1);
			}
		}
		
		
		if( kbResourceGet(cResourceWood) > 1500 &&
			kbBaseGetUnderAttack(cMyID, kbBaseGetMainID(cMyID)) == false &&
			kbUnitCount(cMyID, gTowerUnit, cUnitStateAlive) == kbGetBuildLimit(cMyID,gTowerUnit) &&
		kbUnitQueryExecute(islandBase) > 2)
		{
			int deleteOutpost = kbUnitQueryCreate("deleteOutpost");
			kbUnitQuerySetPlayerID(deleteOutpost, cMyID,false);
			kbUnitQuerySetUnitType(deleteOutpost, gTowerUnit);
			kbUnitQuerySetPosition(deleteOutpost, kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)) ); //set the location
			kbUnitQuerySetMaximumDistance(deleteOutpost, 100);	
			kbUnitQuerySetIgnoreKnockedOutUnits(deleteOutpost, true);
			kbUnitQuerySetState(deleteOutpost, cUnitStateAlive);
			
			int outpostId = -1;
			for (i = 0; < kbUnitQueryExecute(deleteOutpost))
			{
				outpostId = kbUnitQueryGetResult(deleteOutpost, i);
				aiTaskUnitDelete(outpostId);
			}
		}
		
		
		vector attackLocation = cInvalidVector;
		if(getUnit(gTownCenter, aiGetMostHatedPlayerID(), cUnitStateAlive) != -1)
		{
			attackLocation = kbUnitGetPosition(getUnit(gTownCenter, aiGetMostHatedPlayerID(), cUnitStateAlive));
		}
		else
		{
			attackLocation = kbUnitGetPosition(getUnit(cUnitTypeBuildingClass, aiGetMostHatedPlayerID(), cUnitStateAlive));
		}
		int islandArmy = kbUnitQueryCreate("islandArmy");
		kbUnitQuerySetPlayerID(islandArmy, cMyID,false);
		kbUnitQuerySetUnitType(islandArmy, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetPosition(islandArmy, unloadLocation); //set the location
		kbUnitQuerySetMaximumDistance(islandArmy, 30);	
		kbUnitQuerySetIgnoreKnockedOutUnits(islandArmy, true);
		kbUnitQuerySetState(islandArmy, cUnitStateAlive);
		
		unitId = -1;
		if(kbUnitQueryExecute(islandArmy) > 15)
		{
			//aiChat(1,"Now moving island army to attack " + attackLocation);
			for (i = 0; < kbUnitQueryExecute(islandArmy))
			{
				unitId = kbUnitQueryGetResult(islandArmy, i);
				aiTaskUnitMove(unitId,attackLocation);		
			}
			
		}
		
		///}
		
		
		for(i = 0; < xsArrayGetSize(excludeSettlersArray))
		{
			int excludeId = xsArrayGetInt(excludeSettlersArray,i);
			bool foundVill = false;
			
			for (j = 0; < kbUnitCount(cMyID, cUnitTypeAffectedByTownBell, cUnitStateAlive))
			{
				
				unitId = FIND(cUnitTypeAffectedByTownBell, cMyID, j);
				
				if(excludeId == unitId)
				{
					foundVill = true;
					break;
				}
			}
			
			if(foundVill == false)
			{
				xsArraySetInt(excludeSettlersArray, i, -1);
			}
			
		}
		
	}
	/* not ready yet
		rule rushMod
		active
		minInterval 10
		{
		if(kbGetCiv() == cCivBritish)
		{
		int rushArmy = kbUnitQueryCreate("rushArmy");
		kbUnitQuerySetPlayerID(rushArmy, cMyID,false);
		kbUnitQuerySetUnitType(rushArmy, cUnitTypeLogicalTypeLandMilitary);
		kbUnitQuerySetIgnoreKnockedOutUnits(rushArmy, true);
		kbUnitQuerySetState(rushArmy, cUnitStateAlive);
		kbUnitQuerySetActionType(rushArmy,7);
		
		vector attackLocation = cInvalidVector;
		
		if( kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID())) != cInvalidVector)
		{
		attackLocation = kbBaseGetLocation(aiGetMostHatedPlayerID(), kbBaseGetMainID(aiGetMostHatedPlayerID()));
		}
		
		if(kbUnitQueryExecute(rushArmy) > 5)
		{
		for (i = 0; < kbUnitQueryExecute(rushArmy))
		{
		aiTaskUnitMove(kbUnitQueryGetResult(rushArmy, i),attackLocation);
		}
		}
		
		aiSetMilitaryPop(200);	
		gGoodArmyPop = aiGetMilitaryPop(); /// 
		}
		}
	*/
	extern int tradePostManagerTime = 0;
	void tradePostManager()
	{ //Controls when the ai builds VP sites
		if(xsGetTime() - tradePostManagerTime < 60000) return;
		tradePostManagerTime = xsGetTime();
		if(kbGetAge() == cAge1) return;
		if(kbUnitCount(cMyID, gStableUnit, cUnitStateAlive) + kbUnitCount(cMyID, gBarracksUnit, cUnitStateAlive) == 0 )return;
		if(kbGetAge() == cAge2 && kbUnitCount(cMyID, cUnitTypeVictoryPointBuilding, cUnitStateABQ) > 1 )return;
		
		static int vpSiteArray = -1;
		int tradepostQuery = -1; 
		//search for VP sites
		if (tradepostQuery == -1) tradepostQuery = kbUnitQueryCreate("tradepostQuery");	
		kbUnitQuerySetPlayerID(tradepostQuery, 0);
		kbUnitQuerySetUnitType(tradepostQuery, cUnitTypeSocket);
		kbUnitQuerySetState(tradepostQuery, cUnitStateAlive);
		kbUnitQueryResetResults(tradepostQuery);
		kbUnitQuerySetPosition(tradepostQuery,  kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID))); 
		kbUnitQuerySetAscendingSort(tradepostQuery,true);
		int vpList = kbUnitQueryExecute(tradepostQuery);
		int siteID = -1;
		int tradepostPlan = -1;
		if(vpSiteArray == -1) vpSiteArray = xsArrayCreateInt(vpList, -1, "VPsites");
		for(i = 0; < kbUnitQueryExecute(tradepostQuery))
		{
			if(i == 1 && kbGetAge() == cAge2)return;
			if(i == 2 && kbGetAge() == cAge3)return;
			if(aiPlanGetState(xsArrayGetInt(vpSiteArray,i)) != -1) continue;
			siteID = kbUnitQueryGetResult(tradepostQuery, i);
			if(aiTreatyActive() == true && distance(kbBaseGetLocation(cMyID, kbBaseGetMainID(cMyID)), kbUnitGetPosition(siteID)) > 20 )continue;	
			//check for free VP site
			static int availableVPCheck = -1; 
			if (availableVPCheck == -1) availableVPCheck = kbUnitQueryCreate("availableVPCheck");
			kbUnitQuerySetPlayerRelation(availableVPCheck,cPlayerRelationAny);
			kbUnitQuerySetUnitType(availableVPCheck, cUnitTypeVictoryPointBuilding);//cUnitTypeCountsTowardMilitaryScore
			kbUnitQuerySetPosition(availableVPCheck, kbUnitGetPosition(siteID) );
			kbUnitQuerySetMaximumDistance(availableVPCheck, 5);
			kbUnitQuerySetIgnoreKnockedOutUnits(availableVPCheck, true);
			kbUnitQuerySetState(availableVPCheck, cUnitStateABQ);
			kbUnitQueryResetResults(availableVPCheck);
			if (kbUnitQueryExecute(availableVPCheck) > 0) continue;
			//check for enemy
			static int enemyCheck = -1; 
			if (enemyCheck == -1) enemyCheck = kbUnitQueryCreate("enemyCheck");
			kbUnitQuerySetPlayerRelation(enemyCheck,cPlayerRelationEnemyNotGaia);
			kbUnitQuerySetUnitType(enemyCheck, cUnitTypeCountsTowardMilitaryScore);//
			kbUnitQuerySetPosition(enemyCheck, kbUnitGetPosition(siteID) );
			kbUnitQuerySetMaximumDistance(enemyCheck, 20);
			kbUnitQuerySetIgnoreKnockedOutUnits(enemyCheck, true);
			kbUnitQuerySetState(enemyCheck, cUnitStateABQ);
			kbUnitQueryResetResults(enemyCheck);
			if (kbUnitQueryExecute(enemyCheck) > 1) continue;
			//make a new build plan
			aiPlanDestroy(aiPlanGetState(xsArrayGetInt(vpSiteArray,i)));
			tradepostPlan = aiPlanCreate("tradepostPlan "+i, cPlanBuild);	
			aiPlanSetVariableInt(tradepostPlan, cBuildPlanBuildingTypeID, 0, cUnitTypeTradingPost );
			aiPlanSetDesiredPriority(tradepostPlan, 100); //80
			aiPlanSetMilitary(tradepostPlan, false);
			aiPlanSetEconomy(tradepostPlan, true);
			aiPlanSetEscrowID(tradepostPlan, cEconomyEscrowID);
			aiPlanAddUnitType(tradepostPlan, gEconUnit, 1, 1, 1);
			aiPlanSetVariableInt(tradepostPlan, cBuildPlanSocketID, 0, siteID);
			aiPlanSetActive(tradepostPlan);
			xsArraySetInt(vpSiteArray,i, tradepostPlan);
		}
	}
	
	
	extern float timeTaken = 0;
	extern int player = 2;
	extern int currentTask = 0;
	extern bool turnOver = false;
	//rule mainTimer
	//active
	//minInterval 30
	void mainRules()
	{
		if(kbIsPlayerHuman(player) == true || kbIsPlayerResigned(player) == true) 
		{
			if(player < cNumberPlayers)
			{
				player++;
			}
			else
			{
				player = 2;
			}
			return;
		}
		bool breakWhile = false;
		int taskCompleted = 0;
		int taskCap = 25; //total tasks
		//cNumberPlayers
		switch (cNumberPlayers)
		{
			case 3:{taskCap = 25; break;}
			case 4:{taskCap = 25; break;}
			case 5:{taskCap = 25; break;}
			case 6:{taskCap = 12; break;}
			case 7:{taskCap = 12; break;}
			case 8:{taskCap = 12; break;}
			case 9:{taskCap = 12; break;}
		}
		//if(xsGetTime()>1200000) taskCap = taskCap /2; //20 mins
		//Must always run
		
		checkIdleVill();
		while (breakWhile == false)
		{
			switch (currentTask)
			{
				case 0:
				{
					if (player == cMyID ) popManager();
					break;
				}
				case 1:
				{
					if (player == cMyID )buildEconomy();
					break;
				}
				case 2:
				{
					if (player == cMyID )make_2nd_fort();
					break;
				}
				case 3:
				{
					if (player == cMyID )livestockManager();
					break;
				}
				case 4:
				{
					if (player == cMyID )livestockPenMonitor();
					break;
				}
				case 5:
				{
					if (player == cMyID )livestockFatten();
					break;
				}
				case 6:
				{
					if (player == cMyID )MonitorHerding();
					break;
				}
				
				case 7:
				{
					if (player == cMyID )call_levies(); 
					break;
				}
				
				case 8:
				{
					if (player == cMyID )market_exchanges();	
					break;
				}
				case 9:
				{
					if (player == cMyID )spy();
					break;					
				}	
				case 10:
				{
					if (player == cMyID )mostHatedEnemy();
					break;					
				}
				case 11:
				{
					if (player == cMyID )delayWalls();
					break;					
				}
				case 12:
				{
					if (player == cMyID )buildNewTC();	
					break;
				}			
				case 13:
				{
					if (player == cMyID )waterAttack();//waterAttackDefend();	
					break;
				}	
				case 14:
				{
					if (player == cMyID )researchTech();	
					break;	 			
				}	
				case 15:
				{
					if (player == cMyID )targetAttackTimer();	
					break;					
				}
				case 16:
				{
					if (player == cMyID )useCoveredWagons();	
					break;					
				}	
				case 17:
				{
					if (player == cMyID )forwardBaseManager(); break;					
				}
				case 18:
				{
					if (player == cMyID )useFactoryWagons();	
					break;					
				}				
				case 19:
				{
					if (player == cMyID )outpostWangonManager();	
					break;					
				}	
				case 20:
				{
					if (player == cMyID )useBankWagons();	
					break;					
				}	
				
				case 21:
				{
					if (player == cMyID )navyTransport();	
					break;					
				}	
				
				case 22:
				{
					if (player == cMyID )militaryRaid();	
					break;					
				}
				
				case 23:
				{
					if (player == cMyID )tradePostManager();	
					break;					
				}	
				
				case 24:
				{
					if (player == cMyID )capitolArmyManager();	
					break;					
				}	
				
				
				
				default: 
				{
					turnOver = true;
					breakWhile = true;
					
				}
			}
			taskCompleted++;
			
			currentTask++;
			
			if(taskCompleted == taskCap) 
			{
				return;		
			}	
		}
		
		if (turnOver == true)
		{
			turnOver = false;
			currentTask = 0;
			if (player != cNumberPlayers - 1)
			{
				//aiChat(1,"player " + player + " is done" + " startTimer " + startTime + " end time " + xsGetTime());
				//kbIsPlayerHuman USE only ai not human
				player++;
			}
			else
			{
				player = 2;
			}
		}
	}
	
	rule mainTimer
	active
	minInterval 2
	{	
		mainRules();
		//aiChat(1,"found plan " + aiPlanGetNumber(cPlanTownBell, -1,true));
		//aiChat(1,"plan id " + aiPlanGetIDByIndex( cPlanTownBell, -1 ,true,0) );
		//int planBell = aiPlanGetIDByIndex( cPlanTownBell, -1 ,true,0);	
		//if(planBell != -1)aiPlanDestroy(planBell);

		
//aiChat(1," food " + kbResourceGet(cResourceFood) + " wood " + kbResourceGet(cResourceWood) + " coin " + kbResourceGet(cResourceGold) + " fame " +  kbResourceGet(cResourceFame));
	}
	
	/*
		//aiChat(1," food " + kbResourceGet(cResourceFood) + " wood " + kbResourceGet(cResourceWood) + " coin " + kbResourceGet(cResourceGold) + " fame " +  kbResourceGet(cResourceFame));
		for(i = 0; < 1000)
		{
		string getId = aiPlanGetName(i);
		if(getId != "")
		{
		aiChat(1, "plan " + aiPlanGetName(i) );
		}
		}
		int total=aiPlanGetNumber(-1, -1, true) + aiPlanGetNumber(-1, -1, false);
		aiChat(1,"total " + total);
	*/	









